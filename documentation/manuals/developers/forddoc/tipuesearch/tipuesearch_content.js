var tipuesearch = {"pages":[{"text":"Fortran Program","tags":"","loc":"index.html","title":" Fortran Program "},{"text":"Source Code program test_command_argument_count integer :: count count = command_argument_count () if ( count . gt . - 1 ) then print * , count end if end program test_command_argument_count","tags":"","loc":"sourcefile/argcount.f90.html","title":"argcount.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2004 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  avetr.f90 !  average coordinates from Qdyn trajectory files and write pdb-structure !  Added to Qprep March 2004 by Martin Nervall !  Tested to reproduce average structures from vmd !------------------------------------------------------------------------------! module avetr use prep implicit none integer , parameter :: ave_pdb = 11 integer ( 4 ), private :: ncoords , N_sets = 0 real ( 4 ), allocatable , private :: x_in (:), x_sum (:), x2_sum (:) real ( 8 ), private :: rmsd contains !TODO: *choose which frames, add more trajectories, divide x_sum every 100 steps !------------------------------------------------------------------------------! !  Main subroutine !------------------------------------------------------------------------------! subroutine avetr_calc integer :: i , allocation_status character ( len = 1 ) :: ans logical :: fin N_sets = 0 call trajectory ncoords = trj_get_ncoords () allocate ( x_in ( ncoords ), x_sum ( ncoords ), x2_sum ( ncoords ), & stat = allocation_status ) if ( allocation_status . ne . 0 ) then write ( * , * ) 'Out of memory!' return end if do while ( trj_read_masked ( x_in )) !add from first file call add_coordinates end do !add from multiple files fin = . false . do while (. not . fin ) CALL get_string_arg ( ans , '-----> Add more frames? (y or n): ' ) if ( ans . eq . 'y' ) then call trajectory do while ( trj_read_masked ( x_in )) !add from additional files call add_coordinates end do else fin = . true . end if end do call average call write_average deallocate ( x_in , x_sum , x2_sum , stat = allocation_status ) end subroutine avetr_calc !------------------------------------------------------------------------------! !  Sum the coordinates and the squared coordinates !------------------------------------------------------------------------------! subroutine add_coordinates x_sum = x_sum + x_in x2_sum = x2_sum + x_in ** 2 N_sets = N_sets + 1 end subroutine add_coordinates !------------------------------------------------------------------------------! !  Make average and rmsd !------------------------------------------------------------------------------! subroutine average x_sum = x_sum / N_sets x2_sum = x2_sum / N_sets rmsd = sqrt ( sum ( x2_sum - x_sum ** 2 ) / ncoords ) end subroutine average !------------------------------------------------------------------------------! !  Write average coords to pdb file. !  Variables used from prep: mask !  Variables used from topo: xtop !------------------------------------------------------------------------------! subroutine write_average !assign masked coordinates to right atom in topology call mask_put ( mask , xtop , x_sum ) call writepdb write ( * , '(a,f6.3,a)' ) 'Root mean square coordinate deviation ' , rmsd , ' A' x_sum = 0 x2_sum = 0 end subroutine write_average end module avetr","tags":"","loc":"sourcefile/avetr.f90.html","title":"avetr.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  calc_base.f90 !  by John Marelius !  shared data for trajectory calculation modules !------------------------------------------------------------------------------! module calc_base use topo implicit none real ( 8 ), allocatable :: xin (:) ! All functions share this vector which contains a frame (J) ! real(8), allocatable :: xin2d(:,:) ! Schlitters formula needs all coordinates at the same time end module calc_base","tags":"","loc":"sourcefile/calc_base.f90.html","title":"calc_base.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  calc_chemscore.f90 !  Kajsa Ljungberg 1998-06-11 !  Implementation of a scoring function by Eldridge et al. !  JCAMD 11 (1997) 425-445. !  Integration into QCalc5 by Peter Hanspers !------------------------------------------------------------------------------! module calc_chemscore use calc_base use maskmanip use trj use prmfile use indexer use qatom implicit none real :: score integer :: frame integer :: stat integer :: i character ( len = 4 ) :: trj_type character * 80 :: top_file , fep_file type score_precalc_type character ( len = 80 ) :: chFilename ! name of re file if one is given integer :: iType ! 1 = top calculation, 2 = restart calculation end type score_precalc_type type score_type ! structure tp keep track of scoring data character ( len = 80 ) :: chFilename ! either name of restart file, 'top' or empty if trajectory frame integer :: frame ! empty if chReFilename is present real ( 8 ) :: score real ( 8 ) :: h_bonds real ( 8 ) :: metal real ( 8 ) :: lipophil real ( 8 ) :: rot_bond end type score_type !constants integer , parameter :: MAX_MASKS = 10 !module variables type ( SCORE_PRECALC_TYPE ), pointer , private :: aPrecalc (:) ! array of pre-calculations integer , private :: iPrecalc ! current number of pre-calcs added integer , private :: maxPrecalc ! number of pre-calc elements allocated type ( SCORE_TYPE ), pointer , private :: aScore (:) ! framewise scoring info integer :: nScores , maxScores ! number of elements in aScore, number of allocated elements of aScore type ( MASK_TYPE ), private , target :: masks ( MAX_MASKS ) integer , private :: Nmasks = 0 type SCORE_COORD_TYPE real ( 8 ), pointer :: xr (:) real ( 8 ) :: xrcm ( 3 ) end type SCORE_COORD_TYPE type ( SCORE_COORD_TYPE ), private :: coords ( MAX_MASKS ) type wat integer ( AI ) :: O , H1 , H2 !topology numbers real :: score !H-bond score with receptor end type wat type donor integer ( AI ) :: heavy , hydr !topology numbers for atoms in H-bond donor end type donor type lipos !return type for lip_atom integer :: n_lip !number of lipophilic atoms integer :: n_nonlip !number of heavy, non-lipophilic atoms end type lipos type bond_pointer !pointer to the datatype q_bond type ( q_bond ), pointer :: qb !needed for array of q_bonds in type q_atom end type bond_pointer type q_atom integer :: top_nr ! atom number in topology integer :: n !number of bonds type ( bond_pointer ), dimension ( 1 : 6 ) :: bd !pointers to the bonds logical :: contact !if     closer than r to any receptor atom integer :: at_type !if lipophilic 2, if other heavy 1, if hydrogen 0 integer :: hybrid !if included sp3 then 3, if included sp2 then 2, others 0 logical :: been_there !flag used in recursive routines, to avoid eternal loops logical , pointer :: cyclic (:) !array of logicals, one for each ring, true if part of that ring logical :: active !same as been_there end type q_atom type q_bond type ( q_atom ), pointer :: a , b !pointers to two bonded atoms logical :: rotatable !if not part of ring and sp3-sp3 or sp3-sp2 bond logical :: acontact , bcontact !if a and b in contact with receptor, only used if rotatable logical :: been_there integer :: a_nonlip , b_nonlip !number of non-lipophilic heavy atoms on a-side and b-side of bond integer :: a_lip , b_lip !number of lipophilic heavy atoms on a-side and b-side of bond logical , pointer :: cyclic (:) logical :: active end type q_bond integer ( AI ), allocatable :: lph_r (:) !topology number for all lipophilic atoms in the receptor integer ( AI ), allocatable :: lph_l (:) !                               ''                                                   the ligand type ( donor ), allocatable :: hbd_r (:) !H-bond donor in receptor type ( donor ), allocatable :: hbd_l (:) !  ''            ligand integer ( AI ), allocatable :: hba_r (:) !H-bond acceptor atoms in receptor integer ( AI ), allocatable :: hba_l (:) !      ''                 ligand integer ( AI ), allocatable :: met_r (:) !metal atoms in the receptor type ( wat ), allocatable :: waters (:) !water molecules integer , allocatable :: pol_con (:) !connections for potentially polar atoms type ( q_atom ), private , allocatable , target :: q_atoms (:) ! atoms in ligand type ( q_bond ), private , allocatable , target :: q_bonds (:) ! bonds in ligand !numbers of each of the atom types integer :: nlph_r , nlph_l , nhbd_r , nhbd_l integer :: nhba_r , nhba_l , nmet_r , nwaters , nqbonds integer :: nhbd_prot , nhba_prot integer :: nrings !number of rings in the ligand !lists of the atom type categories integer , parameter :: LIPO = 1 , METAL = 2 , SULPHUR = 3 , ACCEPTOR = 4 integer , parameter :: SP3 = 5 , SP2 = 6 , SP3_N = 7 , PL_N = 8 integer , parameter :: HYDROGEN = 9 , OXYGEN = 10 , CARBON_LIPO = 11 integer , parameter :: CARBONYL_CARBON = 12 , CARBONYL_OXYGEN = 13 integer , parameter :: NPROPS = 13 character * ( * ), parameter :: file_heading ( NPROPS ) = [ & 'lipophilic     ' , & 'metal          ' , & 'sulphur        ' , & 'acceptor       ' , & 'sp3            ' , & 'sp2            ' , & 'sp3_nitrogen   ' , & 'planar_nitrogen' , & 'hydrogen       ' , & 'oxygen         ' , & 'carbon_lipo    ' , & 'carbonyl_carbon' , & 'carbonyl_oxygen' ] type ATOM_DATA_TYPE real :: radius logical :: prop ( NPROPS ) end type ATOM_DATA_TYPE type ( ATOM_DATA_TYPE ), allocatable :: atom_data (:) !No record is kept of polar(non H-bonding) atoms integer , allocatable :: iqatom (:) !one element per atom, 0 if not Q-atom, !else number in iqseq (ligand) real , allocatable :: vdwr (:) !van der Waals radius of each atom character * 80 :: atom_data_file character * 80 :: coord_file real :: hbond_term , metal_term , lipo_term , rot_term !result from score real , parameter :: dGconst =- 5.48 , dGhbond =- 3.34 , dGmetal =- 6.03 real , parameter :: dGlipo =- 0.117 , dGrot = 2.56 integer , private :: bDoTopcalc ! boolean flag integer , private :: iRestartCalc =- 1 ! flag to indicate if doing calcs on restart file or not logical , private :: bUseXIN = . false . ! boolean flag to indicate use of xin instead of xtop integer , private :: warn ! flag to indicate if any warnings were displayed contains subroutine score_initialize nScores = 0 maxScores = 16 allocate ( aScore ( maxScores )) end subroutine score_initialize subroutine chemscore_finalize if ( warn . ne . 0 ) then write ( * , '(a,i3,a)' ) 'WARNING: There were ' , warn , ' warnings.' else write ( * , '(a)' ) 'ChemScore finished succesfully.' end if end subroutine chemscore_finalize subroutine log_frame ( iFrame ) ! logs scoring results for frame ! args integer , intent ( in ) :: iFrame ! current frame ! locals type ( SCORE_TYPE ), pointer :: new_aScore (:) ! tmp pointer nScores = nScores + 1 if ( nScores > maxScores ) then maxScores = maxScores + 16 ! allocate 16 elements a time allocate ( new_aScore ( maxScores )) ! allocate new mem new_aScore ( 1 : nScores - 1 ) = aScore ( 1 : nScores - 1 ) ! copy old deallocate ( aScore ) ! return old mem to OS aScore => new_aScore ! update pointer end if ! finally store values aScore ( nScores )% frame = iFrame ! iFrame may be redundant aScore ( nScores )% score = score aScore ( nScores )% h_bonds = hbond_term aScore ( nScores )% metal = metal_term aScore ( nScores )% lipophil = lipo_term aScore ( nScores )% rot_bond = rot_term end subroutine log_frame subroutine score_heading ( i ) integer :: i write ( * , 100 ) 'score' , 'h-bonds' , 'metal' , 'lipophilic' , 'rot_bond' 100 format ( t29 , a5 , t38 , a7 , t51 , a5 , t58 , a10 , t71 , a8 ) !       write(*,'(a)', advance='no') 'SCORE' end subroutine score_heading subroutine calc_hbonds !in subroutine calc_scores integer :: i , j real :: score1 , score2 hbond_term = 0 do i = 1 , nhbd_l !ligand h-bond donors scored against do j = 1 , nhba_r !receptor acceptors score1 = g1_hb ( hbd_l ( i )% hydr , hba_r ( j )) !distance term score2 = g2_hb ( hbd_l ( i )% heavy , hbd_l ( i )% hydr , hba_r ( j )) !angle term hbond_term = hbond_term + score1 * score2 end do end do do i = 1 , nhba_l !ligand acceptors scored against do j = 1 , nhbd_r !receptor donors score1 = g1_hb ( hba_l ( i ), hbd_r ( j )% hydr ) score2 = g2_hb ( hba_l ( i ), hbd_r ( j )% hydr , hbd_r ( j )% heavy ) hbond_term = hbond_term + score1 * score2 end do end do end subroutine calc_hbonds subroutine calc_lipo !in subroutine calc_scores integer :: i , j real :: fij lipo_term = 0 do i = 1 , nlph_l !lipophilic atoms in ligand do j = 1 , nlph_r !    ''              receptor fij = fr_lip ( lph_l ( i ), lph_r ( j )) lipo_term = lipo_term + fij end do end do end subroutine calc_lipo subroutine calc_metals !in subroutine calc_scores integer :: i , j real :: score metal_term = 0 do i = 1 , nmet_r !metal atoms in receptor do j = 1 , nhba_l !H-bond acceptors in ligand score = fr_met ( met_r ( i ), hba_l ( j )) metal_term = metal_term + score end do end do end subroutine calc_metals subroutine calc_rot !in subroutine calc_scores integer :: i , nfrozen real :: pa , pb , hrot , sum nfrozen = 0 sum = 0 do i = 1 , nqbonds if ( q_bonds ( i )% acontact . and . q_bonds ( i )% bcontact ) then !if the bond is rotatable and frozen nfrozen = nfrozen + 1 pa = real ( q_bonds ( i )% a_nonlip ) / ( q_bonds ( i )% a_nonlip + q_bonds ( i )% a_lip ) ! % non-lipophilic heavy atoms on a-side pb = real ( q_bonds ( i )% b_nonlip ) / ( q_bonds ( i )% b_nonlip + q_bonds ( i )% b_lip ) sum = sum + (( pa + pb ) / 2 ) !add to sum with weight according to pa and pb write ( * , * ) 'qbond ' , i , ', atoms ' , q_bonds ( i )% a % top_nr , q_bonds ( i )% b % top_nr , ', contrib = ' , (( pa + pb ) / 2 ) end if end do if ( nfrozen == 0 ) then hrot = 0 else hrot = 1 + ( 1 - 1.0 / nfrozen ) * sum end if rot_term = hrot end subroutine calc_rot subroutine calc_scores call set_waters ! does calcs on waters call calc_hbonds ! calc contribution from hbond interaction between ligand and receptor call calc_metals ! calc contrib from metals in rec interacting with h-bond acceptors in ligand call calc_lipo ! calc lipophilic contrib call q_contacts ! set contact parameter =.true. for qatoms in contact with receptor call frozen ! checks if rotatable bonds are frozen call calc_rot ! calcs contrib from frozen rotatable bonds end subroutine calc_scores subroutine count_qlipo !count (non)lipophilic heavy atoms on each side of every bond integer :: i type ( lipos ) :: lipo q_bonds (:)% a_lip = 0 !reset q_bonds (:)% b_lip = 0 q_bonds (:)% a_nonlip = 0 q_bonds (:)% b_nonlip = 0 do i = 1 , nqbonds if ( q_bonds ( i )% rotatable ) then !go through all rotatable bonds q_bonds (:)% been_there = . false . q_atoms (:)% been_there = . false . !reset q_bonds ( i )% been_there = . true . lipo = lip_atom ( q_bonds ( i )% a ) !lip_atom recursively counts heavy atoms on a-side q_bonds ( i )% a_lip = lipo % n_lip q_bonds ( i )% a_nonlip = lipo % n_nonlip lipo = lip_atom ( q_bonds ( i )% b ) !on b-side q_bonds ( i )% b_lip = lipo % n_lip q_bonds ( i )% b_nonlip = lipo % n_nonlip end if end do end subroutine count_qlipo recursive function lip_atom ( atom ) result ( ans ) !arguments type ( q_atom ), pointer :: atom !local type ( lipos ) :: lipo type ( lipos ) :: temp integer :: i type ( q_bond ), pointer :: bond type ( lipos ) :: ans lipo % n_lip = 0 lipo % n_nonlip = 0 atom % been_there = . true . !flag to avoid cycling in rings do i = 1 , atom % n !go through every bond to this atom bond => atom % bd ( i )% qb if ( . not . bond % been_there ) then !if the bond has not already been passed temp % n_lip = 0 temp % n_nonlip = 0 bond % been_there = . true . !count heavy atoms on the opposite side if (. not . bond % a % been_there ) then !i.e. the side with an atom which has not been passed temp = lip_atom ( bond % a ) end if if (. not . bond % b % been_there ) then temp = lip_atom ( bond % b ) end if lipo % n_lip = lipo % n_lip + temp % n_lip !add result from each bond lipo % n_nonlip = lipo % n_nonlip + temp % n_nonlip end if end do if ( atom % at_type == 2 ) then !add atom itself to sum lipo % n_lip = lipo % n_lip + 1 end if if ( atom % at_type == 1 ) then lipo % n_nonlip = lipo % n_nonlip + 1 end if ans = lipo !return result to atom which made the call end function lip_atom subroutine frozen ! check each rotatable bond to see if it is frozen integer :: i , j type ( q_bond ), pointer :: bond type ( q_atom ), pointer :: atom q_bonds (:)% acontact = . false . !reset q_bonds (:)% bcontact = . false . do i = 1 , nqbonds ! go through all bonds bond => q_bonds ( i ) ! pointer to bond i if ( bond % rotatable ) then ! only have to check rotatable bonds q_bonds (:)% been_there = . false . ! reset q_atoms (:)% been_there = . false . bond % been_there = . true . bond % acontact = find_contact ( bond % a ) !if any contacts on a-side of rotatable bond bond % bcontact = find_contact ( bond % b ) !if any contacts on b-side end if end do end subroutine frozen recursive function find_contact ( atom ) result ( ans ) !argument type ( q_atom ), pointer :: atom !local integer :: i logical :: cont type ( q_bond ), pointer :: bond logical :: ans cont = . false . !no contact found yet atom % been_there = . true . if ( atom % contact ) then !if this atom is in contact there is no need to keep looking cont = . true . else !else go through all the bonds to this atom which have not been passed yet do i = 1 , atom % n bond => atom % bd ( i )% qb if ( . not . bond % been_there ) then bond % been_there = . true . if ( . not . bond % a % been_there ) then !if not passed atom a (call came from atom b) cont = find_contact ( bond % a ) !check if contact on this side else if ( . not . bond % b % been_there ) then !if call came from atom a cont = find_contact ( bond % b ) !check b-side end if if ( cont ) then !if contact found on other side of bond exit !no need to keep looking end if end if end do end if ans = cont !return result to atom which made the call end function find_contact subroutine get_atom_data !---------------- Local variables -----------------! integer :: i , j real :: rad ( natyps ) real :: radius logical :: stat logical :: novdw ( natyps ) character ( len = 8 ) :: tac_in !--------------------------------------------------! write ( * , '(a,a)' ) 'Reading atom parameters from ' , trim ( adjustl ( atom_data_file )) allocate ( atom_data ( natyps )) do i = 1 , natyps atom_data ( i )% radius = 0. atom_data ( i )% prop (:) = . false . end do if (. not . prm_open_section ( 'vdw_radii' , atom_data_file )) then write ( * , * ) 'get_atom_data:: Failed to open vdw_radii section of parameter file ' , trim ( atom_data_file ) stop 'Parameter file read failure' end if novdw (:) = . false . allocate ( vdwr ( 1 : nat_solute )) do while ( prm_get_string_real ( tac_in , radius )) ! tac_in and radius are returned if (. not . index_get ( tac_in , i )) then !                       write(*,10) trim(tac_in) 10 format ( '>>> WARNING: Atom type ' , a , ' ignored: not in topology.' ) else atom_data ( i )% radius = radius end if end do do i = 1 , nat_solute !!! Go through all atoms and give them a vdW radius. vdwr ( i ) = atom_data ( iac ( i ))% radius !!! I represents atom number. if ( vdwr ( i ) == 0.0 ) novdw ( iac ( i )) = . true . end do do i = 1 , natyps if ( novdw ( i )) then write ( * , 20 ) tac ( i ) warn = warn + 1 20 format ( 'WARNING: No vdW radius designated to atom type ' , a ) end if end do !read atom type categories do j = 1 , NPROPS if (. not . prm_open_section ( file_heading ( j ))) then write ( * , 30 ) file_heading ( j ) 30 format ( 'Failed to open ' , a , ' section of parameter file.' ) stop 'Parameter file read failure' end if do while ( prm_get_line ( tac_in )) if (. not . index_get ( tac_in , i )) then !                               write(*,10) trim(tac_in) else atom_data ( i )% prop ( j ) = . true . end if end do end do end subroutine get_atom_data subroutine make_tac_index ! creates index of atom types integer :: i call index_create ( natyps ) ! natyps is read from file do i = 1 , natyps if (. not . index_add ( tac ( i ), i )) then stop '>>>>> ERROR: Could not make atom type index' end if end do end subroutine make_tac_index subroutine q_contacts !check which q-atoms are in contact with receptor, in subroutine calc_scores integer :: i , j , tnr real :: distance q_atoms (:)% contact = . false . do i = 1 , nqat ! loop over heavy q-atoms tnr = q_atoms ( i )% top_nr if ( heavy ( tnr )) then ! if heavy do j = 1 , nat_solute ! all protein atoms, not the waters if (( iqatom ( j ) == 0 ) . and . ( heavy ( j )) ) then ! if heavy receptor atom (not q-atom) distance = dist ( tnr , j ) ! measure distance if ( distance <= ( vdwr ( tnr ) + vdwr ( j ) + 0.5 )) then ! if distance < vdw1+vdw2+0.5 q_atoms ( i )% contact = . true . ! then contact exit !no need to keep looking once one contact has been found end if end if end do end if end do end subroutine q_contacts subroutine q_types ! assign q-atom types and hybrids, used in entropy ! calculation, in subroutine set_ligand integer :: i , nr , a_type !set atom type 0:hydrogen, 2:heavy lipophilic, 1:non-lipophilic heavy do i = 1 , nqat nr = iqseq ( i ) ! topology number q_atoms ( i )% top_nr = nr ! used in other subroutines a_type = iac ( nr ) if ( atom_data ( a_type )% prop ( LIPO )) then !all C, P, F if ( pol_con ( nr ) < 2 ) then !if carbons have >=2 polar connections then it is polar, 62 always have 0 q_atoms ( i )% at_type = 2 !lipophilic else q_atoms ( i )% at_type = 1 !non-lipophilic end if elseif ( atom_data ( a_type )% prop ( SULPHUR )) then !sulphur if ( pol_con ( nr ) < 1 ) then !which is not attached to any polar atom q_atoms ( i )% at_type = 2 !is lipophilic else q_atoms ( i )% at_type = 1 end if elseif ( iaclib ( a_type )% mass < 4. ) then !hydrogen q_atoms ( i )% at_type = 0 !not heavy else !all others are non-lipophilic heavy q_atoms ( i )% at_type = 1 end if !set hybridization if ( atom_data ( a_type )% prop ( SP3 )) then !sp3 q_atoms ( i )% hybrid = 3 elseif ( atom_data ( a_type )% prop ( SP3_N )) then !sp3 nitrogens if ( pol_con ( nr ) == 21 . or . pol_con ( nr ) == 31 ) then !if bonded to two H and one other, or three H and one other q_atoms ( i )% hybrid = 0 !then terminal NH2 or NH3 and should not be included else q_atoms ( i )% hybrid = 3 end if elseif ( atom_data ( a_type )% prop ( SP2 )) then !sp2 q_atoms ( i )% hybrid = 2 elseif ( atom_data ( a_type )% prop ( PL_N )) then !planar nitrogens if ( pol_con ( nr ) == 21 ) then !if bonded to two H and one other then terminal NH2 and not included q_atoms ( i )% hybrid = 0 else q_atoms ( i )% hybrid = 2 end if else q_atoms ( i )% hybrid = 0 end if end do end subroutine q_types subroutine report_ligand integer :: i , top , cont write ( * , 100 ) '#' , 'atom' , 'type' , 'hybrid' , 'type' , 'bonds' , 'contact' 100 format ( t8 , a , t14 , a , t23 , a , t35 , a , t48 , a , t58 , a , t67 , a ) do i = 1 , nqat top = q_atoms ( i )% top_nr if ( q_atoms ( i )% contact ) then cont = 1 else cont = 0 end if 110 format ( t1 , i8 , t10 , i8 , t23 , a8 , t33 , i8 , t45 , i8 , t55 , i8 , t66 , i8 ) !               110     format((1x,i8), t9,(1x,i8), t18,(1x,a8), t27,(1x,i8), t36,(1x,i8), t45,(1x,i8), t54,(1x,i8)) !               110 format(2(1x,i8),1x,a8,4(1x,i8)) !               110 format(7i8) write ( * , 110 ) i , top , tac ( iac ( top )), q_atoms ( i )% hybrid , q_atoms ( i )% at_type , q_atoms ( i )% n , cont !               write(*, 110) i, top, iac(top), q_atoms(i)%hybrid, q_atoms(i)%at_type, q_atoms(i)%n, cont end do write ( * , 120 ) 'lipophilic' 120 format ( 1 a11 ) 130 format ( 1 i7 ) 140 format ( 2 i7 ) do i = 1 , nlph_l write ( * , 130 ) lph_l ( i ) end do write ( * , 120 ) 'Hb acc' do i = 1 , nhba_l write ( * , 130 ) hba_l ( i ) end do write ( * , 120 ) 'Hb don' do i = 1 , nhbd_l write ( * , 140 ) hbd_l ( i )% heavy , hbd_l ( i )% hydr end do end subroutine report_ligand subroutine report_protein 100 format ( '# Receptor atom summary:' ) 110 format ( '# ' , a , t20 , i6 ) write ( * , 100 ) write ( * , 110 ) 'total' , nat_pro - nqat write ( * , 110 ) 'lipophilic' , nlph_r write ( * , 110 ) 'H-bond donors' , nhbd_r write ( * , 110 ) 'H-bond acceptors' , nhba_r write ( * , 110 ) 'metal ions' , nmet_r write ( * , 110 ) 'water molecules' , nwaters write ( * , * ) end subroutine report_protein subroutine report_rings integer :: i , j write ( * , '(/,a,I3)' ) 'number of rings = ' , nrings do i = 1 , nrings write ( * , '(a,I3,a)' ) 'ring ' , i , ': ' do j = 1 , nqbonds if ( q_bonds ( j )% cyclic ( i )) then write ( * , '(I5,a,I5)' ) q_bonds ( j )% a % top_nr , ' ' , q_bonds ( j )% b % top_nr end if end do end do end subroutine report_rings subroutine reset_waters !in subroutine set_waters nhbd_r = nhbd_prot nhba_r = nhba_prot end subroutine reset_waters subroutine score_waters !calculate hydrogen bonds between each water molecule and receptor !in set_waters integer :: i , j , k real :: score1 , score2 , sum_score do i = 1 , nwaters sum_score = 0.0 do j = 1 , nhba_r !water hydrogens as donors, scored against receptor acceptors score1 = g1_hb ( waters ( i )% H1 , hba_r ( j )) !distance term score2 = g2_hb ( waters ( i )% O , waters ( i )% H1 , hba_r ( j )) !angle term sum_score = sum_score + score1 * score2 score1 = g1_hb ( waters ( i )% H2 , hba_r ( j )) score2 = g2_hb ( waters ( i )% O , waters ( i )% H2 , hba_r ( j )) sum_score = sum_score + score1 * score2 end do do j = 1 , nhbd_r !water oxygen as acceptor, scored against receptor donors score1 = g1_hb ( waters ( i )% O , hbd_r ( j )% hydr ) score2 = g2_hb ( waters ( i )% O , hbd_r ( j )% hydr , hbd_r ( j )% heavy ) sum_score = sum_score + score1 * score2 end do waters ( i )% score = sum_score end do end subroutine score_waters subroutine set_ligand call q_types ! assign vdw radii to qatoms call set_rings ! detect rings call set_rotatable ! set parameter 'rotatable' to apropriate value call count_qlipo ! count (non)lipophilic heavy atoms on each side of every bond end subroutine set_ligand subroutine set_rings !in set_ligand integer :: ir type ( q_atom ), pointer :: start_atom integer :: i , j nrings = nqbonds - nqat + 1 !number of rings in ligand if ( nrings > 0 ) then !if at least one ring do i = 1 , nqbonds allocate ( q_bonds ( i )% cyclic ( nrings )) do j = 1 , nrings q_bonds ( i )% cyclic ( j ) = . false . !reset end do end do do i = 1 , nqat allocate ( q_atoms ( i )% cyclic ( nrings )) do j = 1 , nrings q_atoms ( i )% cyclic ( j ) = . false . end do end do q_bonds (:)% been_there = . false . !reset q_atoms (:)% been_there = . false . start_atom => q_atoms ( 1 ) !does not matter which q-atom search starts from ir = 0 start_atom % been_there = . true . do i = 1 , start_atom % n !go through all bonds of the start atom if (. not . start_atom % bd ( i )% qb % been_there ) then call search_ring ( start_atom % bd ( i )% qb , ir ) end if end do end if end subroutine set_rings recursive subroutine search_ring ( bond , ir ) !arguments type ( q_bond ), pointer :: bond integer :: ir !local type ( q_atom ), pointer :: atom integer :: i bond % been_there = . true . if ( bond % a % been_there . and . bond % b % been_there ) then !if both atoms of a bond have been passed, but not the bond call mark_ring ( bond , ir ) !then a ring has been found. call mark_ring to find all the atoms of this ring end if atom => bond % a !pekartilldelning if (. not . atom % been_there ) then !if atom a has not been passed atom % been_there = . true . do i = 1 , atom % n !look for rings in all directions which have not been passed if (. not . atom % bd ( i )% qb % been_there ) then call search_ring ( atom % bd ( i )% qb , ir ) end if end do else atom => bond % b if (. not . atom % been_there ) then !if it is atom b which has not been passed atom % been_there = . true . do i = 1 , atom % n if (. not . atom % bd ( i )% qb % been_there ) then call search_ring ( atom % bd ( i )% qb , ir ) end if end do end if end if end subroutine search_ring subroutine mark_ring ( bond , ir ) !identify atoms involved in rings !arguments type ( q_bond ), pointer :: bond !starting bond integer :: ir !local logical :: found !not used for anything, but the function trace_ring returns a value ir = ir + 1 !one more ring has been found q_bonds (:)% active = . false . !reset q_atoms (:)% active = . false . bond % cyclic ( ir ) = . true . !this bond is part of the ring bond % active = . true . bond % a % cyclic ( ir ) = . true . !atom on a-side also part of the ring found = trace_ring ( bond % b , ir ) !try to close ring starting at atom on b-side end subroutine mark_ring recursive function trace_ring ( atom , ir ) result ( ans ) !arguments type ( q_atom ), pointer :: atom integer :: ir !local integer :: i logical :: found type ( q_bond ), pointer :: bond logical :: ans found = . false . atom % active = . true . !this atom has been passed trying to close the ring do i = 1 , atom % n bond => atom % bd ( i )% qb !go through all bonds which could be part of the ring recently found (been_there) if ( bond % been_there . and . (. not . bond % active )) then !but have not been passed trying to close the ring (not active) bond % active = . true . if ( bond % a % been_there . and . (. not . bond % a % active )) then !a could be part of the ring, and have not checked it yet if ( bond % a % cyclic ( ir ) ) then !if a is part of the right ring found = . true . !then the ring is closed else found = trace_ring ( bond % a , ir ) !else look in a direction end if else if ( bond % b % been_there . and . (. not . bond % b % active )) then !b could be part of the ring, and have not checked it yet if ( bond % b % cyclic ( ir ) ) then !if b part of the right ring found = . true . !ring closed else found = trace_ring ( bond % b , ir ) !else look in b direction end if end if if ( found ) then !if possible to close ring using this bond bond % cyclic ( ir ) = . true . !this bond is part of the ring !if possible to close the ring using bond i atom % cyclic ( ir ) = . true . !then this atom is also part of the ring exit !no need to keep looking when ring closed end if end if end do ans = found !if possible to close ring using this atom end function trace_ring subroutine set_rotatable !check which q-bonds are rotatable integer :: i , j q_bonds (:)% rotatable = . false . do i = 1 , nqbonds !go through all qbonds, rotatable if sp2-sp3 or sp3-sp3 if ( ( ( q_bonds ( i )% a % hybrid == 3 ) . and . ( q_bonds ( i )% b % hybrid > 0 ) ) & . or . ( ( q_bonds ( i )% b % hybrid == 3 ) . and . ( q_bonds ( i )% a % hybrid > 0 ) ) ) then q_bonds ( i )% rotatable = . true . do j = 1 , nrings !check if bond is member of any ring if ( q_bonds ( i )% cyclic ( j )) then !then not rotatable q_bonds ( i )% rotatable = . false . exit end if end do end if end do end subroutine set_rotatable subroutine set_waters !in calc_scores call reset_waters ! does some reseting of two ints call score_waters ! calculate hydrogen bonds between each water molecule and receptor call sort_waters ! does some calculation on the waters end subroutine set_waters subroutine sort_atoms !must be done after sort_bonds ,in subroutine start integer :: i , a_type allocate ( hba_l ( nqat ), lph_l ( nqat ), lph_r ( nat_solute ), hba_r ( nat_solute ), met_r ( 64 )) nlph_l = 0 nlph_r = 0 nmet_r = 0 nhba_l = 0 nhba_r = 0 do i = 1 , nat_solute !go through all atoms, put in right category a_type = iac ( i ) if ( atom_data ( a_type )% prop ( LIPO )) then !atoms which may be lipophilic: all carbons, Cl, Br, I which are not ions if ( pol_con ( i ) < 2 ) then !If carbon has >=2 polar connections then it is polar (not lipophilic), CL always included if ( iqatom ( i ) /= 0 ) then nlph_l = nlph_l + 1 lph_l ( nlph_l ) = i else nlph_r = nlph_r + 1 lph_r ( nlph_r ) = i end if end if elseif ( atom_data ( a_type )% prop ( SULPHUR )) then !sulphurs with more than one connection if ( pol_con ( i ) < 1 ) then !which are not attached to a polar atom are lipophilic if ( iqatom ( i ) /= 0 ) then nlph_l = nlph_l + 1 lph_l ( nlph_l ) = i else nlph_r = nlph_r + 1 lph_r ( nlph_r ) = i end if end if elseif ( atom_data ( a_type )% prop ( METAL )) then !all metal atoms nmet_r = nmet_r + 1 !only metals in receptor met_r ( nmet_r ) = i elseif ( atom_data ( a_type )% prop ( ACCEPTOR )) then ! all N, all O, all halogen ions, sulphurs with only one ! connection can be Hbond acceptors if ( pol_con ( i ) . le . 2 ) then !If N has >2 connections then it is polar, all other atoms have value 0 if ( iqatom ( i ) /= 0 ) then nhba_l = nhba_l + 1 hba_l ( nhba_l ) = i else nhba_r = nhba_r + 1 hba_r ( nhba_r ) = i end if end if end if end do nhba_prot = nhba_r end subroutine sort_atoms subroutine sort_bonds !identify pairs of atoms involved in q-bonds and/or hydrogen bonding !in start integer :: atom1 , atom2 , hydrogen_atom integer :: heavy_at , a_type , type1 , type2 integer :: i , j , k logical :: polar !allokera listor allocate ( q_atoms ( nqat )) allocate ( q_bonds ( nqat * 2 )) ! worst case? allocate ( hbd_r ( nat_solute ), hbd_l ( nqat )) allocate ( pol_con ( nat_solute )) nhbd_l = 0 nhbd_r = 0 q_atoms (:)% n = 0 nqbonds = 0 pol_con (:) = 0 do i = 1 , nbonds_solute ! loop over all bonds between solute atoms polar = . false . atom1 = bnd ( i )% i atom2 = bnd ( i )% j if ( atom_data ( iac ( atom1 ))% prop ( HYDROGEN )) then !all polar H polar = . true . !if one of the atoms is a polar hydrogen, then the bond is polar hydrogen_atom = atom1 heavy_at = atom2 elseif ( atom_data ( iac ( atom2 ))% prop ( HYDROGEN )) then polar = . true . hydrogen_atom = atom2 heavy_at = atom1 end if if ( polar ) then a_type = iac ( heavy_at ) !check if the bond matches any of the h-bond categories if ( atom_data ( a_type )% prop ( OXYGEN )) then !all oxygens (not water) if ( iqatom ( heavy_at ) /= 0 ) then !if q-atom nhbd_l = nhbd_l + 1 hbd_l ( nhbd_l )% heavy = heavy_at hbd_l ( nhbd_l )% hydr = hydrogen_atom else !else receptor nhbd_r = nhbd_r + 1 hbd_r ( nhbd_r )% heavy = heavy_at hbd_r ( nhbd_r )% hydr = hydrogen_atom end if elseif ( atom_data ( a_type )% prop ( SP3_N ) . or . & atom_data ( a_type )% prop ( PL_N )) then !all nitrogens if ( iqatom ( heavy_at ) /= 0 ) then nhbd_l = nhbd_l + 1 hbd_l ( nhbd_l )% heavy = heavy_at hbd_l ( nhbd_l )% hydr = hydrogen_atom else nhbd_r = nhbd_r + 1 hbd_r ( nhbd_r )% heavy = heavy_at hbd_r ( nhbd_r )% hydr = hydrogen_atom end if pol_con ( heavy_at ) = pol_con ( heavy_at ) + 10 !N bonded to H should not be included in hbond acceptors end if else !if not polar hydrogen, count connections to N,S and C type1 = iac ( atom1 ) type2 = iac ( atom2 ) if ( atom_data ( type1 )% prop ( SP3_N ) . or . & atom_data ( type1 )% prop ( PL_N )) then !all nitrogens pol_con ( atom1 ) = pol_con ( atom1 ) + 1 !count all connections to N elseif ( atom_data ( type1 )% prop ( CARBON_LIPO )) then !all carbons (except CH3 and carbons which might be in !carbonyls or nitriles) if ( atom_data ( type2 )% prop ( PL_N ) . or . & atom_data ( type2 )% prop ( ACCEPTOR )) then !       case (30:37,40,41,43,44,49,51,52,61) ! all polar and H-bonding atoms (but not H, not C, not F) !i.e. all N, all O, all halogen ions, P, F, S with only one connection !count polar connections to C pol_con ( atom1 ) = pol_con ( atom1 ) + 1 end if elseif ( atom_data ( type1 )% prop ( SULPHUR )) then !sulphur !count polar connections to S with more than one connection if ( atom_data ( type2 )% prop ( PL_N ) . or . & atom_data ( type2 )% prop ( ACCEPTOR )) then !and not always bonded to a polar atom (49, sulphate, is always polar and no need to count) !case (30:37,40,41,43,44,49,51,52,61)   ! all polar and H-bonding atoms (but not H, not C, not F) pol_con ( atom1 ) = pol_con ( atom1 ) + 1 end if elseif ( atom_data ( type1 )% prop ( CARBONYL_CARBON )) then !case (21) !sp2 carbons which might be carbonyl, !(carbons which could be part of nitriles should be included) if ( atom_data ( type2 )% prop ( CARBONYL_OXYGEN )) then !case (40,43) !carbonyl O, (nitrile N should come here) pol_con ( atom1 ) = pol_con ( atom1 ) + 2 !carbonyl always polar elseif ( atom_data ( type2 )% prop ( PL_N ) . or . & atom_data ( type2 )% prop ( ACCEPTOR )) then !case (30:37,41,44,49,51,52,61) !all other polar atoms, see list above pol_con ( atom1 ) = pol_con ( atom1 ) + 1 !else only count polar connections end if end if !same for atom 2 if ( atom_data ( type2 )% prop ( SP3_N ) . or . & atom_data ( type2 )% prop ( PL_N )) then !case (30:37) pol_con ( atom2 ) = pol_con ( atom2 ) + 1 elseif ( atom_data ( type2 )% prop ( CARBON_LIPO )) then !case (20,22,23,25:29) !select case (type1) if ( atom_data ( type1 )% prop ( PL_N ) . or . & atom_data ( type1 )% prop ( ACCEPTOR )) then !all polar atoms !case (30:37,40,41,43,44,49,51,52,61) pol_con ( atom2 ) = pol_con ( atom2 ) + 1 end if elseif ( atom_data ( type2 )% prop ( SULPHUR )) then !select case (type1) if ( atom_data ( type1 )% prop ( PL_N ) . or . & atom_data ( type1 )% prop ( ACCEPTOR )) then !case (30:37,40,41,43,44,49,51,52,61)   ! polar atoms pol_con ( atom2 ) = pol_con ( atom2 ) + 1 end if elseif ( atom_data ( type2 )% prop ( CARBONYL_CARBON )) then !case (21) !sp2 carbon !select case (type1) if ( atom_data ( type1 )% prop ( CARBONYL_OXYGEN )) then !case (40,43) pol_con ( atom2 ) = pol_con ( atom2 ) + 2 !carbonyl carbons are always polar elseif ( atom_data ( type1 )% prop ( PL_N ) . or . & atom_data ( type1 )% prop ( ACCEPTOR )) then !case (30:37,41,44,49,51,52,61) pol_con ( atom2 ) = pol_con ( atom2 ) + 1 end if end if end if !store all bonds between q-atoms, pointers relating arrays q_atoms and q_bonds if (( iqatom ( atom1 ) /= 0 ) . and . ( iqatom ( atom2 ) /= 0 )) then j = iqatom ( atom1 ) k = iqatom ( atom2 ) nqbonds = nqbonds + 1 q_bonds ( nqbonds )% a => q_atoms ( j ) q_bonds ( nqbonds )% b => q_atoms ( k ) !pointer to atom in q_atoms q_atoms ( j )% n = q_atoms ( j )% n + 1 !number of bonds to atom j q_atoms ( j )% bd ( q_atoms ( j )% n )% qb => q_bonds ( nqbonds ) !pointer to bond in q_bonds q_atoms ( k )% n = q_atoms ( k )% n + 1 q_atoms ( k )% bd ( q_atoms ( k )% n )% qb => q_bonds ( nqbonds ) end if end do !go through bond list once more, count bonds to polar sulphurs do i = 1 , nbonds_solute atom1 = bnd ( i )% i atom2 = bnd ( i )% j type1 = iac ( atom1 ) type2 = iac ( atom2 ) if ( atom_data ( type1 )% prop ( SULPHUR ) . and . & pol_con ( atom1 ) >= 1 ) then !if ((type1 == 50) .and. (pol_con(atom1) .ge. 1))  then !       if atom1 is a polar sulphur !select case (type2) if ( atom_data ( type2 )% prop ( CARBON_LIPO ) . or . & atom_data ( type2 )% prop ( CARBONYL_CARBON )) then !case (20:23,25:29)                                                             !all carbons pol_con ( atom2 ) = pol_con ( atom2 ) + 1 !then atom2 has one more connection to a polar atom end if end if if ( atom_data ( type2 )% prop ( SULPHUR ) . and . & pol_con ( atom2 ) >= 1 ) then !if ((type2 == 50) .and. (pol_con(atom2) .ge. 1))  then !if atom2 is a polar sulphur !select case (type1) if ( atom_data ( type1 )% prop ( CARBON_LIPO ) . or . & atom_data ( type1 )% prop ( CARBONYL_CARBON )) then !case (20:23,25:29)                                                     !all carbons pol_con ( atom1 ) = pol_con ( atom1 ) + 1 !then atom1 has one more connection to a polar atom end if end if end do nhbd_prot = nhbd_r !used later to keep track of waters in receptor list end subroutine sort_bonds subroutine sort_waters !g�rs ev bara en g�ng           !in set_waters integer :: i do i = 1 , nwaters !all waters if ( waters ( i )% score > 1 ) then !if the water is attached to receptor nhbd_r = nhbd_r + 1 hbd_r ( nhbd_r )% heavy = waters ( i )% O hbd_r ( nhbd_r )% hydr = waters ( i )% H1 nhbd_r = nhbd_r + 1 hbd_r ( nhbd_r )% heavy = waters ( i )% O hbd_r ( nhbd_r )% hydr = waters ( i )% H2 nhba_r = nhba_r + 1 hba_r ( nhba_r ) = waters ( i )% O end if end do end subroutine sort_waters subroutine start !       character*80                            ::      top_file, fep_file integer ( 4 ) :: u , nat3 integer :: i call centered_heading ( 'Reading input' , '-' ) ! --- topology file is now read by qcalc !write(*,'(a)', advance='no') 'Topology file: ' !read (*,'(a)') top_file !top_file = 'hapc.top' ! --- fep file is read by score_add !write(*,'(/,a)', advance='no') 'Q-atom (FEP) file: ' !read (*,'(a)') fep_file !fep_file = 'lie.fep' ! --- prm file is read by score_add !write(*,'(/,a)', advance='no') 'Parameter file: ' !read (*,'(a)') atom_data_file !atom_data_file = 'eldro.prm' ! --- topology is loaded by qcalc !if(.not. topo_load(top_file, 4.00)) then !       write(*,'(a)') '>>>>> ERROR: Failed to load topology.' !       stop !end if nwaters = ( nat_pro - nat_solute ) / 3 call make_tac_index ! creates text atom code index call get_atom_data !!! Takes vdw_radii from vdw_file and puts into vector vdwr. !!! Also assigns radii to every solute atom if (. not . qatom_load_atoms ( fep_file )) then stop 'Failed to read Q-atom list from FEP file.' end if allocate ( iqatom ( nat_solute )) ! Allocate mem for every solute atom iqatom (:) = 0 do i = 1 , nqat iqatom ( iqseq ( i )) = i !Set references so that iqatom = 0 if protein and {number} of ligand end do call sort_bonds call sort_atoms call store_waters end subroutine start subroutine store_waters !order of atoms in coordinate list must be O,H,H                !in subroutine start integer :: i , j j = 0 allocate ( waters ( 1 : nwaters )) do i = nat_solute + 1 , nat_pro , 3 j = j + 1 waters ( j )% O = i waters ( j )% H1 = i + 1 waters ( j )% H2 = i + 2 end do end subroutine store_waters real function angle ( a , b , c ) !determines the angle a-b-c in degrees, using the cosine theorem integer :: a , b , c !parameters real :: ab_sq , bc_sq , ca_sq , scp !local variables real , parameter :: pi = 4.0 * atan ( 1.0 ) ab_sq = distsq ( a , b ) bc_sq = distsq ( b , c ) ca_sq = distsq ( c , a ) scp = ( ab_sq + bc_sq - ca_sq ) / ( 2 * sqrt ( ab_sq * bc_sq )) !it may happen that scp is very slightly outside [-1;1] if ( scp > 1.0 ) scp = 1.0 if ( scp < - 1.0 ) scp = - 1.0 angle = acos ( scp ) * 18 0.0 / pi end function angle real function dist ( a , b ) !!! Gives the distance between two atoms. integer :: a , b !topology numbers real , dimension ( 3 ) :: delta if ( bUseXIN ) then delta = xin ( 3 * a - 2 : 3 * a ) - xin ( 3 * b - 2 : 3 * b ) else delta = xtop ( 3 * a - 2 : 3 * a ) - xtop ( 3 * b - 2 : 3 * b ) end if dist = sqrt ( dot_product ( delta , delta )) end function dist real function distsq ( a , b ) !!! Gives the squared distance between two atoms. integer :: a , b real , dimension ( 3 ) :: delta if ( bUseXIN ) then delta = xin ( 3 * a - 2 : 3 * a ) - xin ( 3 * b - 2 : 3 * b ) else delta = xtop ( 3 * a - 2 : 3 * a ) - xtop ( 3 * b - 2 : 3 * b ) end if distsq = dot_product ( delta , delta ) end function distsq real function fr_lip ( a , b ) !!! Gives f(rlL) i.e. contribution from one lipophilic - lipophilic pair integer :: a , b !topology numbers of the pair real :: dr !distance between the two atoms real :: R1 dr = dist ( a , b ) R1 = vdwr ( a ) + vdwr ( b ) + 0.5 if ( dr < ( R1 + 3 )) then !if the atoms interact at all if ( dr <= R1 ) then fr_lip = 1 !if they are closer than R1 the interaction is given full weight else fr_lip = 1 - ( dr - R1 ) / 3 !else the interaction is given reduced weight end if else fr_lip = 0 end if end function fr_lip real function fr_met ( a , b ) ! Gives f(raM) i.e. contribution from one H-bond acceptor ! (or H-bond acceptor/donor) - metal pair integer :: a , b ! topology numbers real :: dr ! distance between the two atoms dr = dist ( a , b ) if ( dr < 2.6 ) then if ( dr <= 2.2 ) then fr_met = 1 else fr_met = 1 - ( dr - 2.2 ) / 0.4 end if else fr_met = 0 end if end function fr_met real function g1_hb ( a , b ) ! Gives g1(dev_dr) i.e. contribution depending on the distance between ! the H of an H-bond donor and an H-bond acceptor integer :: a , b !       top. nr real :: dr , dev_dr ! distance between the two atoms, deviation from the ! ideal value 1.85 � dr = dist ( a , b ) dev_dr = abs ( 1.85 - dr ) if ( dev_dr < 0.65 ) then !if atoms are interacting at all if ( dev_dr <= 0.25 ) then g1_hb = 1 else g1_hb = 1 - ( dev_dr - 0.25 ) / 0.4 end if else g1_hb = 0 end if end function g1_hb real function g2_hb ( a , b , c ) !!! Gives g2(dev_ang) i.e. contribution depending on the H-bond angle at the hydrogen atom integer :: a , b , c !top.nr, the hydrogen must be atom b real :: ang , dev_ang !H-bond angle, deviation from ideal value of 180 degrees ang = angle ( a , b , c ) dev_ang = abs ( 180 - ang ) if ( dev_ang < 80 ) then if ( dev_ang <= 30 ) then g2_hb = 1 else g2_hb = 1 - ( dev_ang - 30 ) / 50 end if else g2_hb = 0 end if end function g2_hb subroutine score_precalc ! 1. Prepares ligand and other stuff for calculations ! 2. Does calculations on topology or restart file before frame by frame calculations start integer :: i character ( len = 200 ) :: chBuf call start ! Prepares coordinates etc call set_ligand ! Prepare ligand call report_rings ! output results call report_ligand ! output results call report_protein ! output results if ( bDoTopcalc . eq . 0 ) return ! abort if no top-calc is to be output ! continue scoring topology call calc_scores ! does the calcs score = dGconst + hbond_term * dGhbond + metal_term * dGmetal + lipo_term * dGlipo + rot_term * dGrot write ( * , * ) !two empty lines for gnuplot as a data set separator write ( * , * ) call centered_heading ( 'Scoring results' , '=' ) write ( * , 100 ) 'file' , 'frame' , 'score' , 'h-bonds' , 'metal' , 'lipophilic' , 'rot_bond' write ( * , 110 ) 'topology' , frame , score , hbond_term , metal_term , lipo_term , rot_term 100 format ( a , t18 , a5 , t29 , a5 , t38 , a7 , t51 , a5 , t58 , a10 , t71 , a8 ) 110 format ( a , t19 , i4 , t25 , f9 . 2 , t36 , f9 . 2 , t47 , f9 . 2 , t59 , f9 . 2 , t70 , f9 . 2 ) end subroutine score_precalc integer function score_add ( desc ) !arguments character ( * ) :: desc integer :: ats , iRe ! locals character ( len = 400 ) :: chInFile ! long buffers to meet long paths character ( len = 400 ) :: chBuf if ( Nmasks == MAX_MASKS ) then write ( * , 10 ) MAX_MASKS return end if 10 format ( 'Sorry, the maximum number of score calculations is ' , i2 ) !add a new score mask Nmasks = Nmasks + 1 call mask_initialize ( masks ( Nmasks )) ats = maskmanip_make ( masks ( Nmasks )) !discard if no atoms in mask if ( ats == 0 ) then call mask_finalize ( masks ( Nmasks )) Nmasks = Nmasks - 1 score_add = 0 return end if chBuf = '' do while (( trim ( chBuf ). ne . 'yes' ). and .( trim ( chBuf ). ne . 'no' )) call getlin ( chBuf , 'Score initial topology? (yes/no)' ) call locase ( chBuf ) end do if ( chBuf . eq . 'yes' ) then bDoTopcalc = 1 else bDoTopCalc = 0 end if call getlin ( fep_file , 'Q-atom (FEP) file: ' ) write ( chBuf , '(a,a,a)' ) 'Parameter file (blank to use ' , trim ( prm_file ), '): ' call getlin ( atom_data_file , trim ( chBuf )) if ( len ( trim ( atom_data_file )). eq . 0 ) then atom_data_file = prm_file end if score_add = Nmasks write ( desc , 20 ) nat_pro 20 format ( 'Score calculation using ' , i6 , ' atoms' ) end function score_add subroutine score_mean ! calculate and print mean score for all contributions ! locals real ( 8 ) :: m_score , m_hbond , m_metal , m_lipo , m_rot do i = 1 , nScores m_score = m_score + aScore ( i )% score m_hbond = m_hbond + aScore ( i )% h_bonds m_metal = m_metal + aScore ( i )% metal m_lipo = m_lipo + aScore ( i )% lipophil m_rot = m_rot + aScore ( i )% rot_bond end do m_score = m_score / nScores m_hbond = m_hbond / nScores m_metal = m_metal / nScores m_lipo = m_lipo / nScores m_rot = m_rot / nScores ! output mean values write ( * , 100 ) 'processed frames: ' , nScores , 'score' , 'h-bonds' , 'metal' , 'lipophilic' , 'rot_bond' 100 format ( t1 , a , t21 , i4 , t29 , a5 , t38 , a7 , t51 , a5 , t58 , a10 , t71 , a8 ) write ( * , 110 ) 'mean value' , m_score , m_hbond , m_metal , m_lipo , m_rot 110 format ( t1 , a , t25 , f9 . 2 , t36 , f9 . 2 , t47 , f9 . 2 , t59 , f9 . 2 , t70 , f9 . 2 ) write ( * , 111 ) '------------------------------------------------------------------------------' 111 format ( t1 , a ) m_score = 0 m_hbond = 0 m_metal = 0 m_lipo = 0 m_rot = 0 nScores = 0 end subroutine score_mean subroutine score_calc ( iCalc , iFrame ) ! calc topmost routine !arguments integer , intent ( in ) :: iCalc ! calculation index, not used integer , intent ( in ) :: iFrame ! frame index ! <begin fulhack> ! added flag to have calc routines use xin instead of xtop. not a pretty solution but better than xtop = xin <end fulhack> bUseXIN = . true . !call start !call set_ligand call calc_scores score = dGconst + hbond_term * dGhbond + metal_term * dGmetal + lipo_term * dGlipo + rot_term * dGrot !       if((iFrame.eq.0).and.(iRestartCalc.eq.-1)) then         ! first restart calc, no calcs have been stored !               iRestartCalc = 1 !               write(*,*) ' begin fresh restart' !       elseif((iFrame.eq.0).and.(iRestartCalc.eq.0)) then      ! begin restart calc, last calc was trajectory calc so calc mean of that !               call score_calc_mean                                                    ! calc mean of traj scores !               nScores = 0                                                                             ! reset frame count !               write(*,*) ' begin restart' !               iRestartCalc = 1 !               call log_frame(iFrame) !       elseif((iFrame.eq.0).and.(iRestartCalc.eq.0)) then      ! continued restart calc !               write(*,*) ' cont restart' !               call log_frame(iFrame) !       elseif((iFrame.ne.0).and.(iRestartCalc.eq.1)) then      ! begin traj calc, last was restart so calc mean of that !               write(*,*) ' begin traj' !               call score_calc_mean !               nScores = 0 !               iRestartCalc = 0 !               call log_frame(iFrame) !       elseif((iFrame.ne.0).and.(iRestartCalc.eq.0)) then      ! continued traj calc !               write(*,*) ' cont traj' !               call log_frame(iFrame) !       else !               write(*,*) ' >>>> ERROR: Unrecognized calculation type in score_calc' !       end if call log_frame ( iFrame ) !write(110,*) score, hbond_term, metal_term, lipo_term, rot_term !       write(100,*) score, hbond_term, metal_term, lipo_term, rot_term !write(*,100, advance='no') score 100 format ( f10 . 3 ) write ( * , 110 ) score , hbond_term , metal_term , lipo_term , rot_term 110 format ( t25 , f9 . 2 , t36 , f9 . 2 , t47 , f9 . 2 , t59 , f9 . 2 , t70 , f9 . 2 ) end subroutine score_calc end module calc_chemscore","tags":"","loc":"sourcefile/calc_chemscore.f90.html","title":"calc_chemscore.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  calc_kineticenergy.f90 !  by Martin Almlof !  calculates the center of mass coordinates of whatever atom mask is specified !------------------------------------------------------------------------------! module calc_com use calc_base use MASKMANIP implicit none !constants integer , parameter :: MAX_MASKS = 10 !module variables type ( MASK_TYPE ), private , target :: masks ( MAX_MASKS ) integer , private :: Nmasks = 0 type COM_COORD_TYPE real , pointer :: x (:), y (:), z (:), mass (:) end type COM_COORD_TYPE type ( COM_COORD_TYPE ), private :: coords_mass ( MAX_MASKS ) type COORD_TYPE real , pointer :: xyz (:) end type COORD_TYPE type ( COORD_TYPE ), private :: coords ( MAX_MASKS ) type MASS_AVE_TYPE real :: x , y , z end type MASS_AVE_TYPE type ( MASS_AVE_TYPE ), private :: mass_ave ( MAX_MASKS ) real , private :: tot_mass ( MAX_MASKS ) contains subroutine COM_initialize end subroutine COM_initialize subroutine COM_finalize ( i ) integer :: i call mask_finalize ( masks ( i )) end subroutine COM_finalize integer function COM_add ( desc ) !arguments character ( * ) :: desc character ( len = 80 ) :: line integer :: readstat integer :: ats , j if ( Nmasks == MAX_MASKS ) then write ( * , 10 ) MAX_MASKS return end if 10 format ( 'Sorry, the maximum number of COM calculations is ' , i2 ) !add a new COM mask Nmasks = Nmasks + 1 call mask_initialize ( masks ( Nmasks )) ats = maskmanip_make ( masks ( Nmasks )) !discard if no atoms in mask if ( ats == 0 ) then call mask_finalize ( masks ( Nmasks )) Nmasks = Nmasks - 1 COM_add = 0 return end if allocate ( coords ( Nmasks )% xyz ( 3 * ats )) allocate ( coords_mass ( Nmasks )% x ( ats ), coords_mass ( Nmasks )% y ( ats ), coords_mass ( Nmasks )% z ( ats ), coords_mass ( Nmasks )% mass ( ats )) coords_mass ( Nmasks )% x (:) = 0 coords_mass ( Nmasks )% y (:) = 0 coords_mass ( Nmasks )% z (:) = 0 coords_mass ( Nmasks )% mass (:) = 0 coords ( Nmasks )% xyz (:) = 0 call COM_put_mass ( Nmasks ) COM_add = Nmasks write ( desc , 20 ) masks ( Nmasks )% included 20 format ( 'Center of mass position ' , i6 , ' atoms' ) end function COM_add subroutine COM_calc ( i ) !arguments integer , intent ( in ) :: i !locals if ( i < 1 . or . i > Nmasks ) return call mask_get ( masks ( i ), xin , coords ( i )% xyz ) !split coords into x, y, and z coords coords_mass ( i )% x = coords ( i )% xyz ( 1 :: 3 ) coords_mass ( i )% y = coords ( i )% xyz ( 2 :: 3 ) coords_mass ( i )% z = coords ( i )% xyz ( 3 :: 3 ) !calculate center of mass mass_ave ( i )% x = dot_product ( coords_mass ( i )% x (:), coords_mass ( i )% mass ) / tot_mass ( i ) mass_ave ( i )% y = dot_product ( coords_mass ( i )% y (:), coords_mass ( i )% mass ) / tot_mass ( i ) mass_ave ( i )% z = dot_product ( coords_mass ( i )% z (:), coords_mass ( i )% mass ) / tot_mass ( i ) write ( * , 100 , advance = 'no' ) mass_ave ( i )% x , mass_ave ( i )% y , mass_ave ( i )% z 100 format ( 3 f9 . 4 ) end subroutine COM_calc subroutine COM_put_mass ( i ) integer :: k , j , i , at real :: mass if ( i < 1 . or . i > Nmasks ) return tot_mass ( i ) = 0 !put in masses into coords_mass k = 1 do j = 1 , nat_pro if ( masks ( i )% MASK ( j )) then mass = iaclib ( iac ( j ))% mass coords_mass ( i )% mass ( k ) = mass tot_mass ( i ) = tot_mass ( i ) + mass k = k + 1 end if end do write ( * , 168 ) \"Total mass: \" , tot_mass ( i ) 168 format ( a , f10 . 3 ) end subroutine COM_put_mass subroutine COM_heading ( i ) integer :: i write ( * , '(a)' , advance = 'no' ) '    X        Y        Z    ' end subroutine COM_heading end module CALC_COM","tags":"","loc":"sourcefile/calc_com.f90.html","title":"calc_com.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  calc_kineticenergy.f90 !  by Martin Almlof !  calculates the kinetic energy of the center of mass of whatever atom !  mask is specified !------------------------------------------------------------------------------! module calc_com_ke use calc_base use maskmanip !       use LAPACKMINI implicit none !constants integer , parameter :: MAX_MASKS = 10 !module variables integer , parameter , private :: conversion_factor = 239 0.0574 ! gram/mol**&#94;2/fs&#94;2  -->  kcal/mol integer , private :: frames ( MAX_MASKS ), apa real ( 8 ), allocatable :: kineticenergy (:) type ( MASK_TYPE ), private , target :: masks ( MAX_MASKS ) integer , private :: Nmasks = 0 type COM_KE_COORD_TYPE real , pointer :: x (:), y (:), z (:), mass (:) end type COM_KE_COORD_TYPE type ( COM_KE_COORD_TYPE ), private :: coords_mass ( MAX_MASKS ), prev_coords_mass ( MAX_MASKS ) type COM_KE_VELOCITY_TYPE real , pointer :: x (:), y (:), z (:) end type COM_KE_VELOCITY_TYPE type ( COM_KE_VELOCITY_TYPE ), private :: velocity ( MAX_MASKS ), rel_coords ( MAX_MASKS ), prev_rel_coords ( MAX_MASKS ), rad_vec ( MAX_MASKS , 3 ) !rel_coords is not velocities type COORD_TYPE real , pointer :: xyz (:) end type COORD_TYPE type ( COORD_TYPE ), private :: coords ( MAX_MASKS ), prev_coords ( MAX_MASKS ) type DP_TYPE real , pointer :: dp (:) end type DP_TYPE type ( DP_TYPE ), private :: dp_vect ( MAX_MASKS ) type MASS_AVE_TYPE real :: x , y , z end type MASS_AVE_TYPE type ( MASS_AVE_TYPE ), private :: mass_ave ( MAX_MASKS ), prev_mass_ave ( MAX_MASKS ) , ang_momentum ( MAX_MASKS , 3 ) type EIGEN_STUFF_TYPE real :: evalue ( 3 ), evector ( 3 , 3 ) end type EIGEN_STUFF_TYPE type ( EIGEN_STUFF_TYPE ), private :: eigen_stuff ( MAX_MASKS ) real , private :: tot_mass ( MAX_MASKS ), KE_rot ( MAX_MASKS , 3 ) logical , private :: first_frame ( MAX_MASKS ) = . true . !       real,private                    :: previous_mass_center(3,MAX_MASKS) real , private :: frame_length = 0 contains subroutine COM_KE_initialize end subroutine COM_KE_initialize subroutine COM_KE_finalize ( i ) integer :: i call mask_finalize ( masks ( i )) end subroutine COM_KE_finalize integer function COM_KE_add ( desc ) !arguments character ( * ) :: desc character ( len = 80 ) :: line integer :: readstat integer :: ats , j if ( Nmasks == MAX_MASKS ) then write ( * , 10 ) MAX_MASKS return end if 10 format ( 'Sorry, the maximum number of COM_KE calculations is ' , i2 ) !get frame time length if ( frame_length == 0 ) then write ( * , '(a)' , advance = 'no' ) 'Enter time span between each trajectory frame (fs): ' read ( * , '(a)' , iostat = readstat ) line read ( line , * , iostat = readstat ) frame_length if ( readstat /= 0 . or . frame_length <= 0 ) then write ( * , 900 ) 900 format ( '>>>>> ERROR: Invalid time span.' ) COM_KE_add = 0 return end if end if !add a new COM_KE mask Nmasks = Nmasks + 1 call mask_initialize ( masks ( Nmasks )) ats = maskmanip_make ( masks ( Nmasks )) !discard if no atoms in mask if ( ats == 0 ) then call mask_finalize ( masks ( Nmasks )) Nmasks = Nmasks - 1 COM_KE_add = 0 return end if allocate ( coords ( Nmasks )% xyz ( 3 * ats ), prev_coords ( Nmasks )% xyz ( 3 * ats )) allocate ( coords_mass ( Nmasks )% x ( ats ), coords_mass ( Nmasks )% y ( ats ), coords_mass ( Nmasks )% z ( ats ), coords_mass ( Nmasks )% mass ( ats )) allocate ( prev_coords_mass ( Nmasks )% x ( ats ), prev_coords_mass ( Nmasks )% y ( ats )) allocate ( prev_coords_mass ( Nmasks )% z ( ats ), prev_coords_mass ( Nmasks )% mass ( ats )) allocate ( velocity ( Nmasks )% x ( ats ), velocity ( Nmasks )% y ( ats ), velocity ( Nmasks )% z ( ats )) allocate ( rel_coords ( Nmasks )% x ( ats ), rel_coords ( Nmasks )% y ( ats ), rel_coords ( Nmasks )% z ( ats )) allocate ( dp_vect ( Nmasks )% dp ( ats ) , prev_rel_coords ( Nmasks )% x ( ats )) allocate ( prev_rel_coords ( Nmasks )% y ( ats ), prev_rel_coords ( Nmasks )% z ( ats )) do j = 1 , 3 allocate ( rad_vec ( Nmasks , j )% x ( ats ), rad_vec ( Nmasks , j )% y ( ats ), rad_vec ( Nmasks , j )% z ( ats )) end do coords_mass ( Nmasks )% x (:) = 0 coords_mass ( Nmasks )% y (:) = 0 coords_mass ( Nmasks )% z (:) = 0 coords_mass ( Nmasks )% mass (:) = 0 coords ( Nmasks )% xyz (:) = 0 frames ( Nmasks ) = 0 call COM_KE_put_mass ( Nmasks ) COM_KE_add = Nmasks write ( desc , 20 ) masks ( Nmasks )% included 20 format ( 'Center of mass kinetic energy for ' , i6 , ' atoms' ) end function COM_KE_add subroutine COM_KE_calc ( i ) !arguments integer , intent ( in ) :: i integer :: info , IPIV ( 3 , 3 ), j double precision :: A ( 3 , 3 ), B ( 3 ), W ( 30 ), K ( 6 ), C ( 6 ) !locals real ( 8 ) :: KE , IXX , IXY , IXZ , IYY , IYZ , IZZ , tot_KE_rot if ( i < 1 . or . i > Nmasks ) return frames ( i ) = frames ( i ) + 1 if ( first_frame ( i )) then call mask_get ( masks ( i ), xin , coords ( i )% xyz ) prev_coords ( i )% xyz = coords ( i )% xyz first_frame ( i ) = . false . else prev_coords ( i )% xyz = coords ( i )% xyz call mask_get ( masks ( i ), xin , coords ( i )% xyz ) end if !split coords into x, y, and z coords coords_mass ( i )% x = coords ( i )% xyz ( 1 :: 3 ) coords_mass ( i )% y = coords ( i )% xyz ( 2 :: 3 ) coords_mass ( i )% z = coords ( i )% xyz ( 3 :: 3 ) prev_coords_mass ( i )% x = prev_coords ( i )% xyz ( 1 :: 3 ) prev_coords_mass ( i )% y = prev_coords ( i )% xyz ( 2 :: 3 ) prev_coords_mass ( i )% z = prev_coords ( i )% xyz ( 3 :: 3 ) !calculate center of mass mass_ave ( i )% x = dot_product ( coords_mass ( i )% x (:), coords_mass ( i )% mass ) / tot_mass ( i ) mass_ave ( i )% y = dot_product ( coords_mass ( i )% y (:), coords_mass ( i )% mass ) / tot_mass ( i ) mass_ave ( i )% z = dot_product ( coords_mass ( i )% z (:), coords_mass ( i )% mass ) / tot_mass ( i ) prev_mass_ave ( i )% x = dot_product ( prev_coords_mass ( i )% x (:), coords_mass ( i )% mass ) / tot_mass ( i ) prev_mass_ave ( i )% y = dot_product ( prev_coords_mass ( i )% y (:), coords_mass ( i )% mass ) / tot_mass ( i ) prev_mass_ave ( i )% z = dot_product ( prev_coords_mass ( i )% z (:), coords_mass ( i )% mass ) / tot_mass ( i ) !create coordinate set relative mass center rel_coords ( i )% x = coords_mass ( i )% x - mass_ave ( i )% x rel_coords ( i )% y = coords_mass ( i )% y - mass_ave ( i )% y rel_coords ( i )% z = coords_mass ( i )% z - mass_ave ( i )% z prev_rel_coords ( i )% x = prev_coords_mass ( i )% x - prev_mass_ave ( i )% x prev_rel_coords ( i )% y = prev_coords_mass ( i )% y - prev_mass_ave ( i )% y prev_rel_coords ( i )% z = prev_coords_mass ( i )% z - prev_mass_ave ( i )% z !calculate moment of inertia tensor IXX = dot_product ( ( rel_coords ( i )% y ) ** 2 + ( rel_coords ( i )% z ) ** 2 , coords_mass ( i )% mass ) IYY = dot_product ( ( rel_coords ( i )% x ) ** 2 + ( rel_coords ( i )% z ) ** 2 , coords_mass ( i )% mass ) IZZ = dot_product ( ( rel_coords ( i )% y ) ** 2 + ( rel_coords ( i )% x ) ** 2 , coords_mass ( i )% mass ) IXY = - 1. _ 8 * sum ( ( rel_coords ( i )% y ) * ( rel_coords ( i )% x ) * coords_mass ( i )% mass ) IXZ = - 1. _ 8 * sum ( ( rel_coords ( i )% x ) * ( rel_coords ( i )% z ) * coords_mass ( i )% mass ) IYZ = - 1. _ 8 * sum ( ( rel_coords ( i )% y ) * ( rel_coords ( i )% z ) * coords_mass ( i )% mass ) !calculate individual atom (relative?) velocities velocity ( i )% x = ( rel_coords ( i )% x - prev_rel_coords ( i )% x ) / frame_length velocity ( i )% y = ( rel_coords ( i )% y - prev_rel_coords ( i )% y ) / frame_length velocity ( i )% z = ( rel_coords ( i )% z - prev_rel_coords ( i )% z ) / frame_length !       write (*,*) ' ' K (:) = ( / IXX , IXY , IYY , IXZ , IYZ , IZZ / ) !       write(*,'(6f18.3)'), K(:) call EIGEN ( K , A , 3 , 0 ) do j = 1 , 3 !               write (*,*) A(1,j),A(2,j),A(3,j),K(j*(j+1)/2) !               write (*,*) info eigen_stuff ( i )% evalue ( j ) = K ( j * ( j + 1 ) / 2 ) eigen_stuff ( i )% evector (:, j ) = A (:, j ) !               write (*,'(4f23.8)') eigen_stuff(i)%evalue(j), eigen_stuff(i)%evector(:,j) end do !eigen_stuff(i)%evector are the NORMALIZED principal axes of rotation !vector of dot_product(principal axis,atom coordinate) do j = 1 , 3 dp_vect ( i )% dp = eigen_stuff ( i )% evector ( 1 , j ) * & rel_coords ( i )% x + eigen_stuff ( i )% evector ( 2 , j ) * & rel_coords ( i )% y + eigen_stuff ( i )% evector ( 3 , j ) * & rel_coords ( i )% z rad_vec ( i , j )% x = rel_coords ( i )% x - dp_vect ( i )% dp * eigen_stuff ( i )% evector ( 1 , j ) rad_vec ( i , j )% y = rel_coords ( i )% y - dp_vect ( i )% dp * eigen_stuff ( i )% evector ( 2 , j ) rad_vec ( i , j )% z = rel_coords ( i )% z - dp_vect ( i )% dp * eigen_stuff ( i )% evector ( 3 , j ) end do !now rad_vec(i,j)%x,y,z contains all the vectors of each atom to the principal axis j !time to take the cross-product of each atoms rad_vec with it's linear momentum vector !       do j=1,3 !               write (*,'(3f20.12)') sum(rad_vec(i,j)%x),sum(rad_vec(i,j)%y),sum(rad_vec(i,j)%z) !       end do do j = 1 , 3 ang_momentum ( i , j )% x = sum ( rad_vec ( i , j )% y * velocity ( i )% z * coords_mass ( i )% mass - & rad_vec ( i , j )% z * velocity ( i )% y * coords_mass ( i )% mass ) ang_momentum ( i , j )% y = sum ( rad_vec ( i , j )% z * velocity ( i )% x * coords_mass ( i )% mass - & rad_vec ( i , j )% x * velocity ( i )% z * coords_mass ( i )% mass ) ang_momentum ( i , j )% z = sum ( rad_vec ( i , j )% x * velocity ( i )% y * coords_mass ( i )% mass - & rad_vec ( i , j )% y * velocity ( i )% x * coords_mass ( i )% mass ) !               write (*,'(3f23.15)') ang_momentum(i,j)%x,ang_momentum(i,j)%y,ang_momentum(i,j)%z end do tot_KE_rot = 0 !Rotational kinetic energy = Lj&#94;2/(2Ij) do j = 1 , 3 KE_rot ( i , j ) = (( ang_momentum ( i , j )% x ) ** 2 + ( ang_momentum ( i , j )% y ) ** 2 + & ( ang_momentum ( i , j )% z ) ** 2 ) / ( 2 * eigen_stuff ( i )% evalue ( j )) * conversion_factor tot_KE_rot = tot_KE_rot + KE_rot ( i , j ) end do !       write (*,'(3f23.15)') KE_rot(i,1),KE_rot(i,2),KE_rot(i,3) !       calculate the kinetic energy KE = 0.5 * tot_mass ( i ) * (( prev_mass_ave ( i )% x - mass_ave ( i )% x ) ** 2 + & ( prev_mass_ave ( i )% y - mass_ave ( i )% y ) ** 2 + ( prev_mass_ave ( i )% z - & mass_ave ( i )% z ) ** 2 ) / frame_length ** 2 * conversion_factor write ( * , 100 , advance = 'no' ) KE , tot_KE_rot 100 format ( 2 f12 . 3 ) end subroutine COM_KE_calc subroutine COM_KE_put_mass ( i ) integer :: k , j , i , at real :: mass if ( i < 1 . or . i > Nmasks ) return tot_mass ( i ) = 0 !put in masses into coords_mass k = 1 do j = 1 , nat_pro if ( masks ( i )% MASK ( j )) then mass = iaclib ( iac ( j ))% mass coords_mass ( i )% mass ( k ) = mass tot_mass ( i ) = tot_mass ( i ) + mass k = k + 1 end if end do write ( * , 168 ) \"Total mass: \" , tot_mass ( i ) 168 format ( a , f10 . 3 ) end subroutine COM_KE_put_mass subroutine COM_KE_heading ( i ) integer :: i write ( * , '(a)' , advance = 'no' ) 'Trans  Rot (kcal/mol)' end subroutine COM_KE_heading end module calc_com_ke","tags":"","loc":"sourcefile/calc_com_ke.f90.html","title":"calc_com_ke.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  calc_entropy.f90 !  By Jens Carlsson, phd !  Absolute entropies according to Quasiharmonic analysis, Schlitter's formula !  and RMS fluctuations !------------------------------------------------------------------------------! module calc_entropy use calc_base use maskmanip use trj use calc_fit use calc_geom implicit none ! Constants ! pi, Planck's constant, R, reference_volume real ( 8 ) :: pi_val , hs , R , ref_vol , e , u , kb , cm !module variables type ( MASK_TYPE ), private , target :: masks ( MAX_MASKS ) integer , private :: Nmasks = 0 type COVARIANCE_MATRIX ! Numbers stored for covariance matrix calculation real ( 8 ) :: Exy , Ex , Ey ! C[X,Y] = E[XY] - E[X] -E[Y] end type COVARIANCE_MATRIX type ENTROPY_COORD_TYPE real , pointer :: x (:), xref (:) ! , Reference structure for rotational fit real ( 8 ), pointer :: xr (:) real ( 8 ) :: xrcm ( 3 ) integer :: interval , Calc_type ! Interval of calculations, character ( len = 9 ) :: Calc_select real ( 8 ) :: Temperature ! Temperature integer :: tot_no_frames ! Total number of frames end type ENTROPY_COORD_TYPE type ( ENTROPY_COORD_TYPE ), private :: coords ( MAX_MASKS ) integer :: entropy_frame , start type trajectory type ( COVARIANCE_MATRIX ), pointer :: COV_DATA (:,:) ! E[XY], E[X], E[Y] - for calculation of Covariance matrix real ( 8 ), pointer :: C (:,:), VIZ (:), massvector (:), Xcm (:,:), Xrot (:) , X (:,:) integer :: startframe , endframe , no_atoms , no_frames , store_cov , Temperature , Calc_type ! Under development: real ( 8 ), dimension ( 3 , 3 ) :: ROT real ( 8 ) :: masstot ! Total mass end type trajectory contains !--------------- !- Entropy Add - !--------------- integer function entropy_add ( desc ) !arguments character ( * ) :: desc integer :: ats if ( Nmasks == 1 ) then write ( * , 10 ) 1 entropy_add = 0 return end if 10 format ( 'Sorry, the maximum number of entropy calculations is ' , i2 ) ! Open output file open ( 100 , file = 'Entropy.out' , err = 999 ) ! Entropy output file 999 write ( * , '(a)' ) 'WARNING: Unable to initialize entropy output file. If you are not doing entropy calculations and & &multiple instances of Q are running in the same directory, you may ignore this warning.' !Add a new entropy mask Nmasks = Nmasks + 1 call mask_initialize ( masks ( Nmasks )) ats = maskmanip_make ( masks ( Nmasks )) WRITE ( * , '(a)' ) & '' , & '===================== Entropy calculation settings 1 ==============================' , & '   description                                                command   ' , & ' 1 Schlitters formula                                            1      ' , & ' 2 Quasiharmonic analysis                                        2      ' , & ' 3 Schlitters formula for masscenter of molecule                 3      ' , & ' 4 Principal variances (translation)                             4      ' , & ' 5 RMS deviations in Euler angles (Rotation)                     5      ' WRITE ( * , '(a)' , advance = 'no' ) & 'Qcalc> ' read ( * , * ) coords ( Nmasks )% Calc_type WRITE ( * , '(a)' ) & '' , & '===================== Entropy calculation settings 2 ==============================' , & '   description                                                command   ' , & ' 1 S[vibration,rotation,translation,configuration]            All       ' , & ' 2 S[vibration,rotation, conformation (vibration)]            No_transl ' , & ' 3 S[conformation (vibration)]                                No_rot    ' call getlin ( coords ( Nmasks )% Calc_select , 'Qcalc> ' ) WRITE ( * , '(a)' ) & 'Number of frames:' WRITE ( * , '(a)' , advance = 'no' ) & 'Qcalc> ' read ( * , * ) coords ( Nmasks )% interval ! Temperature set to default 300 coords ( Nmasks )% Temperature = 300 WRITE ( * , '(a)' ) & 'Set no frames:' WRITE ( * , '(a)' , advance = 'no' ) & 'Qcalc> ' read ( * , * ) coords ( Nmasks )% tot_no_frames if ( ats == 0 ) then call mask_finalize ( masks ( Nmasks )) Nmasks = Nmasks - 1 entropy_add = 0 return end if allocate ( coords ( Nmasks )% x ( 3 * ats ), coords ( Nmasks )% xref ( 3 * ats )) entropy_add = Nmasks write ( desc , 20 ) masks ( Nmasks )% included 20 format ( 'Entropy calculation for ' , i6 , ' atoms' ) end function entropy_add !------------------------ !- Construct trajectory - !------------------------ subroutine construct_trajectory ( t , Temp , startframe , endframe , no_atoms , Calc_type ) type ( trajectory ) :: t integer :: startframe , endframe , no_frames , no_atoms , i , j , Calc_type real ( 8 ) :: Temp character ( len = 20 ) :: dcd , top t % startframe = startframe ! Starting frame t % endframe = endframe ! Ending frame t % no_frames = endframe - startframe + 1 ! Calculate total number of frames t % no_atoms = no_atoms ! Number of atoms in mask t % Temperature = Temp ! Temperature t % Calc_type = Calc_type ! Store choice of calculation end subroutine construct_trajectory !------------------------------------------- !- Subroutine: Entropy initialize/finalize - !------------------------------------------- subroutine ENTROPY_initialize ! Set constants pi_val = 4 * atan ( 1. ) ! pi e = exp ( 1.0 ) ! Eulers number R = 1.9855026 ! In cal/mol kb = 1.38066 ! Boltzmann konstant  *10**(-23) hs = 1.0545727 ! Plancs constant     *10**(-34) u = 1.6605402 ! Atomic mass constant *10**(-27) from u to Kg ref_vol = 166 0.0 ! Corresponds to a 1M concentration cm = 3.3356410 / ( 2 * pi_val ) ! Constant for vibrational frequencies calculation ! Other variables entropy_frame = 1 start = 1 return end subroutine ENTROPY_initialize subroutine ENTROPY_finalize ( i ) integer :: i call mask_finalize ( masks ( i )) deallocate ( coords ( i )% xr , coords ( i )% x , coords ( i )% xref ) end subroutine ENTROPY_finalize !################### !- Entropy heading - !################### subroutine entropy_heading ( i ) integer :: i write ( * , '(a)' , advance = 'no' ) 'Entropy(cal/mol K)' end subroutine entropy_heading !####################################### !- Main entropy calculation subroutine - !####################################### subroutine entropy_calc ( i ) integer , intent ( in ) :: i integer :: j , k , l , n , m , o real ( 8 ) :: det , gauss , uniform !, ref_vol type ( trajectory ) :: t real ( 8 ), dimension ( 3 ) :: uin , vin ! Go on with entropy calculation if ( start == 1 ) then allocate ( coords ( i )% xr ( 3 * nat_pro )) allocate ( t % Xrot ( 3 ) ) select case ( coords ( i )% Calc_type ) case ( 1 : 2 ) allocate ( t % COV_DATA ( 1 : masks ( i )% included * 3 , masks ( i )% included * 3 )) case ( 3 : 5 ) allocate ( t % COV_DATA ( 3 , 3 )) end select call fit_make_reference ( i ) ! Reference for rotational fit start = 0 end if call construct_trajectory ( t , coords ( i )% Temperature , 1 , entropy_frame , masks ( i )% included , coords ( i )% Calc_type ) select case ( t % Calc_type ) case ( 1 : 2 ) if ( coords ( i )% Calc_select == 'No_rot' . OR . coords ( i )% Calc_select == 'No_transl' ) then call RotationAndTranslation ( t , i ) end if case ( 3 : 5 ) call RotationAndTranslation ( t , i ) end select ! Locate which atoms to make the calculation on call mask_get ( masks ( i ), xin , coords ( i )% x ) ! Uppdate COV_DATA for Schlitters formula and Quasiharmonics if ( t % Calc_type == 1 . OR . t % Calc_type == 2 ) then allocate ( t % massvector ( 3 * t % no_atoms )) n = 1 do l = 1 , nat_pro ! nat_pro is the total number of atoms in topology if ( masks ( Nmasks )% mask ( l )) then t % massvector ( 3 * n - 2 ) = iaclib ( iac ( l ))% mass t % massvector ( 3 * n - 1 ) = iaclib ( iac ( l ))% mass t % massvector ( 3 * n ) = iaclib ( iac ( l ))% mass n = n + 1 endif end do j = 1 k = 1 do j = 1 , t % no_atoms * 3 do k = 1 , j t % COV_DATA ( j , k )% Exy = ( t % COV_DATA ( j , k )% Exy * ( t % no_frames - 1 ) + coords ( i )% x ( j ) * coords ( i )% x ( k )) / t % no_frames t % COV_DATA ( j , k )% Ex = ( t % COV_DATA ( j , k )% Ex * ( t % no_frames - 1 ) + coords ( i )% x ( j )) / t % no_frames t % COV_DATA ( j , k )% Ey = ( t % COV_DATA ( j , k )% Ey * ( t % no_frames - 1 ) + coords ( i )% x ( k )) / t % no_frames t % COV_DATA ( k , j )% Exy = t % COV_DATA ( j , k )% Exy t % COV_DATA ( k , j )% Ex = t % COV_DATA ( j , k )% Ex t % COV_DATA ( k , j )% Ey = t % COV_DATA ( j , k )% Ey enddo enddo endif ! Schlitter or quasi? if ( mod ( entropy_frame , coords ( i )% interval ) == 0 ) then ! Check if entropy is to be calculated select case ( t % Calc_type ) ! Check which type of calculation is to be performed !--------------------- ! Schlitter's formula !--------------------- case ( 1 ) call CovarianceMatrix ( t ) call SchlittersFormula ( t , det ) write ( * , * ) 0.5 * R * det write ( 100 , * ) entropy_frame , 0.5 * 1.9855026 * det !------------------------ ! Quasiharmonic analysis !------------------------ case ( 2 ) call CovarianceMatrix ( t ) call Quasiharmonic_analysis ( i , t , det ) write ( * , * ) R * det ! 0.5* Used before to be compatible to schlitters formula write ( 100 , * ) R * det ! 0.5* !------------------------------------------ ! Schlitter's formula using center of mass !------------------------------------------ case ( 3 ) t % no_atoms = 1 call CovarianceMatrix ( t ) call SchlittersFormula ( t , det ) write ( * , * ) 0.5 * R * det write ( 100 , * ) 0.5 * R * det !----------------------------------------------- ! Principal RMS fluctuations for center of mass !----------------------------------------------- case ( 4 ) ! ref_vol = 1660.0   !34.123**3        !1660.0         !133.565**3 call PCA ( t , det ) gauss = R * log ( sqrt ( det ) * ( 2 * pi_val * exp ( 1.0 )) ** ( 1.5 ) / ref_vol ) uniform = R * log ( sqrt ( det ) * ( 12 ) ** ( 1.5 ) / ref_vol ) write ( * , * ) 'Gaussian approximation:  dS(transl) =' , gauss write ( * , * ) 'Uniform approximation:      dS(transl) =' , uniform write ( 100 , * ) gauss , uniform !---------------------------------- ! RMS fluctuations in Euler angles !---------------------------------- case ( 5 ) call PCA ( t , det ) gauss = R * log ( sqrt ( det ) * sin ( t % COV_DATA ( 1 , 1 )% Ex ) * ( 2 * pi_val * exp ( 1.0 )) ** ( 1.5 ) / ( 8 * pi_val ** 2 ) ) uniform = R * log ( sqrt ( det ) * sin ( t % COV_DATA ( 1 , 1 )% Ex ) * ( 12 ) ** ( 1.5 ) / ( 8 * pi_val ** 2 ) ) write ( * , * ) 'Gaussian approximation:  dS(rot) =' , gauss write ( * , * ) 'Uniform approximation:   dS(rot) =' , uniform write ( 100 , * ) entropy_frame , gauss , uniform end select endif ! Deallocate vector containing all coordinates if ( entropy_frame == coords ( i )% tot_no_frames ) then deallocate ( t % massvector ) end if entropy_frame = entropy_frame + 1 end subroutine entropy_calc !################################# !- Covariance matrix calculation - !################################# subroutine CovarianceMatrix ( t ) type ( trajectory ) :: t integer :: i , j ! Allocate covariance matrix allocate ( t % C ( 1 : t % no_atoms * 3 , 1 : t % no_atoms * 3 ) ) do i = 1 , t % no_atoms * 3 do j = 1 , i t % C ( i , j ) = t % COV_DATA ( i , j )% Exy - t % COV_DATA ( i , j )% Ex * t % COV_DATA ( i , j )% Ey t % C ( j , i ) = t % C ( i , j ) enddo enddo end subroutine CovarianceMatrix !##################################################### !- Calculation of Schlitter's formula type entropies - !##################################################### ! Evaluates the determinant of a coleskyfactorized matrix subroutine SchlittersFormula ( t , det ) type ( trajectory ) :: t integer :: i , k real ( 8 ) :: det call MultiplyMatrices ( t ) !  MCM + 1 call CholeskyFactorization ( t ) !  Coleskyfactorized matrix, L (C = L*L ), is stored in C ! Calculate entropy det = 0.0 do i = 1 , t % no_atoms * 3 det = det + 2 * log ( t % C ( i , i )) !  det L*L =  2 * det L end do deallocate ( t % C ) ! Deallocate covariance matrix end subroutine SchlittersFormula !################################################ ! Multiplies Matrice with Schlitter's constants - !################################################ subroutine MultiplyMatrices ( t ) type ( trajectory ) :: t integer :: i , j , k , l , n real ( 8 ) :: det , c !, kb, hs, e, c, u ! Set constants ! kb=1.38066       ! Boltzmann konstant  *10**(-23) ! hs=1.0545727    ! Plancs constant     *10**(-34) ! e=2.718281828       ! Euler number ! u=1.6605402      ! Atomic mass constant *10**(-27) from u to Kg c = ( e ** 2 ) * kb * ( t % Temperature ) * u * 0.01 / ( hs ** 2 ) ! 0.01 is � to m, u is u to kg (hs*hs) to hs**2 do i = 1 , t % no_atoms * 3 do j = 1 , i !t%no_atoms*3 ! Multiply with constant t % C ( i , j ) = c * t % C ( i , j ) * sqrt ( t % massvector ( i ) * t % massvector ( j )) t % C ( j , i ) = t % C ( i , j ) ! Symmetrix matrix ! Add diagonal matrix to massweigted matrix if ( i == j ) then t % C ( i , i ) = t % C ( i , i ) + 1.0 endif enddo enddo end subroutine MultiplyMatrices !############################################# !- Choleskyfactorization of symmetric matrix - !############################################# ! Coleskyfactorizes the covariance matrix and ! and stores the result (L) in C, C = L*L ! Heath, M., Scientific Computing - An Introduction Survey subroutine CholeskyFactorization ( t ) type ( trajectory ) :: t integer :: i , j , k , l do j = 1 , t % no_atoms * 3 do k = 1 , j - 1 do i = j , t % no_atoms * 3 t % C ( i , j ) = t % C ( i , j ) - t % C ( i , k ) * t % C ( j , k ) enddo enddo if ( t % C ( j , j ) < 0.0 ) then print * , \"Matrix is not positive definite!\" ! Should hold. endif t % C ( j , j ) = sqrt ( t % C ( j , j )) do k = j + 1 , t % no_atoms * 3 t % C ( k , j ) = t % C ( k , j ) / t % C ( j , j ) end do end do end subroutine CholeskyFactorization !####################################################### !- Removal of Translational and/or rotational movement - !####################################################### subroutine RotationAndTranslation ( t , i ) integer , intent ( in ) :: i integer :: at , j , k integer :: lsqstatus real ( 8 ) :: totmass , error real ( 8 ) :: xcm ( 3 ) type ( trajectory ) :: t !calc. mass centre of xin xcm (:) = 0. totmass = 0 do at = 1 , nat_pro if ( masks ( i )% mask ( at )) then ! Take only the ones specified in mask xcm (:) = xcm (:) + xin ( 3 * at - 2 : 3 * at ) * iaclib ( iac ( at ))% mass totmass = totmass + iaclib ( iac ( at ))% mass end if end do xcm (:) = xcm (:) / totmass allocate ( t % massvector ( 3 )) t % massvector ( 1 ) = totmass t % massvector ( 2 ) = totmass t % massvector ( 3 ) = totmass if ( t % Calc_type == 3 . OR . t % Calc_type == 4 ) then ! If we want to calculate the center of mass motion ! Uppdate covariance matrix do j = 1 , 3 do k = 1 , j t % COV_DATA ( j , k )% Exy = ( t % COV_DATA ( j , k )% Exy * ( t % no_frames - 1 ) + xcm ( j ) * xcm ( k )) / t % no_frames t % COV_DATA ( j , k )% Ex = ( t % COV_DATA ( j , k )% Ex * ( t % no_frames - 1 ) + xcm ( j )) / t % no_frames t % COV_DATA ( j , k )% Ey = ( t % COV_DATA ( j , k )% Ey * ( t % no_frames - 1 ) + xcm ( k )) / t % no_frames t % COV_DATA ( k , j )% Exy = t % COV_DATA ( j , k )% Exy t % COV_DATA ( k , j )% Ex = t % COV_DATA ( j , k )% Ex t % COV_DATA ( k , j )% Ey = t % COV_DATA ( j , k )% Ey enddo enddo endif if ( coords ( i )% Calc_select == 'No_transl' ) then ! Translation is removed ! Remove translational motion, shift xin to origin do at = 1 , nat_pro xin ( 3 * at - 2 ) = xin ( 3 * at - 2 ) - xcm ( 1 ) xin ( 3 * at - 1 ) = xin ( 3 * at - 1 ) - xcm ( 2 ) xin ( 3 * at ) = xin ( 3 * at ) - xcm ( 3 ) enddo elseif ( coords ( i )% Calc_select == 'No_rot' ) then ! Translation and Rotation is removed ! Remove translational motion and massweight, shift xin to origin do at = 1 , nat_pro xin ( 3 * at - 2 ) = ( xin ( 3 * at - 2 ) - xcm ( 1 )) * sqrt ( iaclib ( iac ( at ))% mass ) xin ( 3 * at - 1 ) = ( xin ( 3 * at - 1 ) - xcm ( 2 )) * sqrt ( iaclib ( iac ( at ))% mass ) xin ( 3 * at ) = ( xin ( 3 * at ) - xcm ( 3 )) * sqrt ( iaclib ( iac ( at ))% mass ) end do ! rotate xin to fit with coords(i)%xr lsqstatus = LSQSTR ( nat_pro , masks ( i )% mask (:), coords ( i )% xr (:), xin (:), error , t % ROT ) if ( lsqstatus == 1 ) then print * , 'Error: Least sqares fit failed' end if if ( t % Calc_type == 5 ) then call Euler_angles ( t ) endif ! Divide the output coordinates with the mass of the particles. ! xrcm is not weighted in fit make reference and is not needed for entropy calculation (it keeps things at zero) do at = 1 , nat_pro xin ( 3 * at - 2 ) = xin ( 3 * at - 2 ) / sqrt ( iaclib ( iac ( at ))% mass ) xin ( 3 * at - 1 ) = xin ( 3 * at - 1 ) / sqrt ( iaclib ( iac ( at ))% mass ) xin ( 3 * at ) = xin ( 3 * at ) / sqrt ( iaclib ( iac ( at ))% mass ) end do endif end subroutine RotationAndTranslation !################################ !- Makes reference for RMS fit  - !################################ subroutine fit_make_reference ( i ) !arguments integer :: i !locals integer :: at real ( 8 ) :: totmass if ( i < 1 . or . i > Nmasks ) return !calc centre vector of mass coords ( i )% xrcm (:) = 0. totmass = 0.0 do at = 1 , nat_pro if ( masks ( i )% mask ( at )) then coords ( i )% xrcm (:) = coords ( i )% xrcm (:) + xin ( 3 * at - 2 : 3 * at ) * iaclib ( iac ( at ))% mass totmass = totmass + iaclib ( iac ( at ))% mass end if end do coords ( i )% xrcm (:) = coords ( i )% xrcm (:) / totmass ! Center of mass ! shift to origin and massweight coordinates in order to get massweighted RMS fit do at = 1 , nat_pro coords ( i )% xr ( 3 * at - 2 ) = ( xin ( 3 * at - 2 ) - coords ( i )% xrcm ( 1 )) * sqrt ( iaclib ( iac ( at ))% mass ) coords ( i )% xr ( 3 * at - 1 ) = ( xin ( 3 * at - 1 ) - coords ( i )% xrcm ( 2 )) * sqrt ( iaclib ( iac ( at ))% mass ) coords ( i )% xr ( 3 * at ) = ( xin ( 3 * at ) - coords ( i )% xrcm ( 3 )) * sqrt ( iaclib ( iac ( at ))% mass ) end do end subroutine fit_make_reference !######################################################## !- Calculation of Quasiharmonic analysis type entropies - !######################################################## ! Performs Quasiharmonic analysis according to: ! Andricioaei, I. and Karplus, M. (2001) Journal of Chemical Physics 115, 6289-6292. subroutine Quasiharmonic_analysis ( i , t , det ) type ( trajectory ) :: t real ( 8 ), dimension (:,:), pointer :: R ! can I remove this real ( 8 ) :: det integer :: i call massweight ( t ) ! Massweighting of the Covariancematrix sqrt(M)*C*sqrt(M) call VIZ ( t ) ! Transformation to storage for symmetrix matrix call eigen ( t % VIZ , R , t % no_atoms * 3 , 1 ) ! Calculation of eigenvalues (vibrational frequencies) call entropy_ho ( i , t , det ) ! Calculation of entropy from Harmonic oscillator end subroutine Quasiharmonic_analysis !######################### !- Subroutine massweight - !######################### subroutine massweight ( t ) ! Massweighting of coordinates type ( trajectory ) :: t integer :: i , j do i = 1 , t % no_atoms * 3 do j = 1 , i ! Symmetrix matrix t % C ( i , j ) = sqrt ( t % massvector ( i ) * t % massvector ( j )) * t % C ( i , j ) t % C ( j , i ) = t % C ( i , j ) !       if( i == j ) then !     t%C(i,j) = t%C(i,j)          + 1.0 !       endif end do end do end subroutine massweight !############################################ !- VIZ - smart storage for symmetric matrix - !############################################ subroutine VIZ ( t ) type ( trajectory ) :: t integer :: i , j , k allocate ( t % VIZ ( 3 * t % no_atoms * ( 3 * t % no_atoms + 1 ) / 2 ) ) do i = 1 , t % no_atoms * 3 do j = 1 , t % no_atoms * 3 k = i * ( i - 1 ) / 2 + j t % VIZ ( k ) = t % C ( i , j ) end do end do deallocate ( t % C ) end subroutine VIZ !#################################### !- Entropy from harmonic oscillator - !#################################### subroutine entropy_ho ( m , t , det ) type ( trajectory ) :: t integer :: i , k , no_freq , m real ( 8 ) :: det , hswkT , w , cm , scaling ! , hs, kb, u, ,pi ! kb = 1.380658                         ! 10**(-23) ! hs = 1.05457266                       ! 10**(-34) ! u  = 1.6605402                    ! 10**(-27), u to Kg ! pi = acos(-1.0)                       ! Pi cm = 3.3356410 / ( 2 * pi ) ! 10**(-11), s**(-1) to cm**(-1) ! Different number of eigenvalues are used depending if ! any degrees of freedom have been removed if ( coords ( m )% Calc_select == 'No_rot' ) then no_freq = 3 * t % no_atoms - 6 elseif ( coords ( m )% Calc_select == 'No_transl' ) then no_freq = 3 * t % no_atoms - 3 else no_freq = 3 * t % no_atoms endif WRITE ( * , '(a)' ) ':' WRITE ( * , '(a)' ) & '------------------------------------------------------------------------' ,& '         Frequency (cm**(-1))                  S (cal/mol Kelvin)' det = 0.0 do i = 1 , no_freq k = i * ( i + 1 ) / 2 ! Transformation to VIZ format w = sqrt ( kb * t % Temperature / ( u * t % VIZ ( k ))) ! Removed -1.0 since i don't have to shift  ! 10**(12) = sqrt(10**(-23, kb)/(10**(-27, u)*10**(-20, �**2 to m**2)) hswkT = 10 * hs * w / ( kb * t % Temperature ) ! 10**(1) = 10**(-34, h)*10**(12, w)/10**(-23, kb) write ( * , '(i10,a,3f8.3)' , advance = 'no' ) i , '. ' , 10 * cm * w ! 10**(1) = 10**(12,w)*10**(-11,cm) write ( * , '(a)' , advance = 'no' ) '                      ' write ( * , '(3f8.3)' ) 1.9855026 * ( hswkT / ( exp ( hswkT ) - 1 ) - log ( 1 - exp ( - hswkT ))) det = det + hswkT / ( exp ( hswkT ) - 1 ) - log ( 1 - exp ( - hswkT )) enddo WRITE ( * , '(a)' ) & '-------------------------------------------------------------------------' WRITE ( * , '(a)' , advance = 'no' ) & 'S(Total) = ' !det=det*2.0        ! Technical thing to make it compatible to calculations using Schlitter's formula - not needed anymore end subroutine entropy_ho !################################## !- Principal components of motion - !################################## ! Finds principal variances in translational motion subroutine PCA ( t , det ) type ( trajectory ) :: t integer :: i , j , k , rotation real ( 8 ), dimension (:,:), pointer :: R real ( 8 ) :: det ! Can only be done if center off mass has been removed if ( t % Calc_type == 5 ) then !deallocate(t%X) !allocate(t%X(1:3,1:t%no_frames)) !t%X = t%Xrot t % no_atoms = 1 print * , '<theta> =' , t % COV_DATA ( 1 , 1 )% Ex endif ! Remove masses from covariance calculation do i = 1 , 3 t % massvector ( i ) = 1.0 enddo call CovarianceMatrix ( t ) call VIZ ( t ) if ( t % Calc_type == 4 ) then call eigen ( t % VIZ , R , 3 , 1 ) endif det = 1 print * , '' do j = 1 , 3 k = j * ( j + 1 ) / 2 print * , 'Variance in direction' , j , t % VIZ ( k ) det = det * t % VIZ ( k ) ! multiplying principal RMS deviations enddo end subroutine PCA !############################### !- Calculation of Euler angles - !############################### ! Euler type angle from Classical dynamics of particles and systems, Marion Thornton subroutine Euler_angles ( t ) type ( trajectory ) :: t real ( 8 ) :: phi , psi , theta , delta integer :: i , j , k theta = acos ( t % ROT ( 3 , 3 )) ! Calculate Euler angles phi = atan2 ( t % ROT ( 3 , 1 ) / sin ( theta ), - t % ROT ( 3 , 2 ) / sin ( theta )) psi = atan2 ( t % ROT ( 1 , 3 ) / sin ( theta ), t % ROT ( 2 , 3 ) / sin ( theta )) t % Xrot ( 1 ) = theta t % Xrot ( 2 ) = psi t % Xrot ( 3 ) = phi ! Uppdate covariance matrix do j = 1 , 3 do k = 1 , j t % COV_DATA ( j , k )% Exy = ( t % COV_DATA ( j , k )% Exy * ( t % no_frames - 1 ) + t % Xrot ( j ) * t % Xrot ( k )) / t % no_frames t % COV_DATA ( j , k )% Ex = ( t % COV_DATA ( j , k )% Ex * ( t % no_frames - 1 ) + t % Xrot ( j )) / t % no_frames t % COV_DATA ( j , k )% Ey = ( t % COV_DATA ( j , k )% Ey * ( t % no_frames - 1 ) + t % Xrot ( k )) / t % no_frames t % COV_DATA ( k , j )% Exy = t % COV_DATA ( j , k )% Exy t % COV_DATA ( k , j )% Ex = t % COV_DATA ( j , k )% Ex t % COV_DATA ( k , j )% Ey = t % COV_DATA ( j , k )% Ey enddo enddo end subroutine Euler_angles !######################################### !- Subroutine to update Covariancematrix - !######################################### subroutine UpdateCovariancematrix ( t , i ) ! NOTE: Not in use yet! type ( trajectory ) :: t integer :: i , j , k do j = 1 , t % no_atoms * 3 do k = 1 , j t % COV_DATA ( j , k )% Exy = ( t % COV_DATA ( j , k )% Exy * ( t % no_frames - 1 ) + coords ( i )% x ( j ) * coords ( i )% x ( k )) / t % no_frames t % COV_DATA ( j , k )% Ex = ( t % COV_DATA ( j , k )% Ex * ( t % no_frames - 1 ) + coords ( i )% x ( j )) / t % no_frames t % COV_DATA ( j , k )% Ey = ( t % COV_DATA ( j , k )% Ey * ( t % no_frames - 1 ) + coords ( i )% x ( k )) / t % no_frames t % COV_DATA ( k , j )% Exy = t % COV_DATA ( j , k )% Exy t % COV_DATA ( k , j )% Ex = t % COV_DATA ( j , k )% Ex t % COV_DATA ( k , j )% Ey = t % COV_DATA ( j , k )% Ey enddo enddo end subroutine UpdateCovariancematrix end module calc_entropy","tags":"","loc":"sourcefile/calc_entropy.f90.html","title":"calc_entropy.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  calc_fit.f90 !  by John Marelius !  parts (C) 1979 W. F. van Gunsteren !  pair-wise superposition of coordidinate sets !------------------------------------------------------------------------------! module calc_fit use calc_base use maskmanip implicit none !constants integer , parameter :: MAX_MASKS = 10 !module variables type ( MASK_TYPE ), private , target :: masks ( MAX_MASKS ) integer , private :: Nmasks = 0 type FIT_COORD_TYPE real ( 8 ), pointer :: xr (:) real ( 8 ) :: xrcm ( 3 ) end type FIT_COORD_TYPE type ( FIT_COORD_TYPE ), private :: coords ( MAX_MASKS ) contains subroutine fit_initialize end subroutine fit_initialize subroutine fit_finalize ( i ) integer :: i call mask_finalize ( masks ( i )) end subroutine fit_finalize integer function fit_add ( desc ) !arguments character ( * ) :: desc integer :: ats if ( Nmasks == MAX_MASKS ) then write ( * , 10 ) MAX_MASKS return end if 10 format ( 'Sorry, the maximum number of LSQ fits is ' , i2 ) !add a new RMS mask Nmasks = Nmasks + 1 call mask_initialize ( masks ( Nmasks )) ats = maskmanip_make ( masks ( Nmasks )) !discard if no atoms in mask if ( ats == 0 ) then call mask_finalize ( masks ( Nmasks )) Nmasks = Nmasks - 1 fit_add = 0 return end if allocate ( coords ( Nmasks )% xr ( 3 * nat_pro )) call fit_make_ref ( Nmasks ) fit_add = Nmasks write ( desc , 20 ) masks ( Nmasks )% included 20 format ( 'Least squares fit of ' , i6 , ' atoms' ) end function fit_add subroutine fit_calc ( i ) !arguments integer , intent ( in ) :: i !locals integer :: at integer :: lsqstatus real ( 8 ) :: xcm ( 3 ), totmass , U ( 3 , 3 ), E if ( i < 1 . or . i > Nmasks ) return !calc. mass centre of xin xcm (:) = 0. totmass = 0.0 do at = 1 , nat_pro if ( masks ( i )% mask ( at )) then xcm (:) = xcm (:) + xin ( 3 * at - 2 : 3 * at ) * iaclib ( iac ( at ))% mass totmass = totmass + iaclib ( iac ( at ))% mass end if end do ! Calculate center of mass (/masks(i)%included for geometric) xcm (:) = xcm (:) / totmass ! shift xin to origin and massweight do at = 1 , nat_pro xin ( 3 * at - 2 ) = ( xin ( 3 * at - 2 ) - xcm ( 1 )) * sqrt ( iaclib ( iac ( at ))% mass ) !sqrt(iaclib(iac(at))%mass) xin ( 3 * at - 1 ) = ( xin ( 3 * at - 1 ) - xcm ( 2 )) * sqrt ( iaclib ( iac ( at ))% mass ) !sqrt(iaclib(iac(at))%mass) xin ( 3 * at ) = ( xin ( 3 * at ) - xcm ( 3 )) * sqrt ( iaclib ( iac ( at ))% mass ) !sqrt(iaclib(iac(at))%mass) end do !rotate xin to fit with coords(i)%xr lsqstatus = LSQSTR ( nat_pro , masks ( i )% mask (:), coords ( i )% xr (:), xin (:), E , U ) ! Remove massweighting and ! Add the translation vector if ( lsqstatus == 1 ) then print * , \"Failed!\" endif do at = 1 , nat_pro xin ( 3 * at - 2 ) = xin ( 3 * at - 2 ) / sqrt ( iaclib ( iac ( at ))% mass ) + coords ( i )% xrcm ( 1 ) xin ( 3 * at - 1 ) = xin ( 3 * at - 1 ) / sqrt ( iaclib ( iac ( at ))% mass ) + coords ( i )% xrcm ( 2 ) xin ( 3 * at ) = xin ( 3 * at ) / sqrt ( iaclib ( iac ( at ))% mass ) + coords ( i )% xrcm ( 3 ) enddo end subroutine fit_calc subroutine fit_make_ref ( i ) !arguments integer :: i !locals integer :: at real ( 8 ) :: totmass if ( i < 1 . or . i > Nmasks ) return !calc centre vector coords ( i )% xrcm (:) = 0. totmass = 0.0 do at = 1 , nat_pro if ( masks ( i )% mask ( at )) then coords ( i )% xrcm (:) = coords ( i )% xrcm (:) + xtop ( 3 * at - 2 : 3 * at ) * iaclib ( iac ( at ))% mass totmass = totmass + iaclib ( iac ( at ))% mass end if end do coords ( i )% xrcm (:) = coords ( i )% xrcm (:) / totmass !/for geometric masks(i)%included ! shift to origin and massweight coordinates do at = 1 , nat_pro coords ( i )% xr ( 3 * at - 2 ) = ( xtop ( 3 * at - 2 ) - coords ( i )% xrcm ( 1 )) * sqrt ( iaclib ( iac ( at ))% mass ) coords ( i )% xr ( 3 * at - 1 ) = ( xtop ( 3 * at - 1 ) - coords ( i )% xrcm ( 2 )) * sqrt ( iaclib ( iac ( at ))% mass ) coords ( i )% xr ( 3 * at ) = ( xtop ( 3 * at ) - coords ( i )% xrcm ( 3 )) * sqrt ( iaclib ( iac ( at ))% mass ) end do end subroutine fit_make_ref integer function LSQSTR ( NR , W , XP , X , E , U ) !CCCCC W.F. VAN GUNSTEREN, CAMBRIDGE, JULY 1979 CCCCCCCCCCCCCCCCCCCCCCCC !                                                                      C !         SUBROUTINE LSQSTR (NR,W,XP,X,E,IROT)                         C !                                                                      C !OMMENT   LSQSTR ROTATES THE ATOMS WITH COORDINATES X ABOUT THE ORIGIN C !         SUCH THAT THE FUNCTION E = 0.5 * SUM OVER ALL NR ATOMS OF        C !         W*(X-XP)**2 HAS A MINIMUM. HERE W DENOTES THE WEIGHT FACTORS AND C !         XP ARE THE REFERENCE COORDINATES. FOR A DESCRIPTION OF THE       C !         METHOD SEE A.D. MCLACHLAN, J. MOL. BIOL. 128 (1979) 49.          C !         IF THE SUBROUTINE FAILS, IT IS RETURNED WITH A MESSAGE AND       C !         IROT=0.                                                          C !                                                                          C !         NR = NUMBER OF ATOMS                                             C !         W(1..NR) = ATOMIC WEIGHT FACTORS                                 C !         XP(1..3*NR) = REFERENCE ATOM COORDINATES                         C !         X(1..3*NR) = ATOM COORDINATES; DELIVERED WITH THE ROTATED ONES   C !         If present, !         E is DELIVERED WITH THE MINIMUM VALUE OF THE FUNCTION E          C !                                                                          C !         LSQSTR USES SUBR. EIGEN.                                         C !                                                                          C !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC ! !       converted to F90 function by John Marelius, July 2000 !       returns 0 on success, 1 if Det(U) < 1e-9, 2 if Det(U) < 0 and Omega has !       degenerate eigenvalues !       Weight vector W has been made logical implicit none !arguments integer , intent ( in ) :: NR logical ( 1 ), intent ( in ) :: W (:) real ( 8 ), intent ( in ) :: XP (:) real ( 8 ), intent ( inout ) :: X (:) real ( 8 ), optional , intent ( out ) :: E !locals real ( 8 ), optional :: U ( 3 , 3 ) real ( 8 ) :: COM ( 21 ), OM ( 6 , 6 ) real ( 8 ) :: VH ( 3 , 3 ), VK ( 3 , 3 ) real ( 8 ) :: DU real ( 8 ) :: SIG integer :: I , J , M , M1 , M2 ! !*****CALCULATE THE MATRIX U AND ITS DETERMINANT U (:,:) = 0. DO J = 1 , NR if ( W ( J )) then U (:,:) = U (:,:) + matmul ( reshape ( X ( 3 * J - 2 : 3 * J ),( / 3 , 1 / )), & reshape ( XP ( 3 * J - 2 : 3 * J ),( / 1 , 3 / ))) end if END DO ! DU = U ( 1 , 1 ) * U ( 2 , 2 ) * U ( 3 , 3 ) + U ( 1 , 3 ) * U ( 2 , 1 ) * U ( 3 , 2 ) & + U ( 1 , 2 ) * U ( 2 , 3 ) * U ( 3 , 1 ) - U ( 3 , 1 ) * U ( 2 , 2 ) * U ( 1 , 3 ) & - U ( 3 , 3 ) * U ( 2 , 1 ) * U ( 1 , 2 ) - U ( 3 , 2 ) * U ( 2 , 3 ) * U ( 1 , 1 ) IF ( ABS ( DU ) < 1.E-9 ) then LSQSTR = 1 return end if !*****CONSTRUCT OMEGA, DIAGONALIZE IT AND DETERMINE H AND K M = 0 DO M1 = 1 , 6 DO M2 = 1 , M1 M = M + 1 IF ( M1 > 3 . AND . M2 <= 3 ) then COM ( M ) = U ( M2 , M1 - 3 ) else COM ( M ) = 0. end if END DO END DO ! CALL EIGEN ( COM , OM , 6 , 0 ) IF ( DU < 0. . AND . ABS ( COM ( 3 ) - COM ( 6 )) < 1.E-5 ) then LSQSTR = 2 return end if ! VH (:,:) = sqrt ( 2. ) * OM ( 1 : 3 , 1 : 3 ) VK (:,:) = sqrt ( 2. ) * OM ( 4 : 6 , 1 : 3 ) SIG = ( VH ( 2 , 1 ) * VH ( 3 , 2 ) - VH ( 3 , 1 ) * VH ( 2 , 2 )) * VH ( 1 , 3 ) & + ( VH ( 3 , 1 ) * VH ( 1 , 2 ) - VH ( 1 , 1 ) * VH ( 3 , 2 )) * VH ( 2 , 3 ) & + ( VH ( 1 , 1 ) * VH ( 2 , 2 ) - VH ( 2 , 1 ) * VH ( 1 , 2 )) * VH ( 3 , 3 ) IF ( SIG <= 0. ) then VH (:, 3 ) = - VH (:, 3 ) VK (:, 3 ) = - VK (:, 3 ) end if ! !*****DETERMINE R AND ROTATE X DO M2 = 1 , 3 DO M1 = 1 , 3 U ( M1 , M2 ) = VK ( M1 , 1 ) * VH ( M2 , 1 ) + VK ( M1 , 2 ) * VH ( M2 , 2 ) & + sign ( 1. _ 8 , DU ) * VK ( M1 , 3 ) * VH ( M2 , 3 ) end do END DO ! DO J = 1 , NR X ( 3 * J - 2 : 3 * J ) = matmul ( U , X ( 3 * J - 2 : 3 * J )) END DO LSQSTR = 0 !OK ! !*****CALCULATE E, WHEN REQUIRED if ( present ( E )) then E = 0. DO J = 1 , NR if ( W ( J )) E = E + sum (( X ( 3 * J - 2 : 3 * J ) - XP ( 3 * J - 2 : 3 * J )) ** 2 ) end do E = E / 2. end if END function LSQSTR end module calc_fit","tags":"","loc":"sourcefile/calc_fit.f90.html","title":"calc_fit.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  calc_geom.f90 !  by John Marelius !  geometry analysis functions !------------------------------------------------------------------------------! module calc_geom use calc_base implicit none !constants integer , parameter :: MAX_MEASUREMENTS = 99 !module variables real ( 8 ) :: pi integer , private :: Nmeas = 0 type GEOM_TYPE integer :: i , j , k , l , cod integer :: kind end type GEOM_TYPE type ( GEOM_TYPE ), private :: geom ( MAX_MEASUREMENTS ) contains subroutine geom_initialize pi = 4 * atan ( 1. ) end subroutine geom_initialize subroutine geom_finalize end subroutine geom_finalize integer function dist_add ( desc ) !arguments character ( * ) :: desc !locals character ( len = 80 ) :: line integer :: readstat integer :: b if ( Nmeas == MAX_MEASUREMENTS ) then write ( * , 10 ) MAX_MEASUREMENTS return end if 10 format ( 'Sorry, the maximum number of geometry calculations is ' , i2 ) !add a new dist measurement Nmeas = Nmeas + 1 write ( * , '(a)' , advance = 'no' ) 'dist: Enter the two atom numbers: ' read ( * , '(a)' , iostat = readstat ) line read ( line , * , iostat = readstat ) geom ( Nmeas )% i , geom ( Nmeas )% j if ( readstat /= 0 . or . geom ( Nmeas )% i < 1 . or . geom ( Nmeas )% i > nat_pro . or . & geom ( Nmeas )% j < 1 . or . geom ( Nmeas )% j > nat_pro ) then write ( * , 900 ) 900 format ( '>>>>> ERROR: Invalid atom number(s).' ) Nmeas = Nmeas - 1 dist_add = 0 return end if geom ( Nmeas )% cod = 0 !clear force field code !search topology for a bond between these atoms do b = 1 , nbonds if (( bnd ( b )% i == geom ( Nmeas )% i . and . bnd ( b )% j == geom ( Nmeas )% j ) . or . & ( bnd ( b )% j == geom ( Nmeas )% i . and . bnd ( b )% i == geom ( Nmeas )% j )) then geom ( Nmeas )% cod = bnd ( b )% cod exit end if end do dist_add = Nmeas if ( geom ( Nmeas )% cod > 0 ) then write ( desc , 19 ) geom ( Nmeas )% i , geom ( Nmeas )% j 19 format ( 'distance, bond energy between atoms' , i5 , ' and' , i5 ) else write ( desc , 20 ) geom ( Nmeas )% i , geom ( Nmeas )% j 20 format ( 'distance between atoms' , i5 , ' and' , i5 ) end if end function dist_add integer function angle_add ( desc ) !arguments character ( * ) :: desc !locals character ( len = 80 ) :: line integer :: readstat integer :: i , j , k integer :: b if ( Nmeas == MAX_MEASUREMENTS ) then write ( * , 10 ) MAX_MEASUREMENTS return end if 10 format ( 'Sorry, the maximum number of geometry calculations is ' , i2 ) !add a new dist measurement Nmeas = Nmeas + 1 write ( * , '(a)' , advance = 'no' ) 'angle: Enter the three atom numbers: ' read ( * , '(a)' , iostat = readstat ) line read ( line , * , iostat = readstat ) i , j , k if ( readstat /= 0 . or . i < 1 . or . i > nat_pro . or . & j < 1 . or . j > nat_pro . or . & k < 1 . or . k > nat_pro . or . & i == j . or . i == k . or . j == k ) then write ( * , 900 ) 900 format ( '>>>>> ERROR: Invalid atom number(s).' ) Nmeas = Nmeas - 1 angle_add = 0 return end if geom ( Nmeas )% i = i geom ( Nmeas )% j = j geom ( Nmeas )% k = k geom ( Nmeas )% cod = 0 !clear force field code !search topology for this angle do b = 1 , nangles if ( ang ( b )% j == j . and . & (( ang ( b )% i == i . and . ang ( b )% k == k ) . or . & ( ang ( b )% i == k . and . ang ( b )% k == i ))) then geom ( Nmeas )% cod = ang ( b )% cod exit end if end do angle_add = Nmeas if ( geom ( Nmeas )% cod > 0 ) then write ( desc , 19 ) i , j , k 19 format ( 'angle, angle energy between atoms' , i5 , ',' , i5 , ',' , i5 ) else write ( desc , 20 ) i , j , k 20 format ( 'angle between atoms' , i5 , ',' , i5 , ',' , i5 ) end if end function angle_add integer function torsion_add ( desc ) !arguments character ( * ) :: desc !locals character ( len = 80 ) :: line integer :: readstat integer :: i , j , k , l integer :: b if ( Nmeas == MAX_MEASUREMENTS ) then write ( * , 10 ) MAX_MEASUREMENTS return end if 10 format ( 'Sorry, the maximum number of geometry calculations is ' , i2 ) !add a new dist measurement Nmeas = Nmeas + 1 write ( * , '(a)' , advance = 'no' ) 'torsion: Enter the four atom numbers: ' read ( * , '(a)' , iostat = readstat ) line read ( line , * , iostat = readstat ) i , j , k , l if ( readstat /= 0 . or . i < 1 . or . i > nat_pro . or . & j < 1 . or . j > nat_pro . or . & k < 1 . or . k > nat_pro . or . & l < 1 . or . l > nat_pro . or . & i == j . or . i == k . or . i == l . or . j == k . or . & j == l . or . k == l ) then write ( * , 900 ) 900 format ( '>>>>> ERROR: Invalid atom number(s).' ) Nmeas = Nmeas - 1 torsion_add = 0 return end if geom ( Nmeas )% i = i geom ( Nmeas )% j = j geom ( Nmeas )% k = k geom ( Nmeas )% l = l geom ( Nmeas )% cod = 0 !clear force field code !search topology for this angle do b = 1 , ntors if (( tor ( b )% i == i . and . tor ( b )% j == j . and . & tor ( b )% k == k . and . tor ( b )% l == l ) . or . & ( tor ( b )% i == l . and . tor ( b )% j == k . and . & tor ( b )% k == j . and . tor ( b )% l == i )) then geom ( Nmeas )% cod = tor ( b )% cod exit end if end do torsion_add = Nmeas if ( geom ( Nmeas )% cod > 0 ) then write ( desc , 19 ) i , j , k , l 19 format ( 'torsion, torsion energy between atoms' , i5 , ',' , i5 , ',' , i5 , ',' , i5 ) else write ( desc , 20 ) i , j , k , l 20 format ( 'torsion between atoms' , i5 , ',' , i5 , ',' , i5 , ',' , i5 ) end if end function torsion_add subroutine dist_calc ( i ) !arguments integer , intent ( in ) :: i !locals real ( 8 ) :: rji ( 3 ) real ( 8 ) :: r2 , r , V if ( i < 1 . or . i > Nmeas ) return rji (:) = xin ( 3 * geom ( i )% i - 2 : 3 * geom ( i )% i ) - xin ( 3 * geom ( i )% j - 2 : 3 * geom ( i )% j ) r2 = dot_product ( rji , rji ) r = sqrt ( r2 ) write ( * , 100 , advance = 'no' ) r 100 format ( f10 . 2 ) if ( geom ( i )% cod > 0 ) then !calc energy V = 0.5 * bondlib ( geom ( i )% cod )% fk * ( r - bondlib ( geom ( i )% cod )% bnd0 ) ** 2 write ( * , 110 , advance = 'no' ) V end if 110 format ( f8 . 2 ) end subroutine dist_calc subroutine angle_calc ( i ) !arguments integer , intent ( in ) :: i !locals real ( 8 ) :: rji ( 3 ), rjk ( 3 ), scp real ( 8 ) :: a , V if ( i < 1 . or . i > Nmeas ) return rji (:) = xin ( 3 * geom ( i )% i - 2 : 3 * geom ( i )% i ) - xin ( 3 * geom ( i )% j - 2 : 3 * geom ( i )% j ) rjk (:) = xin ( 3 * geom ( i )% k - 2 : 3 * geom ( i )% k ) - xin ( 3 * geom ( i )% j - 2 : 3 * geom ( i )% j ) scp = dot_product ( rji , rjk ) & / sqrt ( dot_product ( rji , rji ) * dot_product ( rjk , rjk )) IF ( scp > 1. ) scp = 1. IF ( scp < - 1. ) scp = - 1. a = acos ( scp ) write ( * , 100 , advance = 'no' ) a * 180 / pi 100 format ( f11 . 2 ) if ( geom ( i )% cod > 0 ) then !calc energy V = 0.5 * anglib ( geom ( i )% cod )% fk & * ( a - anglib ( geom ( i )% cod )% ang0 * pi / 18 0. ) ** 2 write ( * , 110 , advance = 'no' ) V end if 110 format ( f8 . 2 ) end subroutine angle_calc subroutine torsion_calc ( i ) !arguments integer , intent ( in ) :: i !locals real ( 8 ) :: rji ( 3 ), rjk ( 3 ), rkl ( 3 ), rnj ( 3 ), rnk ( 3 ), scp real ( 8 ) :: phi , sgn , arg , V integer :: ic if ( i < 1 . or . i > Nmeas ) return rji (:) = xin ( 3 * geom ( i )% i - 2 : 3 * geom ( i )% i ) - xin ( 3 * geom ( i )% j - 2 : 3 * geom ( i )% j ) rjk (:) = xin ( 3 * geom ( i )% k - 2 : 3 * geom ( i )% k ) - xin ( 3 * geom ( i )% j - 2 : 3 * geom ( i )% j ) rkl (:) = xin ( 3 * geom ( i )% l - 2 : 3 * geom ( i )% l ) - xin ( 3 * geom ( i )% k - 2 : 3 * geom ( i )% k ) !cross products rnj ( 1 ) = rji ( 2 ) * rjk ( 3 ) - rji ( 3 ) * rjk ( 2 ) rnj ( 2 ) = rji ( 3 ) * rjk ( 1 ) - rji ( 1 ) * rjk ( 3 ) rnj ( 3 ) = rji ( 1 ) * rjk ( 2 ) - rji ( 2 ) * rjk ( 1 ) rnk ( 1 ) = - rjk ( 2 ) * rkl ( 3 ) + rjk ( 3 ) * rkl ( 2 ) rnk ( 2 ) = - rjk ( 3 ) * rkl ( 1 ) + rjk ( 1 ) * rkl ( 3 ) rnk ( 3 ) = - rjk ( 1 ) * rkl ( 2 ) + rjk ( 2 ) * rkl ( 1 ) scp = dot_product ( rnj , rnk ) & / sqrt ( dot_product ( rnj , rnj ) * dot_product ( rnk , rnk )) IF ( scp > 1.0 ) scp = 1.0 IF ( scp < - 1.0 ) scp = - 1.0 phi = acos ( scp ) sgn = rjk ( 1 ) * ( rnj ( 2 ) * rnk ( 3 ) - rnj ( 3 ) * rnk ( 2 ) ) + rjk ( 2 )& * ( rnj ( 3 ) * rnk ( 1 ) - rnj ( 1 ) * rnk ( 3 ) ) + rjk ( 3 ) * ( rnj ( 1 ) & * rnk ( 2 ) - rnj ( 2 ) * rnk ( 1 ) ) IF ( sgn < 0 ) phi = - phi write ( * , 100 , advance = 'no' ) phi * 180 / pi 100 format ( f10 . 2 ) ic = geom ( i )% cod if ( ic > 0 ) then !calc energy arg = torlib ( ic )% rmult * phi - torlib ( ic )% deltor * pi / 18 0. V = torlib ( ic )% fk * ( 1.0 + cos ( arg ) ) / real ( torlib ( ic )% paths ) write ( * , 110 , advance = 'no' ) V end if 110 format ( f8 . 2 ) end subroutine torsion_calc subroutine dist_heading ( i ) integer :: i write ( * , '(a)' , advance = 'no' ) 'dist(�)' if ( geom ( i )% cod > 0 ) then write ( * , '(a8)' , advance = 'no' ) 'V_bond' end if end subroutine dist_heading subroutine angle_heading ( i ) integer :: i write ( * , '(a)' , advance = 'no' ) 'angle(�)' if ( geom ( i )% cod > 0 ) then write ( * , '(a8)' , advance = 'no' ) 'V_angle' end if end subroutine angle_heading subroutine torsion_heading ( i ) integer :: i write ( * , '(a)' , advance = 'no' ) 'tors(�)' if ( geom ( i )% cod > 0 ) then write ( * , '(a8)' , advance = 'no' ) 'V_tors' end if end subroutine torsion_heading end module calc_geom","tags":"","loc":"sourcefile/calc_geom.f90.html","title":"calc_geom.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2003 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  calc_nb.f90 !  by Martin Alml�f & Martin Nervall !  nonbonded potential calculation & !  calculation of nb interactions between 'q-atoms' and !  protein residues !------------------------------------------------------------------------------! module CALC_NB use CALC_BASE use MASKMANIP use PARSE use ATOM_MASK implicit none !constants integer , parameter :: MAX_LISTS = 20 integer , parameter :: MAX_NB_QP = 1 !module variables type ( MASK_TYPE ), private , target :: masks ( 2 ) integer , private :: Nlists = 0 integer , private :: N_nb_qp = 0 type NB_LIST_TYPE integer :: number_of_NB integer , pointer :: atom1 (:), atom2 (:) real , pointer :: AA (:), BB (:), qq (:) end type NB_LIST_TYPE type ( NB_LIST_TYPE ), private , allocatable :: nb_listan (:) type ( NB_LIST_TYPE ), private , allocatable :: nb_list_res (:) type AVERAGES real :: lj , el end type AVERAGES type ( AVERAGES ), allocatable :: aves (:) type ( AVERAGES ), allocatable :: qp_aves (:) integer , allocatable :: total_frames (:) integer :: total_qp_frames = 0 type NB_QP_TYPE integer :: p_first , p_last , q_first , q_last end type NB_QP_TYPE type ( NB_QP_TYPE ), private :: qp_calc contains !******************************************************************* subroutine nb_initialize allocate ( nb_listan ( MAX_LISTS ), total_frames ( MAX_LISTS ), aves ( MAX_LISTS )) aves (:)% lj = 0 aves (:)% el = 0 total_frames (:) = 0 end subroutine nb_initialize !******************************************************************* subroutine nb_finalize ( i ) integer :: i !       Print averages of all trajectories write ( * , 669 ) i , aves ( i )% lj write ( * , 670 ) i , aves ( i )% el 669 format ( 'Average NB_lj energies of NB_calc ' , i2 , ' : ' , f9 . 2 ) 670 format ( 'Average NB_el energies of NB_calc ' , i2 , ' : ' , f9 . 2 ) end subroutine nb_finalize !******************************************************************* integer function nb_add ( desc ) !arguments character ( * ) :: desc integer :: ats1 integer :: ats2 if ( Nlists == MAX_LISTS ) then write ( * , 10 ) MAX_LISTS / 2 nb_add = 0 return end if 10 format ( 'Sorry, the maximum number of nonbond calculations is ' , i2 ) write ( * , 52 ) 52 format ( 'N.B. the calculated nonbonded energies are for the trajectory coordinates using topology parameters.' ) write ( * , 53 ) 53 format ( 'i.e. lambda is not taken into account.' ) !make mask for first set of atoms write ( * , 11 ) 11 format ( 'Enter mask for first group of atoms' ) call mask_initialize ( masks ( 1 )) ats1 = maskmanip_make ( masks ( 1 )) if ( ats1 == 0 ) then call mask_finalize ( masks ( 1 )) nb_add = 0 return end if write ( * , 13 ) masks ( 1 )% included 13 format ( 'First mask contains ' , i6 , ' atoms' ) write ( * , 14 ) 14 format ( 'Enter mask for second group of atoms' ) !make mask for second set of atoms call mask_initialize ( masks ( 2 )) ats2 = maskmanip_make ( masks ( 2 )) !discard if no atoms in mask if ( ats2 == 0 ) then call mask_finalize ( masks ( 1 )) call mask_finalize ( masks ( 2 )) nb_add = 0 return end if write ( * , 16 ) masks ( 2 )% included 16 format ( 'Second mask contains ' , i6 , ' atoms' ) Nlists = Nlists + 1 allocate ( nb_listan ( Nlists )% atom1 ( ats1 * ats2 )) allocate ( nb_listan ( Nlists )% atom2 ( ats1 * ats2 )) allocate ( nb_listan ( Nlists )% AA ( ats1 * ats2 )) allocate ( nb_listan ( Nlists )% BB ( ats1 * ats2 )) allocate ( nb_listan ( Nlists )% qq ( ats1 * ats2 )) call nb_make_list ( masks ( 1 ), masks ( 2 ), nb_listan ( Nlists )) nb_add = Nlists write ( desc , 20 ) nb_listan ( Nlists )% number_of_NB 20 format ( 'Nonbonded list contains ' , i6 , ' pairs' ) end function nb_add !******************************************************************* !* Invoked from Qcalc to calculate nonbonded interactions !*  between two masks defined by user. !******************************************************************* subroutine nb_calc ( i ) integer :: i real ( 8 ) :: NB_Vlj , NB_Vel call nb_calc_lists ( NB_Vlj , NB_Vel , nb_listan ( i )) write ( * , 99 , advance = 'no' ) NB_Vlj write ( * , 100 , advance = 'no' ) NB_Vel 99 format ( f9 . 2 ) 100 format ( f8 . 2 ) !       Make averages. To be printed after all trajectory files are processed aves ( i )% lj = ( aves ( i )% lj * total_frames ( i ) + NB_Vlj ) / ( total_frames ( i ) + 1 ) aves ( i )% el = ( aves ( i )% el * total_frames ( i ) + NB_Vel ) / ( total_frames ( i ) + 1 ) total_frames ( i ) = total_frames ( i ) + 1 end subroutine nb_calc !******************************************************************* subroutine nb_calc_lists ( NB_Vlj , NB_Vel , nb_list ) !arguments real ( 8 ), intent ( out ) :: NB_Vlj , NB_Vel type ( NB_LIST_TYPE ), intent ( in ) :: nb_list !locals real ( 8 ) :: r , x1 , x2 , y1 , y2 , z1 , z2 , invr , invr6 , invr12 integer :: j , k , storleken NB_Vlj = 0 NB_Vel = 0 storleken = nb_list % number_of_NB do j = 1 , storleken x1 = xin ( 3 * nb_list % atom1 ( j ) - 2 ) x2 = xin ( 3 * nb_list % atom2 ( j ) - 2 ) y1 = xin ( 3 * nb_list % atom1 ( j ) - 1 ) y2 = xin ( 3 * nb_list % atom2 ( j ) - 1 ) z1 = xin ( 3 * nb_list % atom1 ( j )) z2 = xin ( 3 * nb_list % atom2 ( j )) r = sqrt (( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 + ( z1 - z2 ) ** 2 ) if ( r /= 0 ) then invr = 1 / r invr6 = invr * invr * invr * invr * invr * invr invr12 = invr6 * invr6 if ( ivdw_rule == 1 ) then !geometric comb. rule NB_Vlj = NB_Vlj + nb_list % AA ( j ) * invr12 - nb_list % BB ( j ) * invr6 else !arithmetic NB_Vlj = NB_Vlj + sqrt ( nb_list % BB ( j )) * ( nb_list % AA ( j )) ** 6 * invr6 * (( nb_list % AA ( j )) ** 6 * invr6 - 2.0 ) endif NB_Vel = NB_Vel + nb_list % qq ( j ) * invr end if end do end subroutine nb_calc_lists !******************************************************************* ! Make pair lists of interacting atoms in mask1 and mask2 !******************************************************************* subroutine nb_make_list ( mask1 , mask2 , nb_list ) integer :: j , k , l , m , nat1 , nat2 , LJ_code , nl , qq_pair , atomj , atomk , b integer :: size_groupm integer , allocatable :: group1 (:), group2 (:) integer :: ljcod ( 255 , 255 ), groupm ( nat_pro ) logical :: NB type ( MASK_TYPE ), intent ( in ) :: mask1 , mask2 type ( NB_LIST_TYPE ) :: nb_list !       type(NB_LIST_TYPE), private     ::  temp_list l = 1 m = 1 !make the list of atoms in first mask nat1 = mask1 % included allocate ( group1 ( nat1 )) do j = 1 , nat_pro if ( mask1 % MASK ( j )) then group1 ( l ) = j l = l + 1 end if end do !make the list of atoms in second mask nat2 = mask2 % included allocate ( group2 ( nat2 )) do j = 1 , nat_pro if ( mask2 % MASK ( j )) then group2 ( m ) = j m = m + 1 end if end do !make list of mutual atoms b = 0 do j = 1 , l - 1 do k = 1 , m - 1 if ( group1 ( j ) == group2 ( k )) then b = b + 1 groupm ( b ) = group1 ( j ) exit end if end do end do size_groupm = b ljcod (:,:) = 1 do m = 1 , nlj2 ljcod ( lj2 ( m )% i , lj2 ( m )% j ) = 2 ljcod ( lj2 ( m )% j , lj2 ( m )% i ) = 2 end do m = 1 do j = 1 , nat1 do k = 1 , nat2 atomj = group1 ( j ) atomk = group2 ( k ) NB = . true . !check if we're adding a pair which has already been added if ( atomj . ge . atomk ) then do l = 1 , size_groupm !cycle through list of mutual atoms if ( atomk == groupm ( l )) then NB = . false . exit end if end do end if !check if the atoms are in a mutual angle !if so, they're 1-2 or 1-3 neighbors and no NB terms should be calculated !code from calc_geom.f90 if ( NB ) then do b = 1 , nangles if ( ( ang ( b )% i == atomj . and . & ( ang ( b )% j == atomk . or . ang ( b )% k == atomk )) . or . & ( ang ( b )% j == atomj . and . & ( ang ( b )% i == atomk . or . ang ( b )% k == atomk )) . or . & ( ang ( b )% k == atomj . and . & ( ang ( b )% i == atomk . or . ang ( b )% j == atomk ))) then NB = . false . exit end if end do end if !some LJ_CODE code taken from md.f90::nbmonitorlist !starting guess = use LJ_code matrix for topology atom types if ( NB ) then nb_list % atom1 ( m ) = atomj nb_list % atom2 ( m ) = atomk LJ_code = ljcod ( iac ( atomj ), iac ( atomk )) !iac is from topo.f90 \"integer atom code\" !Are atoms of pair in 1-4 position? !                                       if(iqatom(atomj) == 0 .and. iqatom(atomk) == 0) then !neither atom is q_atom if ( abs ( atomk - atomj ) . le . max_nbr_range ) then if ( atomj . gt . atomk ) then if ( list14 ( atomj - atomk , atomk ) ) LJ_code = 3 !3 means 1-4 !list14 contains 1-4 neighbors !within 25 atom#s of eachother !n14long contains 1-4neighbors !which are \"further\" than 25 !atom#s else if ( list14 ( atomk - atomj , atomj ) ) LJ_code = 3 end if else do nl = 1 , n14long if (( list14long ( 1 , nl ) . eq . atomj & . and . list14long ( 2 , nl ) . eq . atomk ) . or . & ( list14long ( 1 , nl ) . eq . atomk & . and . list14long ( 2 , nl ) . eq . atomj )) then LJ_code = 3 endif end do endif !kolla 1-4 interaktioner if ( ivdw_rule == 1 ) then !geometric comb. rule !iaclib() from topo.f90, contains atom parameters. !argument is \"integer atom code\" nb_list % AA ( m ) = iaclib ( iac ( atomj ))% avdw ( LJ_code ) * iaclib ( iac ( atomk ))% avdw ( LJ_code ) else !arithmetic nb_list % AA ( m ) = iaclib ( iac ( atomj ))% avdw ( LJ_code ) + iaclib ( iac ( atomk ))% avdw ( LJ_code ) endif nb_list % BB ( m ) = iaclib ( iac ( atomj ))% bvdw ( LJ_code ) * iaclib ( iac ( atomk ))% bvdw ( LJ_code ) if ( LJ_code == 3 ) then nb_list % qq ( m ) = crg ( atomj ) * crg ( atomk ) * coulomb_constant * el14_scale !coulombconstant from topo.f90 else nb_list % qq ( m ) = crg ( atomj ) * crg ( atomk ) * coulomb_constant !el14_scale from topo.f90 end if m = m + 1 !increase index else ! endif end do end do nb_list % number_of_NB = m - 1 end subroutine nb_make_list !******************************************************************* subroutine nb_heading ( i ) integer :: i write ( * , '(a6)' , advance = 'no' ) 'Vlj' write ( * , '(a8)' , advance = 'no' ) 'Vel' end subroutine nb_heading !******************************************************************* !* Add new calculation of nonbonded interactions between !*  two sets of residues, e.g. protein aa and q-atoms. The !*  interactions will be calculated for for the first group !*  one at the time against all residues in the second group. !******************************************************************* integer function nb_qp_add ( desc ) !arguments character ( * ) :: desc character ( len = 200 ) :: line integer :: ires , ats1 , ats2 nb_qp_add = - 1 if ( N_nb_qp . ge . MAX_NB_QP ) then write ( * , 10 ) MAX_NB_QP return end if 10 format ( 'Sorry, the maximum number of residue nonbond calculations is ' , i2 ) Nlists = nres allocate ( qp_aves ( nres ), nb_list_res ( nres )) qp_aves (:)% lj = 0. qp_aves (:)% el = 0. call mask_initialize ( masks ( 1 )) call mask_initialize ( masks ( 2 )) write ( * , * ) '' qp_calc % p_first = get_int_arg ( \"Enter first residue of protein:\" ) write ( * , * ) '' write ( * , * ) 'First residue of protein:   ' , qp_calc % p_first qp_calc % p_last = get_int_arg ( \"Enter last residue of protein:\" ) write ( * , * ) '' write ( * , * ) 'Last residue of protein:   ' , qp_calc % p_last write ( * , * ) 'Enter mask for q-atoms (e.g. <residue  xx yy>.)' write ( * , * ) 'Finalize with end.' ats2 = maskmanip_make ( masks ( 2 )) if ( ats2 == 0 ) then call mask_finalize ( masks ( 2 )) return end if write ( * , 13 ) masks ( 2 )% included 13 format ( 'Q-atom mask contains ' , i6 , ' atoms' ) do ires = qp_calc % p_first , qp_calc % p_last call mask_clear ( masks ( 1 )) write ( line , '(a,i6,i6)' ) 'residue ' , ires , ires ats1 = mask_add ( masks ( 1 ), line ) allocate ( nb_list_res ( ires )% atom1 ( ats1 * ats2 )) allocate ( nb_list_res ( ires )% atom2 ( ats1 * ats2 )) allocate ( nb_list_res ( ires )% AA ( ats1 * ats2 )) allocate ( nb_list_res ( ires )% BB ( ats1 * ats2 )) allocate ( nb_list_res ( ires )% qq ( ats1 * ats2 )) call nb_make_list ( masks ( 1 ), masks ( 2 ), nb_list_res ( ires )) end do call mask_finalize ( masks ( 1 )) call mask_finalize ( masks ( 2 )) nb_qp_add = 1 end function nb_qp_add !******************************************************************* !* Step through one residue at the time and calculate nonbonded !* interactions with all q-atoms. !******************************************************************* subroutine nb_qp_calc () !arguments integer :: ires , count , i real ( 8 ) :: vdw , el total_qp_frames = total_qp_frames + 1 do ires = qp_calc % p_first , qp_calc % p_last call nb_calc_lists ( vdw , el , nb_list_res ( ires )) qp_aves ( ires )% lj = ( qp_aves ( ires )% lj * ( total_qp_frames - 1 ) + vdw ) / ( total_qp_frames ) qp_aves ( ires )% el = ( qp_aves ( ires )% el * ( total_qp_frames - 1 ) + el ) / ( total_qp_frames ) end do end subroutine nb_qp_calc !******************************************************************* !* Print final averages and clean up. !******************************************************************* subroutine nb_qp_finalize () integer :: ires !Print header write ( * , 701 ) qp_calc % q_first , qp_calc % q_last write ( * , 702 ) 'Residue' , 'Average LJ' , 'Average el' 701 format ( 'Average nonbonded interaction between residues' , i4 , ' to ' , i4 , ' and other residues:' ) 702 format ( a15 , a15 , a15 ) !       Print averages of all trajectories do ires = qp_calc % p_first , qp_calc % p_last write ( * , 703 ) ires , qp_aves ( ires )% lj , qp_aves ( ires )% el end do 703 format ( i15 , f15 . 2 , f15 . 2 ) deallocate ( qp_aves , nb_list_res ) end subroutine nb_qp_finalize !******************************************************************* end module CALC_NB","tags":"","loc":"sourcefile/calc_nb.f90.html","title":"calc_nb.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2003 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  calc_nb.f90 !  by Martin Almlof & Martin Nervall !  nonbonded potential calculation & !  calculation of nb interactions between 'q-atoms' and !  protein residues !------------------------------------------------------------------------------! module CALC_NB use CALC_BASE use MASKMANIP use PARSE use ATOM_MASK implicit none !constants integer , parameter :: MAX_LISTS = 20 integer , parameter :: MAX_NB_QP = 1 !module variables type ( MASK_TYPE ), private , target :: masks ( 2 ) integer , private :: Nlists = 0 integer , private :: N_nb_qp = 0 type NB_LIST_TYPE integer :: number_of_NB integer , pointer :: atom1 (:), atom2 (:) real , pointer :: AA (:), BB (:), qq (:) end type NB_LIST_TYPE type ( NB_LIST_TYPE ), private , allocatable :: nb_listan (:) type ( NB_LIST_TYPE ), private , allocatable :: nb_list_res (:) type AVERAGES real :: lj , el end type AVERAGES type ( AVERAGES ), allocatable :: aves (:) type ( AVERAGES ), allocatable :: qp_aves (:) integer , allocatable :: total_frames (:) integer :: total_qp_frames = 0 type NB_QP_TYPE integer :: p_first , p_last , q_first , q_last end type NB_QP_TYPE type ( NB_QP_TYPE ), private :: qp_calc real :: center_mask1 ( 3 ), ave_Elj_r ( 10 , 100 ), Elj_r ( 100 ) contains !******************************************************************* subroutine nb_initialize allocate ( nb_listan ( MAX_LISTS ), total_frames ( MAX_LISTS ), aves ( MAX_LISTS )) aves (:)% lj = 0 aves (:)% el = 0 total_frames (:) = 0 end subroutine nb_initialize !******************************************************************* subroutine nb_finalize ( i ) integer :: i , j !       Print averages of all trajectories write ( * , 669 ) i , aves ( i )% lj write ( * , 670 ) i , aves ( i )% el 669 format ( 'Average NB_lj energies of NB_calc ' , i2 , ' : ' , f9 . 2 ) 670 format ( 'Average NB_el energies of NB_calc ' , i2 , ' : ' , f9 . 2 ) 671 format ( 'radius' , i2 , ' : ' , f9 . 2 ) do j = 1 , 40 write ( * , 671 ) j , ave_elj_r ( i , j ) end do end subroutine nb_finalize !******************************************************************* integer function nb_add ( desc ) !arguments character ( * ) :: desc integer :: ats1 integer :: ats2 if ( Nlists == MAX_LISTS ) then write ( * , 10 ) MAX_LISTS / 2 nb_add = 0 return end if 10 format ( 'Sorry, the maximum number of nonbond calculations is ' , i2 ) write ( * , 52 ) 52 format ( 'N.B. the calculated nonbonded energies are for the trajectory coordinates using topology parameters.' ) write ( * , 53 ) 53 format ( 'i.e. lambda is not taken into account.' ) !make mask for first set of atoms write ( * , 11 ) 11 format ( 'Enter mask for first group of atoms' ) call mask_initialize ( masks ( 1 )) ats1 = maskmanip_make ( masks ( 1 )) if ( ats1 == 0 ) then call mask_finalize ( masks ( 1 )) nb_add = 0 return end if write ( * , 13 ) masks ( 1 )% included 13 format ( 'First mask contains ' , i6 , ' atoms' ) write ( * , 14 ) 14 format ( 'Enter mask for second group of atoms' ) !make mask for second set of atoms call mask_initialize ( masks ( 2 )) ats2 = maskmanip_make ( masks ( 2 )) !discard if no atoms in mask if ( ats2 == 0 ) then call mask_finalize ( masks ( 1 )) call mask_finalize ( masks ( 2 )) nb_add = 0 return end if write ( * , 16 ) masks ( 2 )% included 16 format ( 'Second mask contains ' , i6 , ' atoms' ) Nlists = Nlists + 1 allocate ( nb_listan ( Nlists )% atom1 ( ats1 * ats2 )) allocate ( nb_listan ( Nlists )% atom2 ( ats1 * ats2 )) allocate ( nb_listan ( Nlists )% AA ( ats1 * ats2 )) allocate ( nb_listan ( Nlists )% BB ( ats1 * ats2 )) allocate ( nb_listan ( Nlists )% qq ( ats1 * ats2 )) call nb_make_list ( masks ( 1 ), masks ( 2 ), nb_listan ( Nlists )) nb_add = Nlists write ( desc , 20 ) nb_listan ( Nlists )% number_of_NB 20 format ( 'Nonbonded list contains ' , i6 , ' pairs' ) end function nb_add !***************************** !*********************** subroutine calc_center () integer , allocatable :: group1 (:) real :: sum_center_mask1 ( 3 ) integer :: nat1 , j , l nat1 = masks ( 1 )% included allocate ( group1 ( nat1 )) sum_center_mask1 (:) = 0.0 _ 8 l = 1 do j = 1 , nat_pro if ( masks ( 1 )% MASK ( j )) then group1 ( l ) = j l = l + 1 end if end do do j = 1 , nat1 sum_center_mask1 ( 1 ) = sum_center_mask1 ( 1 ) + xin ( 3 * group1 ( j ) - 2 ) sum_center_mask1 ( 2 ) = sum_center_mask1 ( 2 ) + xin ( 3 * group1 ( j ) - 1 ) sum_center_mask1 ( 3 ) = sum_center_mask1 ( 3 ) + xin ( 3 * group1 ( j )) end do center_mask1 (:) = sum_center_mask1 (:) / nat1 !               sum_center_mask1(2) += xin(3*group1(j)-1) !               sum_center_mask1(3) += xin(3*group1(j)) end subroutine calc_center !***************************** !*********************** integer function dist_group1 ( atom2 ) integer :: atom2 real :: x1 , x2 , y1 , y2 , z1 , z2 x1 = center_mask1 ( 1 ) x2 = xin ( 3 * atom2 - 2 ) y1 = center_mask1 ( 2 ) y2 = xin ( 3 * atom2 - 1 ) z1 = center_mask1 ( 3 ) z2 = xin ( 3 * atom2 ) dist_group1 = floor ( sqrt (( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 + ( z1 - z2 ) ** 2 )) end function dist_group1 !******************************************************************* !* Invoked from Qcalc to calculate nonbonded interactions !*  between two masks defined by user. !******************************************************************* subroutine nb_calc ( i ) integer :: i real ( 8 ) :: NB_Vlj , NB_Vel call nb_calc_lists ( NB_Vlj , NB_Vel , nb_listan ( i )) write ( * , 99 , advance = 'no' ) NB_Vlj write ( * , 100 , advance = 'no' ) NB_Vel 99 format ( f9 . 2 ) 100 format ( f8 . 2 ) !       Make averages. To be printed after all trajectory files are processed aves ( i )% lj = ( aves ( i )% lj * total_frames ( i ) + NB_Vlj ) / ( total_frames ( i ) + 1 ) aves ( i )% el = ( aves ( i )% el * total_frames ( i ) + NB_Vel ) / ( total_frames ( i ) + 1 ) ave_Elj_r ( i ,:) = ( ave_Elj_r ( i ,:) * total_frames ( i ) + Elj_r (:)) / ( total_frames ( i ) + 1 ) total_frames ( i ) = total_frames ( i ) + 1 end subroutine nb_calc !******************************************************************* subroutine nb_calc_lists ( NB_Vlj , NB_Vel , nb_list ) !arguments real ( 8 ), intent ( out ) :: NB_Vlj , NB_Vel type ( NB_LIST_TYPE ), intent ( in ) :: nb_list !locals real ( 8 ) :: r , x1 , x2 , y1 , y2 , z1 , z2 , invr , invr6 , invr12 integer :: j , k , storleken NB_Vlj = 0 NB_Vel = 0 storleken = nb_list % number_of_NB call calc_center () Elj_r (:) = 0 do j = 1 , storleken x1 = xin ( 3 * nb_list % atom1 ( j ) - 2 ) x2 = xin ( 3 * nb_list % atom2 ( j ) - 2 ) y1 = xin ( 3 * nb_list % atom1 ( j ) - 1 ) y2 = xin ( 3 * nb_list % atom2 ( j ) - 1 ) z1 = xin ( 3 * nb_list % atom1 ( j )) z2 = xin ( 3 * nb_list % atom2 ( j )) r = sqrt (( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 + ( z1 - z2 ) ** 2 ) if ( r /= 0 ) then invr = 1 / r invr6 = invr * invr * invr * invr * invr * invr invr12 = invr6 * invr6 if ( ivdw_rule == 1 ) then !geometric comb. rule Elj_r ( dist_group1 ( nb_list % atom2 ( j ))) = Elj_r ( dist_group1 ( nb_list % atom2 ( j ))) + & nb_list % AA ( j ) * invr12 - nb_list % BB ( j ) * invr6 NB_Vlj = NB_Vlj + nb_list % AA ( j ) * invr12 - nb_list % BB ( j ) * invr6 else !arithmetic Elj_r ( dist_group1 ( nb_list % atom2 ( j ))) = Elj_r ( dist_group1 ( nb_list % atom2 ( j ))) + & sqrt ( nb_list % BB ( j )) * ( nb_list % AA ( j )) ** 6 * invr6 * (( nb_list % AA ( j )) ** 6 * invr6 - & 2.0 ) NB_Vlj = NB_Vlj + sqrt ( nb_list % BB ( j )) * ( nb_list % AA ( j ) ** 6 * invr6 * & ( nb_list % AA ( j ) ** 6 * invr6 - 2.0 ) ) endif NB_Vel = NB_Vel + nb_list % qq ( j ) * invr end if end do end subroutine nb_calc_lists !******************************************************************* ! Make pair lists of interacting atoms in mask1 and mask2 !******************************************************************* subroutine nb_make_list ( mask1 , mask2 , nb_list ) integer :: j , k , l , m , nat1 , nat2 , LJ_code , nl , qq_pair , atomj , atomk , b integer :: size_groupm integer , allocatable :: group1 (:), group2 (:) integer :: ljcod ( 255 , 255 ), groupm ( nat_pro ) logical :: NB type ( MASK_TYPE ), intent ( in ) :: mask1 , mask2 type ( NB_LIST_TYPE ) :: nb_list !       type(NB_LIST_TYPE), private     ::  temp_list l = 1 m = 1 !make the list of atoms in first mask nat1 = mask1 % included allocate ( group1 ( nat1 )) do j = 1 , nat_pro if ( mask1 % MASK ( j )) then group1 ( l ) = j l = l + 1 end if end do !make the list of atoms in second mask nat2 = mask2 % included allocate ( group2 ( nat2 )) do j = 1 , nat_pro if ( mask2 % MASK ( j )) then group2 ( m ) = j m = m + 1 end if end do !make list of mutual atoms b = 1 do j = 1 , l - 1 do k = 1 , m - 1 if ( group1 ( j ) == group2 ( k )) then groupm ( b ) = group1 ( j ) b = b + 1 exit end if end do end do size_groupm = b ljcod (:,:) = 1 do m = 1 , nlj2 ljcod ( lj2 ( m )% i , lj2 ( m )% j ) = 2 ljcod ( lj2 ( m )% j , lj2 ( m )% i ) = 2 end do m = 1 do j = 1 , nat1 do k = 1 , nat2 atomj = group1 ( j ) atomk = group2 ( k ) NB = . true . !check if we're adding a pair which has already been added if ( atomj . ge . atomk ) then do l = 1 , size_groupm !cycle through list of mutual atoms if ( atomk == groupm ( l )) then NB = . false . exit end if end do end if !check if the atoms are in a mutual angle !if so, they're 1-2 or 1-3 neighbors and no NB terms should be calculated !code from calc_geom.f90 if ( NB ) then do b = 1 , nangles if ( ( ang ( b )% i == atomj . and . & ( ang ( b )% j == atomk . or . ang ( b )% k == atomk )) . or . & ( ang ( b )% j == atomj . and . & ( ang ( b )% i == atomk . or . ang ( b )% k == atomk )) . or . & ( ang ( b )% k == atomj . and . & ( ang ( b )% i == atomk . or . ang ( b )% j == atomk ))) then NB = . false . exit end if end do end if !some LJ_CODE code taken from md.f90::nbmonitorlist !starting guess = use LJ_code matrix for topology atom types if ( NB ) then nb_list % atom1 ( m ) = atomj nb_list % atom2 ( m ) = atomk LJ_code = ljcod ( iac ( atomj ), iac ( atomk )) !iac is from topo.f90 \"integer atom code\" !Are atoms of pair in 1-4 position? !                                       if(iqatom(atomj) == 0 .and. iqatom(atomk) == 0) then !neither atom is q_atom if ( abs ( atomk - atomj ) . le . max_nbr_range ) then if ( atomj . gt . atomk ) then if ( list14 ( atomj - atomk , atomk ) ) LJ_code = 3 !3 means 1-4 !list14 contains 1-4 neighbors !within 25 atom#s of eachother !n14long contains 1-4neighbors !which are \"further\" than 25 !atom#s else if ( list14 ( atomk - atomj , atomj ) ) LJ_code = 3 end if else do nl = 1 , n14long if (( list14long ( 1 , nl ) . eq . atomj & . and . list14long ( 2 , nl ) . eq . atomk ) . or . & ( list14long ( 1 , nl ) . eq . atomk & . and . list14long ( 2 , nl ) . eq . atomj )) then LJ_code = 3 endif end do endif !kolla 1-4 interaktioner if ( ivdw_rule == 1 ) then !geometric comb. rule !iaclib() from topo.f90, contains atom parameters. !argument is \"integer atom code\" nb_list % AA ( m ) = iaclib ( iac ( atomj ))% avdw ( LJ_code ) * iaclib ( iac ( atomk ))% avdw ( LJ_code ) else !arithmetic nb_list % AA ( m ) = iaclib ( iac ( atomj ))% avdw ( LJ_code ) + iaclib ( iac ( atomk ))% avdw ( LJ_code ) endif nb_list % BB ( m ) = iaclib ( iac ( atomj ))% bvdw ( LJ_code ) * iaclib ( iac ( atomk ))% bvdw ( LJ_code ) if ( LJ_code == 3 ) then nb_list % qq ( m ) = crg ( atomj ) * crg ( atomk ) * coulomb_constant * el14_scale !coulombconstant from topo.f90 else nb_list % qq ( m ) = crg ( atomj ) * crg ( atomk ) * coulomb_constant !el14_scale from topo.f90 end if m = m + 1 !increase index else ! endif end do end do nb_list % number_of_NB = m - 1 end subroutine nb_make_list !******************************************************************* subroutine nb_heading ( i ) integer :: i write ( * , '(a6)' , advance = 'no' ) 'Vlj' write ( * , '(a8)' , advance = 'no' ) 'Vel' end subroutine nb_heading !******************************************************************* !* Add new calculation of nonbonded interactions between !*  two sets of residues, e.g. protein aa and q-atoms. The !*  interactions will be calculated for for the first group !*  one at the time against all residues in the second group. !******************************************************************* integer function nb_qp_add ( desc ) !arguments character ( * ) :: desc character ( len = 200 ) :: line integer :: ires , ats1 , ats2 nb_qp_add = . false . if ( N_nb_qp . ge . MAX_NB_QP ) then write ( * , 10 ) MAX_NB_QP return end if 10 format ( 'Sorry, the maximum number of residue nonbond calculations is ' , i2 ) Nlists = nres allocate ( qp_aves ( nres ), nb_list_res ( nres )) call mask_initialize ( masks ( 1 )) call mask_initialize ( masks ( 2 )) write ( * , * ) '' qp_calc % p_first = get_int_arg ( \"Enter first residue of protein:\" ) write ( * , * ) '' write ( * , * ) 'First residue of protein:   ' , qp_calc % p_first qp_calc % p_last = get_int_arg ( \"Enter last residue of protein:\" ) write ( * , * ) '' write ( * , * ) 'Last residue of protein:   ' , qp_calc % p_last write ( * , * ) 'Enter mask for q-atoms (e.g. <residue  xx yy>.)' write ( * , * ) 'Finalize with end.' ats2 = maskmanip_make ( masks ( 2 )) if ( ats2 == 0 ) then call mask_finalize ( masks ( 2 )) return end if write ( * , 13 ) masks ( 2 )% included 13 format ( 'Q-atom mask contains ' , i6 , ' atoms' ) do ires = qp_calc % p_first , qp_calc % p_last call mask_clear ( masks ( 1 )) write ( line , '(a,i6,i6)' ) 'residue ' , ires , ires ats1 = mask_add ( masks ( 1 ), line ) allocate ( nb_list_res ( ires )% atom1 ( ats1 * ats2 )) allocate ( nb_list_res ( ires )% atom2 ( ats1 * ats2 )) allocate ( nb_list_res ( ires )% AA ( ats1 * ats2 )) allocate ( nb_list_res ( ires )% BB ( ats1 * ats2 )) allocate ( nb_list_res ( ires )% qq ( ats1 * ats2 )) call nb_make_list ( masks ( 1 ), masks ( 2 ), nb_list_res ( ires )) end do call mask_finalize ( masks ( 1 )) call mask_finalize ( masks ( 2 )) nb_qp_add = . true . end function nb_qp_add !******************************************************************* !* Step through one residue at the time and calculate nonbonded !* interactions with all q-atoms. !******************************************************************* subroutine nb_qp_calc () !arguments integer :: ires , count , i real ( 8 ) :: vdw , el total_qp_frames = total_qp_frames + 1 do ires = qp_calc % p_first , qp_calc % p_last call nb_calc_lists ( vdw , el , nb_list_res ( ires )) qp_aves ( ires )% lj = ( qp_aves ( ires )% lj * ( total_qp_frames - 1 ) + vdw ) / ( total_qp_frames ) qp_aves ( ires )% el = ( qp_aves ( ires )% el * ( total_qp_frames - 1 ) + el ) / ( total_qp_frames ) end do end subroutine nb_qp_calc !******************************************************************* !* Print final averages and clean up. !******************************************************************* subroutine nb_qp_finalize () integer :: ires !Print header write ( * , 701 ) qp_calc % q_first , qp_calc % q_last write ( * , 702 ) 'Residue' , 'Average LJ' , 'Average el' 701 format ( 'Average nonbonded interaction between residues' , i4 , ' to ' , i4 , ' and other residues:' ) 702 format ( a15 , a15 , a15 ) !       Print averages of all trajectories do ires = qp_calc % p_first , qp_calc % p_last write ( * , 703 ) ires , qp_aves ( ires )% lj , qp_aves ( ires )% el end do 703 format ( i15 , f15 . 2 , f15 . 2 ) deallocate ( qp_aves , nb_list_res ) end subroutine nb_qp_finalize !******************************************************************* end module CALC_NB","tags":"","loc":"sourcefile/calc_nb_radius.f90.html","title":"calc_nb_radius.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2006 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  calc_rdf.f90 !  by Martin Ander and Martin Almlof (multiple atoms in first mask and PBC) !  Calculates RDF for a center atom with respect to all atoms in !  target_mask, using Nbins bins from r=0 to r=rdf_radius !------------------------------------------------------------------------------! module CALC_RDF use CALC_BASE use MASKMANIP use PARSE implicit none ! constants integer , parameter :: MAX_MASKS = 10 ! module variables type ( MASK_TYPE ), private , target :: temp_masks ( 2 ) ! masks for making pair lists integer , private :: ats1 , ats2 , Nmasks = 0 ! # target masks type RDF_CALC_TYPE integer :: atoms_in_mask1 ! center atom idx integer :: frames = 0 ! # frames used integer :: Nbins ! Divide rdf_radius into Nbins bins real ( 8 ) :: rdf_radius ! Calculate RDF within this radius real ( 8 ), pointer :: bins (:) ! RDF bins end type RDF_CALC_TYPE type ( RDF_CALC_TYPE ), private , save :: rdf_calcs ( MAX_MASKS ) ! stores data for indivdual RDF calcs real ( 8 ) :: pi type RDF_LIST_TYPE integer :: number_of_pairs integer , pointer :: atom1 (:), atom2 (:) end type RDF_LIST_TYPE type ( RDF_LIST_TYPE ), private , allocatable :: rdf_listan (:) contains subroutine RDF_initialize allocate ( rdf_listan ( MAX_MASKS )) end subroutine RDF_initialize subroutine RDF_finalize ( i ) ! arguments integer :: i ! calculation # ! locals integer :: j ! atom index real ( 8 ) :: volume ! shell volume ! write output header 1 write ( * , 3 ) i 3 format ( 'Results from RDF calulation' , i3 , ', normalized with respect to shell volume and frame count' ) ! write output header 2 write ( * , 4 ) 4 format ( '    Bin  r_max    RDF' ) pi = 4. * atan ( 1. ) ! pi = 3.1416..... ! normalize the contents of each bin with respect to shell ! volume and # processed frames and print the results do j = 1 , rdf_calcs ( i )% Nbins volume = 4 * pi / 3 * (( j * rdf_calcs ( i )% rdf_radius / & rdf_calcs ( i )% Nbins ) ** 3 - (( j - 1 ) * rdf_calcs ( i )% rdf_radius / rdf_calcs ( i )% Nbins ) ** 3 ) rdf_calcs ( i )% bins ( j ) = rdf_calcs ( i )% bins ( j ) / volume / & rdf_calcs ( i )% frames / rdf_calcs ( i )% atoms_in_mask1 write ( * , 5 ) j , j * rdf_calcs ( i )% rdf_radius / rdf_calcs ( i )% Nbins , rdf_calcs ( i )% bins ( j ) end do 5 format ( i7 , f10 . 6 , f10 . 6 ) ! finalize and deallocate deallocate ( rdf_calcs ( i )% bins ) ! deallocate bins deallocate ( rdf_listan ( i )% atom1 ) deallocate ( rdf_listan ( i )% atom2 ) end subroutine RDF_finalize !********************************************************* ! Qcalc calls this function to set up one RDF calculation, ! which is then added to the list of calculations in Qcalc !********************************************************* integer function RDF_add ( desc ) ! arguments character ( * ) :: desc ! locals integer :: ats ! check the # of calculations if ( Nmasks == MAX_MASKS ) then write ( * , 10 ) MAX_MASKS return end if 10 format ( 'Sorry, the maximum number of RDF calculations is ' , i2 ) ! start adding new calculation Nmasks = Nmasks + 1 ! set current calculation write ( * , 1011 ) 1011 format ( 'Enter mask for first atom set in RDF calculation' ) call mask_initialize ( temp_masks ( 1 )) ats1 = maskmanip_make ( temp_masks ( 1 )) if ( ats1 == 0 ) then call mask_finalize ( temp_masks ( 1 )) RDF_add = 0 return end if write ( * , 1012 ) 1012 format ( 'Enter mask for second atom set in RDF calculation' ) call mask_initialize ( temp_masks ( 2 )) ats2 = maskmanip_make ( temp_masks ( 2 )) if ( ats2 == 0 ) then call mask_finalize ( temp_masks ( 1 )) call mask_finalize ( temp_masks ( 2 )) RDF_add = 0 return end if !create rdf_listan allocate ( rdf_listan ( Nmasks )% atom1 ( ats1 * ats2 )) allocate ( rdf_listan ( Nmasks )% atom2 ( ats1 * ats2 )) !rdf_make_list returns number of pairs rdf_listan ( Nmasks )% number_of_pairs = rdf_make_list ( temp_masks ( 1 ), temp_masks ( 2 ), rdf_listan ( Nmasks )) call mask_finalize ( temp_masks ( 1 )) call mask_finalize ( temp_masks ( 2 )) ! set the parameters for this calculation rdf_calcs ( Nmasks )% atoms_in_mask1 = ats1 rdf_calcs ( Nmasks )% rdf_radius = get_real_arg ( 'RDF radius      :' ) ! get RDF radius rdf_calcs ( Nmasks )% Nbins = get_int_arg ( 'Number of bins  :' ) ! get # bins allocate ( rdf_calcs ( Nmasks )% bins ( rdf_calcs ( Nmasks )% Nbins )) ! allocate bins rdf_calcs ( Nmasks )% bins (:) = 0 ! set bins(:) = 0 RDF_add = Nmasks write ( desc , 25 ) ats1 25 format ( 'RDF calculation for ' , i6 , ' atoms' ) end function RDF_add !***************************************************************** ! Calculates RDF data from the current trajectory frame !***************************************************************** subroutine RDF_calc ( i ) !arguments integer , intent ( in ) :: i !locals integer :: j ! atom index integer :: binidx ! bin index real :: dist ! distance !       do j = 1, nat_pro !               if(target_masks(i)%mask(j))     then                                    ! if atom j in this target_mask !                       dist = r(rdf_calcs(i)%center, j)                                ! calculate distance between center atom and atom j !                       if(dist < rdf_calcs(i)%rdf_radius) then                 ! if atom j is within rdf_radius of center atom !                               binidx = dist / rdf_calcs(i)%rdf_radius * rdf_calcs(i)%Nbins + 1 !                               rdf_calcs(i)%bins(binidx) = rdf_calcs(i)%bins(binidx) + 1 !                       end if !               end if !       end do do j = 1 , rdf_listan ( i )% number_of_pairs dist = r ( rdf_listan ( i )% atom1 ( j ), rdf_listan ( i )% atom2 ( j )) if ( dist < rdf_calcs ( i )% rdf_radius ) then binidx = dist / rdf_calcs ( i )% rdf_radius * rdf_calcs ( i )% Nbins + 1 rdf_calcs ( i )% bins ( binidx ) = rdf_calcs ( i )% bins ( binidx ) + 1 end if end do rdf_calcs ( i )% frames = rdf_calcs ( i )% frames + 1 ! update # processed frames write ( * , 100 , advance = 'no' ) rdf_calcs ( i )% atoms_in_mask1 100 format ( i10 ) end subroutine RDF_calc subroutine RDF_heading ( i ) integer :: i write ( * , '(a)' , advance = 'no' ) 'RDF ats' end subroutine RDF_heading !***************************************************** ! r(a,b) calculates the distance between atoms a and b !***************************************************** real function r ( a , b ) ! arguments integer :: a , b !atom indices ! locals real , dimension ( 3 ) :: delta delta = xin ( 3 * a - 2 : 3 * a ) - xin ( 3 * b - 2 : 3 * b ) ! if PBC then adjust lengths according to periodicity - MA if ( use_PBC ) then delta ( 1 ) = delta ( 1 ) - boxlength ( 1 ) * nint ( delta ( 1 ) / boxlength ( 1 ) ) delta ( 2 ) = delta ( 2 ) - boxlength ( 2 ) * nint ( delta ( 2 ) / boxlength ( 2 ) ) delta ( 3 ) = delta ( 3 ) - boxlength ( 3 ) * nint ( delta ( 3 ) / boxlength ( 3 ) ) end if r = sqrt ( dot_product ( delta , delta )) end function r !***************************************************** ! rdf_make_list makes a list of all atom atom pairs in the masks and return the number of pairs !***************************************************** integer function rdf_make_list ( mask1 , mask2 , rdf_list ) integer :: i , j , k , l , m , nat1 , nat2 integer , allocatable :: group1 (:), group2 (:) type ( MASK_TYPE ), intent ( in ) :: mask1 , mask2 type ( RDF_LIST_TYPE ) :: rdf_list l = 1 m = 1 !make the list of atoms in first mask nat1 = mask1 % included allocate ( group1 ( nat1 )) do j = 1 , nat_pro if ( mask1 % MASK ( j )) then group1 ( l ) = j l = l + 1 end if end do !make the list of atoms in second mask nat2 = mask2 % included allocate ( group2 ( nat2 )) do j = 1 , nat_pro if ( mask2 % MASK ( j )) then group2 ( m ) = j m = m + 1 end if end do i = 1 do j = 1 , nat1 do k = 1 , nat2 if ( group1 ( j ) . ne . group2 ( k )) then rdf_list % atom1 ( i ) = group1 ( j ) rdf_list % atom2 ( i ) = group2 ( k ) i = i + 1 end if end do end do rdf_make_list = i - 1 !set the return value end function rdf_make_list end module CALC_RDF","tags":"","loc":"sourcefile/calc_rdf.f90.html","title":"calc_rdf.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  calc_rms.f90 !  by John Marelius !  root mean square coordinate deviation !------------------------------------------------------------------------------! module CALC_RMS use CALC_BASE use MASKMANIP implicit none !constants integer , parameter :: MAX_MASKS = 10 !module variables type ( MASK_TYPE ), private , target :: masks ( MAX_MASKS ) integer , private :: Nmasks = 0 type RMS_COORD_TYPE real , pointer :: x (:), x0 (:) end type RMS_COORD_TYPE type ( RMS_COORD_TYPE ), private :: coords ( MAX_MASKS ) contains subroutine RMS_initialize end subroutine RMS_initialize subroutine RMS_finalize ( i ) integer :: i call mask_finalize ( masks ( i )) end subroutine RMS_finalize integer function RMS_add ( desc ) !arguments character ( * ) :: desc integer :: ats if ( Nmasks == MAX_MASKS ) then write ( * , 10 ) MAX_MASKS return end if 10 format ( 'Sorry, the maximum number of RMS calculations is ' , i2 ) !add a new RMS mask Nmasks = Nmasks + 1 call mask_initialize ( masks ( Nmasks )) ats = maskmanip_make ( masks ( Nmasks )) !discard if no atoms in mask if ( ats == 0 ) then call mask_finalize ( masks ( Nmasks )) Nmasks = Nmasks - 1 RMS_add = 0 return end if allocate ( coords ( Nmasks )% x ( 3 * ats ), coords ( Nmasks )% x0 ( 3 * ats )) call RMS_make_ref ( Nmasks ) RMS_add = Nmasks write ( desc , 20 ) masks ( Nmasks )% included 20 format ( 'RMS coordinate deviation for ' , i6 , ' atoms' ) end function RMS_add subroutine RMS_calc ( i ) !arguments integer , intent ( in ) :: i !locals real ( 8 ) :: r if ( i < 1 . or . i > Nmasks ) return call mask_get ( masks ( i ), xin , coords ( i )% x ) r = sqrt ( sum (( coords ( i )% x - coords ( i )% x0 ) ** 2 ) / ( masks ( i )% included ) ) ! removed 3 in front of mask(i) write ( 100 , * ) r write ( * , 100 , advance = 'no' ) r 100 format ( f10 . 3 ) end subroutine RMS_calc subroutine RMS_make_ref ( i ) integer :: i , at if ( i < 1 . or . i > Nmasks ) return call mask_get ( masks ( i ), xtop , coords ( i )% x0 ) end subroutine RMS_make_ref subroutine RMS_heading ( i ) integer :: i write ( * , '(a)' , advance = 'no' ) 'RMSd(A)' end subroutine RMS_heading end module CALC_RMS","tags":"","loc":"sourcefile/calc_rms.f90.html","title":"calc_rms.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  calc_rmsf.f90 !  by Martin Almlof !  root mean square coordinate deviation !------------------------------------------------------------------------------! module CALC_RMSF use CALC_BASE use MASKMANIP implicit none !constants integer , parameter :: MAX_MASKS = 10 !module variables integer , private :: frames ( MAX_MASKS ), apa real ( 8 ), allocatable :: rmsf (:) type ( MASK_TYPE ), private , target :: masks ( MAX_MASKS ) integer , private :: Nmasks = 0 type RMSF_COORD_TYPE real , pointer :: x (:), x0 (:), x2 (:) end type RMSF_COORD_TYPE type ( RMSF_COORD_TYPE ), private :: coords ( MAX_MASKS ) contains subroutine RMSF_initialize end subroutine RMSF_initialize subroutine RMSF_finalize ( i ) integer :: i call mask_finalize ( masks ( i )) end subroutine RMSF_finalize integer function RMSF_add ( desc ) !arguments character ( * ) :: desc integer :: ats if ( Nmasks == MAX_MASKS ) then write ( * , 10 ) MAX_MASKS return end if 10 format ( 'Sorry, the maximum number of RMSF calculations is ' , i2 ) !add a new RMSF mask Nmasks = Nmasks + 1 call mask_initialize ( masks ( Nmasks )) ats = maskmanip_make ( masks ( Nmasks )) !discard if no atoms in mask if ( ats == 0 ) then call mask_finalize ( masks ( Nmasks )) Nmasks = Nmasks - 1 RMSF_add = 0 return end if allocate ( coords ( Nmasks )% x ( 3 * ats ), coords ( Nmasks )% x0 ( 3 * ats ), coords ( Nmasks )% x2 ( 3 * ats ), rmsf ( masks ( Nmasks )% included )) coords ( Nmasks )% x2 (:) = 0 coords ( Nmasks )% x0 (:) = 0 frames ( Nmasks ) = 0 call RMSF_make_ref ( Nmasks ) RMSF_add = Nmasks write ( desc , 20 ) masks ( Nmasks )% included 20 format ( 'RMSF coordinate deviation for ' , i6 , ' atoms' ) end function RMSF_add subroutine RMSF_calc ( i ) !arguments integer , intent ( in ) :: i !locals real ( 8 ) :: r if ( i < 1 . or . i > Nmasks ) return frames ( i ) = frames ( i ) + 1 call mask_get ( masks ( i ), xin , coords ( i )% x ) !calculate the sum of the squared coordinates up to this frame coords ( i )% x2 = coords ( i )% x2 + ( coords ( i )% x ) ** 2 !calculate the average coordinates up to this frame coords ( i )% x0 = coords ( i )% x0 * ( 1. _ 8 - 1. _ 8 / frames ( i )) + coords ( i )% x / frames ( i ) do apa = 1 , masks ( i )% included rmsf ( apa ) = sqrt ( 1. _ 8 / frames ( i ) * sum ( coords ( i )% x2 ( 3 * apa - 2 : 3 * apa )) - sum (( coords ( i )% x0 ( 3 * apa - 2 : 3 * apa )) ** 2 )) end do r = 1. _ 8 / masks ( i )% included * sum ( rmsf ) write ( * , 100 , advance = 'no' ) r 100 format ( f10 . 3 ) end subroutine RMSF_calc subroutine RMSF_make_ref ( i ) integer :: i , at if ( i < 1 . or . i > Nmasks ) return call mask_get ( masks ( i ), xtop , coords ( i )% x0 ) end subroutine RMSF_make_ref subroutine RMSF_heading ( i ) integer :: i write ( * , '(a)' , advance = 'no' ) 'RMSFd(A)' end subroutine RMSF_heading end module CALC_RMSF","tags":"","loc":"sourcefile/calc_rmsf.f90.html","title":"calc_rmsf.f90 – Fortran Program"},{"text":"Source Code SUBROUTINE EIGEN ( A , R , N , MV ) ! !CCCCC W.F. VAN GUNSTEREN, CAMBRIDGE, JUNE 1979 CCCCCCCCCCCCCCCCCCCCCCCC !                                                                      C !SUBROUTINE EIGEN (A,R,N,MV)                                           C !                                                                      C !COMMENT:   EIGEN COMPUTES EIGENVALUES AND EIGENVECTORS OF THE REAL    C !     SYMMETRIC N*N MATRIX A, USING THE DIAGONALIZATION METHOD         C !     DESCRIBED IN \"MATHEMATICAL METHODS FOR DIGITAL COMPUTERS\", EDS.  C !     A.RALSTON AND H.S.WILF, WILEY, NEW YORK, 1962, CHAPTER 7.        C !     IT HAS BEEN COPIED FROM THE IBM SCIENTIFIC SUBROUTINE PACKAGE.   C !                                                                      C !     A(1..N*(N+1)/2) = MATRIX TO BE DIAGONALIZED, STORED IN SYMMETRIC C !                       STORAGE MODE, VIZ. THE I,J-TH ELEMENT (I.GE.J) C !                       IS STORED AT THE LOCATION K=I*(I-1)/2+J IN A;  C !                       THE EIGENVALUES ARE DELIVERED IN DESCENDING    C !                       ORDER ON THE DIAGONAL, VIZ. AT THE LOCATIONS   C !                       K=I*(I+1)/2                                    C !     R(1..N,1..N) = DELIVERED WITH THE CORRESPONDING EIGENVECTORS     C !                    STORED COLUMNWISE                                 C !     N = ORDER OF MATRICES A AND R                                    C !     MV = 0 : EIGENVALUES AND EIGENVECTORS ARE COMPUTED               C !        = 1 : ONLY EIGENVALUES ARE COMPUTED                           C !                                                                      C !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC ! !implicit double precision (A-H, O-Z) double precision :: A , B , C , D , E , F , G , H , O , P , Q , R , S , T , U , V , W , X , Y , Z double precision :: anorm , anrmx , thr , sinx , sinx2 , cosx , cosx2 , sincs !implicit integer (I-N) integer :: I , J , K , L , M , N , range , mv , iq , ij , ia , ind , mq , lq , lm , ll , mm , ilq , imq , im , il , ilr , imr , jq DIMENSION A ( 1 ), R ( 1 ) ! !*****GENERATE IDENTITY MATRIX 5 RANGE = 1.E-12 IF ( MV - 1 ) 10 , 25 , 10 10 IQ =- N DO 20 J = 1 , N IQ = IQ + N DO 20 I = 1 , N IJ = IQ + I R ( IJ ) = 0.E0 IF ( I - J ) 20 , 15 , 20 15 R ( IJ ) = 1.E0 20 CONTINUE ! !*****COMPUTE INITIAL AND FINAL NORMS (ANORM AND ANRMX) 25 ANORM = 0.E0 DO 35 I = 1 , N DO 35 J = I , N IF ( I - J ) 30 , 35 , 30 30 IA = I + ( J * J - J ) / 2 ANORM = ANORM + A ( IA ) * A ( IA ) 35 CONTINUE IF ( ANORM ) 165 , 165 , 40 40 ANORM = 1.414E0 * SQRT ( ANORM ) ANRMX = ANORM * RANGE / FLOAT ( N ) ! !*****INITIALIZE INDICATORS AND COMPUTE THRESHOLD, THR IND = 0 THR = ANORM 45 THR = THR / FLOAT ( N ) 50 L = 1 55 M = L + 1 ! !*****COMPUT SIN AND COS 60 MQ = ( M * M - M ) / 2 LQ = ( L * L - L ) / 2 LM = L + MQ 62 IF ( ABS ( A ( LM )) - THR ) 130 , 65 , 65 65 IND = 1 LL = L + LQ MM = M + MQ X = 0.5E0 * ( A ( LL ) - A ( MM )) 68 Y =- A ( LM ) / SQRT ( A ( LM ) * A ( LM ) + X * X ) IF ( X ) 70 , 75 , 75 70 Y =- Y 75 SINX = Y / SQRT ( 2.E0 * ( 1.E0 + ( SQRT ( 1.E0 - Y * Y )))) SINX2 = SINX * SINX 78 COSX = SQRT ( 1.E0 - SINX2 ) COSX2 = COSX * COSX SINCS = SINX * COSX ! !*****ROTATE L AND M COLUMNS ILQ = N * ( L - 1 ) IMQ = N * ( M - 1 ) DO 125 I = 1 , N IQ = ( I * I - I ) / 2 IF ( I - L ) 80 , 115 , 80 80 IF ( I - M ) 85 , 115 , 90 85 IM = I + MQ GOTO 95 90 IM = M + IQ 95 IF ( I - L ) 100 , 105 , 105 100 IL = I + LQ GOTO 110 105 IL = L + IQ 110 X = A ( IL ) * COSX - A ( IM ) * SINX A ( IM ) = A ( IL ) * SINX + A ( IM ) * COSX A ( IL ) = X 115 IF ( MV - 1 ) 120 , 125 , 120 120 ILR = ILQ + I IMR = IMQ + I X = R ( ILR ) * COSX - R ( IMR ) * SINX R ( IMR ) = R ( ILR ) * SINX + R ( IMR ) * COSX R ( ILR ) = X 125 END DO X = 2.E0 * A ( LM ) * SINCS Y = A ( LL ) * COSX2 + A ( MM ) * SINX2 - X X = A ( LL ) * SINX2 + A ( MM ) * COSX2 + X A ( LM ) = ( A ( LL ) - A ( MM )) * SINCS + A ( LM ) * ( COSX2 - SINX2 ) A ( LL ) = Y A ( MM ) = X ! !*****TESTS FOR COMPLETION ! !*****TEST FOR M = LAST COLUMN 130 IF ( M - N ) 135 , 140 , 135 135 M = M + 1 GOTO 60 ! !*****TEST FOR L = SECOND FROM LAST COLUMN 140 IF ( L - ( N - 1 )) 145 , 150 , 145 145 L = L + 1 GOTO 55 150 IF ( IND - 1 ) 160 , 155 , 160 155 IND = 0 GOTO 50 ! !*****COMPARE THRESHOLD WITH FINAL NORM 160 IF ( THR - ANRMX ) 165 , 165 , 45 ! !*****SORT EIGENVALUES AND EIGENVECTORS 165 IQ =- N DO 185 I = 1 , N IQ = IQ + N LL = I + ( I * I - I ) / 2 JQ = N * ( I - 2 ) DO 185 J = I , N JQ = JQ + N MM = J + ( J * J - J ) / 2 IF ( A ( LL ) - A ( MM )) 170 , 185 , 185 170 X = A ( LL ) A ( LL ) = A ( MM ) A ( MM ) = X IF ( MV - 1 ) 175 , 185 , 175 175 DO 180 K = 1 , N ILR = IQ + K IMR = JQ + K X = R ( ILR ) R ( ILR ) = R ( IMR ) 180 R ( IMR ) = X 185 CONTINUE ! RETURN END","tags":"","loc":"sourcefile/eigen.f90.html","title":"eigen.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  index.f90 !  by John Marelius !  string-to-integer index lookup table and functions !------------------------------------------------------------------------------! module indexer implicit none !constants character ( * ), private , parameter :: MODULE_VERSION = '5.7' character ( * ), private , parameter :: MODULE_DATE = '2015-02-22' integer , private :: count = 0 , top = 0 integer , parameter :: KEYLENGTH = 8 integer , parameter , private :: RESIZE_INCREMENT = 10 type indexentry character ( len = KEYLENGTH ) :: key integer :: ndx end type indexentry type ( indexentry ), pointer , private :: ndx (:) integer , private :: memstat !declare private procedures private grow contains subroutine index_create ( size ) !arguments integer , optional :: size !locals call index_clear top = RESIZE_INCREMENT !use default starting size if ( present ( size )) then if ( size > 0 ) then top = size end if end if allocate ( ndx ( top )) end subroutine index_create subroutine index_clear count = 0 top = 0 deallocate ( ndx , stat = memstat ) !ignore error if not allocated end subroutine index_clear subroutine index_shutdown call index_clear end subroutine index_shutdown subroutine index_startup end subroutine index_startup subroutine index_resize ( size ) !arguments integer :: size !locals integer :: mintop type ( indexentry ), pointer :: new_ndx (:) if ( size <= 0 ) then call index_clear else !allocate new allocate ( new_ndx ( size )) !copy mintop = min ( top , size ) new_ndx ( 1 : mintop ) = ndx ( 1 : mintop ) !get rid of old deallocate ( ndx , stat = memstat ) !point ndx to new_ndx ndx => new_ndx top = size end if end subroutine index_resize subroutine grow call index_resize ( top + RESIZE_INCREMENT ) end subroutine grow logical function index_add ( key , index ) !arguments character ( * ) :: key integer :: index !locals integer :: i , j do i = 1 , count if ( ndx ( i )% key == key ) then !cannot redefine index_add = . false . return elseif ( lgt ( ndx ( i )% key , key )) then !grow if necessary if ( count == top ) call grow !make a slot by moving subsequent entries do j = count , i , - 1 ndx ( j + 1 ) = ndx ( j ) end do exit end if end do if ( count == top ) call grow !grow also if inserting last ndx ( i )% key = key ndx ( i )% ndx = index count = count + 1 index_add = . true . end function index_add logical function index_alias ( alias , key ) !arguments character ( * ) :: alias , key !locals integer :: index index_alias = . false . if ( index_get ( key , index )) then if ( index_add ( alias , index )) then index_alias = . true . end if end if end function index_alias logical function index_get ( key , i , allow_wildcard ) !arguments character ( * ), intent ( in ) :: key integer , intent ( out ) :: i logical , optional :: allow_wildcard !locals integer :: hi , lo , mid !perform standard binary search !(Modified from N. C. Shammas/Secrets of the Visual C++ Masters) index_get = . false . i = 0 if ( present ( allow_wildcard )) then if ( allow_wildcard . and . ( key == '?' . or . key == '0' )) then index_get = . true . return endif endif lo = 1 hi = count do while ( lo <= hi ) mid = ( lo + hi ) / 2 if ( ndx ( mid )% key == key ) then i = ndx ( mid )% ndx index_get = . true . return elseif ( lle ( key , ndx ( mid )% key )) then hi = mid - 1 else lo = mid + 1 end if end do end function index_get end module indexer","tags":"","loc":"sourcefile/index.f90.html","title":"index.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  mask.f90 !  by John Marelius !  atom selection mask !------------------------------------------------------------------------------! module atom_mask use topo implicit none ! version data character ( * ), private , parameter :: MODULE_VERSION = '5.7' character ( * ), private , parameter :: MODULE_DATE = '2015-02-22' !private procedures private update , update_pretop , set_solute , get_word , finalize_storage !declare variables logical ( 1 ), private , allocatable :: solute (:) type , private :: set integer :: first , last logical :: residue_numbering logical :: solute1 , solute2 logical :: excl1 , excl2 logical :: restr1 , restr2 logical :: heavy1 , heavy2 logical :: sybyl1 , sybyl2 logical :: notflag character ( 5 ) :: sybylcode end type set type , public :: MASK_TYPE integer :: included logical ( 1 ), pointer :: mask (:) end type MASK_TYPE contains subroutine mask_startup call topo_startup end subroutine mask_startup subroutine mask_shutdown call finalize_storage end subroutine mask_shutdown subroutine mask_initialize ( m ) !arguments type ( MASK_TYPE ) :: m allocate ( m % mask ( nat_pro )) call mask_clear ( m ) if (. not . allocated ( solute )) then allocate ( solute ( nat_pro )) call set_solute end if end subroutine mask_initialize subroutine mask_finalize ( m ) !arguments type ( MASK_TYPE ) :: m if ( associated ( m % mask )) deallocate ( m % mask ) m % included = 0 end subroutine mask_finalize subroutine mask_clear ( m ) !arguments type ( MASK_TYPE ) :: m !clear mask m % mask (:) = . false . m % included = 0 end subroutine mask_clear subroutine mask_all ( m ) !arguments type ( MASK_TYPE ) :: m !clear mask m % mask (:) = . true . m % included = nat_pro end subroutine mask_all integer function mask_count ( m ) !arguments type ( MASK_TYPE ) :: m mask_count = m % included end function mask_count subroutine set_solute solute ( 1 : nat_solute ) = . true . solute ( nat_solute + 1 : nat_pro ) = . false . end subroutine set_solute !***************************************************** !Add atoms to mask according to rules in 'line'. !***************************************************** integer function mask_add ( m , line , pretop ) !arguments logical , intent ( in ), optional :: pretop type ( MASK_TYPE ) :: m character ( * ) :: line !locals character ( len = 80 ) :: word integer :: pos type ( set ) :: s integer :: i logical :: empty integer :: readstat integer :: inthis !clear set description s % first = 1 s % last = nat_pro !default to whole sequence s % residue_numbering = . false . !use atom numbering s % solute1 = . true . s % solute2 = . false . s % excl1 = . true . s % excl2 = . false . s % restr1 = . true . s % restr2 = . false . s % heavy1 = . true . s % heavy2 = . false . s % sybyl1 = . true . s % sybyl2 = . false . s % sybylcode = \"\" s % notflag = . false . empty = . true . mask_add = 0 pos = 0 do while ( get_word ( line , word , pos )) call upcase ( word ) select case ( word ) case ( 'ALL' ) s % notflag = . false . empty = . false . case ( 'NOT' , '-' ) s % notflag = . true . case ( 'RESIDUE' , 'RES' , 'RESI' ) s % residue_numbering = . true . s % notflag = . false . case ( 'SOLUTE' ) s % solute1 = . not . s % notflag s % solute2 = . not . s % notflag empty = . false . s % notflag = . false . case ( 'EXCLUDED' , 'EXCL' ) s % excl1 = . not . s % notflag s % excl2 = . not . s % notflag empty = . false . s % notflag = . false . case ( 'RESTRAINED' ) s % restr1 = . not . s % notflag s % restr2 = . not . s % notflag empty = . false . s % notflag = . false . case ( 'HEAVY' ) s % heavy1 = . not . s % notflag s % heavy2 = . not . s % notflag empty = . false . s % notflag = . false . case ( 'SYBYL' ) s % sybyl1 = . not . s % notflag s % sybyl2 = . not . s % notflag s % notflag = . false . if (. not . get_word ( line , word , pos )) then ! get (potential) SYBYL name write ( * , 800 ) 800 format ( '>>>>> ERROR: no SYBYL name found' ) exit end if s % sybylcode = word call get_sybylcode ( s % sybylcode ) empty = . false . case default read ( word , * , iostat = readstat ) s % first if ( readstat /= 0 ) then write ( * , 900 ) trim ( word ) 900 format ( '>>>>> ERROR: unrecognised property ' , a ) empty = . true . exit elseif ( s % residue_numbering . and . ( s % first < 1 . or . & s % first > nres )) then write ( * , 911 ) s % first 911 format ( '>>>>> ERROR: invalid first residue ' , i5 ) empty = . true . exit elseif ( s % first < 1 . or . s % first > nat_pro ) then write ( * , 910 ) s % first 910 format ( '>>>>> ERROR: invalid first atom ' , i5 ) empty = . true . exit elseif (. not . get_word ( line , word , pos )) then empty = . false . !default to all !failed to read last atom, assume last=first s % last = s % first exit else empty = . false . !default to all read ( word , * , iostat = readstat ) s % last if ( readstat /= 0 . or . & ( s % residue_numbering . and . s % last > nres ) . or . & s % last < s % first . or . s % last > nat_pro ) then if ( s % residue_numbering ) then write ( * , 931 ) trim ( word ) else write ( * , 930 ) trim ( word ) end if 930 format ( '>>>>> ERROR: invalid last atom ' , a ) 931 format ( '>>>>> ERROR: invalid last residue ' , a ) empty = . true . exit else exit end if end if end select end do if (. not . empty . and . present ( pretop )) then if ( pretop ) then mask_add = update_pretop ( s , m ) else mask_add = update ( s , m ) end if elseif (. not . empty ) then mask_add = update ( s , m ) end if end function mask_add !***************************************************** logical function get_word ( line , word , pos ) !arguments character ( * ) :: line character ( * ), intent ( out ) :: word integer , intent ( inout ) :: pos !locals integer , save :: linelen character , save :: TAB = char ( 9 ) integer :: start_field , end_field logical :: prm_res get_word = . false . if ( pos <= 1 ) then pos = 1 linelen = len_trim ( line ) end if if ( linelen == 0 ) return if ( pos > linelen ) return do while ( line ( pos : pos ) == ' ' . or . line ( pos : pos ) == TAB ) pos = pos + 1 if ( pos > linelen ) then return end if end do start_field = pos do while ( line ( pos : pos ) /= ' ' . and . line ( pos : pos ) /= TAB ) pos = pos + 1 if ( pos > linelen ) then exit end if end do end_field = pos - 1 pos = pos + 1 !update for next call word = line ( start_field : end_field ) get_word = . true . end function get_word !***************************************************** ! Update mask from rules in s. ! if s%property1 and s%property2 are true, then that ! requested without \"not\". if both are false then it has ! been requested with \"not\" flag. else it has not been requested !***************************************************** integer function update ( s , m ) !arguments type ( set ) :: s type ( MASK_TYPE ) :: m !locals integer :: i character ( 5 ) :: sybyl_upcase logical ( 1 ), allocatable :: sybyl (:) update = 0 if ( s % residue_numbering ) then s % first = res ( s % first )% start if ( s % last == nres ) then s % last = nat_pro else s % last = res ( s % last + 1 )% start - 1 endif end if allocate ( sybyl ( nat_pro )) sybyl (:) = . false . if ( s % sybyl1 . eqv . s % sybyl2 ) then !make sybyl array write ( * , * ) \"making sybyl array\" do i = s % first , s % last sybyl_upcase = SYBYL_atom_type ( iac ( i )) call upcase ( sybyl_upcase ) if ( sybyl_upcase == s % sybylcode ) then sybyl ( i ) = . true . end if end do end if do i = s % first , s % last if ( (( solute ( i ) . eqv . s % solute1 ) . or . ( solute ( i ) . eqv . s % solute2 )). and .& (( excl ( i ) . eqv . s % excl1 ) . or . ( excl ( i ) . eqv . s % excl2 )) . and . & (( ( shell ( i ) . or . excl ( i )) . eqv . s % restr1 ) . or . (( shell ( i ) . or . excl ( i )) . eqv . s % restr2 )) . and . & (( heavy ( i ) . eqv . s % heavy1 ) . or . ( heavy ( i ) . eqv . s % heavy2 )) . and . & (( sybyl ( i ) . eqv . s % sybyl1 ) . or . ( sybyl ( i ) . eqv . s % sybyl2 ))) then if (. not . m % mask ( i )) then m % mask ( i ) = . true . update = update + 1 end if end if end do m % included = m % included + update if ( allocated ( sybyl )) deallocate ( sybyl ) end function update !***************************************************** ! Update mask from rules in s. ! Used before topology is made, thus ! vectors 'excl' or 'shell' cannot be used. !***************************************************** integer function update_pretop ( s , m ) !arguments type ( set ) :: s type ( MASK_TYPE ) :: m !locals integer :: i update_pretop = 0 if ( s % residue_numbering ) then s % first = res ( s % first )% start if ( s % last == nres ) then s % last = nat_pro else s % last = res ( s % last + 1 )% start - 1 endif end if do i = s % first , s % last if ((( solute ( i ) . eqv . s % solute1 ) . or . ( solute ( i ) . eqv . s % solute2 )). and .& (( heavy ( i ) . eqv . s % heavy1 ) . or . ( heavy ( i ) . eqv . s % heavy2 ))) then if (. not . m % mask ( i )) then m % mask ( i ) = . true . update_pretop = update_pretop + 1 end if end if end do m % included = m % included + update_pretop end function update_pretop !***************************************************** ! Function: get_sybylcode() ! Argument: A (potential) SYBYL atom name ! Returns:  the integer atom code (iac) for that SYBYL name !           (returns 0 if the argument is not a valid SYBYL name) !***************************************************** subroutine get_sybylcode ( sybylname ) !arguments character ( * ) :: sybylname ! (potential) SYBYL name !locals integer :: i = 1 , check_sybylcode ! index character ( len = 5 ) :: this_sybyl_caps ! SYBYL_atom_type(i) in CAPS do i = 1 , natyps this_sybyl_caps = SYBYL_atom_type ( i ) call upcase ( this_sybyl_caps ) if ( this_sybyl_caps == sybylname ) then check_sybylcode = i end if end do if ( check_sybylcode == 0 ) then write ( * , 940 ) sybylname 940 format ( '>>>>> ERROR: invalid SYBYL code ' , a ) end if end subroutine get_sybylcode !***************************************************** subroutine finalize_storage if ( allocated ( solute )) deallocate ( solute ) end subroutine finalize_storage subroutine mask_get ( m , x , xmasked ) !arguments type ( MASK_TYPE ) :: m real ( 8 ) :: x (:) real :: xmasked (:) integer :: i , i3 , j if ( size ( x ) < 3 * nat_pro . or . size ( xmasked ) < 3 * m % included ) then write ( * , 900 ) 900 format ( '>>>>> ERROR: invalid coordinate array size.' ) return end if j = 0 do i = 1 , nat_pro if ( m % mask ( i )) then j = j + 1 xmasked ( 3 * j - 2 : 3 * j ) = x ( 3 * i - 2 : 3 * i ) end if end do end subroutine mask_get !*************************************************** !transfer coords from masked atoms in 'xmasked' ! to topology coord array 'x' !*************************************************** subroutine mask_put ( m , x , xmasked ) !arguments type ( MASK_TYPE ) :: m real ( 8 ) :: x (:) real :: xmasked (:) integer :: i , i3 , j if ( size ( x ) < 3 * nat_pro . or . size ( xmasked ) < 3 * m % included ) then write ( * , 900 ) 900 format ( '>>>>> ERROR: invalid coordinate array size.' ) return end if j = 0 do i = 1 , nat_pro if ( m % mask ( i )) then j = j + 1 x ( 3 * i - 2 : 3 * i ) = xmasked ( 3 * j - 2 : 3 * j ) end if end do end subroutine mask_put !***************************************************** end module atom_mask","tags":"","loc":"sourcefile/mask.f90.html","title":"mask.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  maskmanip.f90 !  by John Marelius !  atom mask manipulation functions !------------------------------------------------------------------------------! module MASKMANIP use ATOM_MASK use MISC use PARSE implicit none contains !******************************************************* integer function maskmanip_make ( mask ) !arguments type ( MASK_TYPE ) :: mask !locals character ( len = 200 ) :: line integer :: included , inthis call mask_clear ( mask ) do call getlin ( line , 'Mask:' ) call upcase ( line ) if ( line == 'END' . or . line == '.' ) exit if ( line == 'CLEAR' ) then call mask_clear ( mask ) cycle elseif ( line == 'HELP' . or . line == '?' ) then call maskmanip_help cycle end if inthis = mask_add ( mask , line ) write ( * , 110 ) inthis , mask % included 110 format ( 'Added' , i5 , ' atoms to the mask which now contains' , i5 , ' atoms.' ) end do maskmanip_make = mask % included end function maskmanip_make !******************************************************* subroutine maskmanip_help call centered_heading ( 'Help for mask creation' , '-' ) WRITE ( * , '(a)' ) & 'The following syntax is used to specify the set of atoms to include:' , & '[properties] [residue] [first [last]]' , & '  properties are one or more of:' ,& '    solute: only solute atoms' , & '    excluded: atoms outside the simulation sphere' , & '    restrained: atoms outside the simulation sphere and in the restrained shell' , & '    heavy: heavy (non-hydrogen) atoms' , & '    sybyl syb.type: atoms of sybyl type \"syb.type\"' , & '  Each property may be negated by prepending not.' , & '  If no property is given, all atoms are selected.' ,& '  residue: first and last are residue numbers, not atom numbers' , & '  first: first atom/residue of a sequence.' , & '  last: last atom/residue of a sequence.' ,& '  If first and last are omitted, first=1 and last=number of atoms/residues' , & '  If last is omitted, last=first.' ,& 'Enter atom set specifications and terminate with end.' end subroutine maskmanip_help !******************************************************* integer function maskmanip_make_pretop ( mask ) !arguments type ( MASK_TYPE ) :: mask !locals character ( len = 200 ) :: line integer :: included , inthis logical :: pretop = . true . call mask_clear ( mask ) do call get_line_arg ( line , 'Mask:' ) call upcase ( line ) if ( line == 'END' . or . line == '.' ) exit if ( line == 'CLEAR' ) then call mask_clear ( mask ) cycle elseif ( line == 'HELP' . or . line == '?' ) then call maskmanip_help_pretop cycle end if inthis = mask_add ( mask , line , pretop ) write ( * , 110 ) inthis , mask % included 110 format ( 'Added' , i5 , ' atoms to the mask which now contains' , i5 , ' atoms.' ) end do maskmanip_make_pretop = mask % included end function maskmanip_make_pretop !******************************************************* subroutine maskmanip_help_pretop call centered_heading ( 'Help for mask creation' , '-' ) WRITE ( * , '(a)' ) & 'The following syntax is used to specify the set of atoms to include:' , & '[properties] [residue] [first [last]]' , & '  properties are one or more of:' ,& '    solute: only solute atoms' , & '    heavy: heavy (non-hydrogen) atoms' , & '  Each property may be negated by prepending not.' , & '  If no property is given, all atoms are selected.' ,& '  residue: first and last are residue numbers, not atom numbers' , & '  first: first atom/residue of a sequence.' , & '  last: last atom/residue of a sequence.' ,& '  If first and last are omitted, first=1 and last=number of atoms/residues' , & '  If last is omitted, last=first.' ,& 'Enter atom set specifications and terminate with end.' end subroutine maskmanip_help_pretop !******************************************************* end module MASKMANIP","tags":"","loc":"sourcefile/maskmanip.f90.html","title":"maskmanip.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  misc.f90 !  by John Marelius & Johan Aqvist !  miscellaneous utility functions !------------------------------------------------------------------------------! module misc use sizes implicit none ! version data character ( * ), private , parameter :: MODULE_VERSION = '5.7' character ( * ), private , parameter :: MODEULE_DATE = '2015-02-22' contains subroutine centered_heading ( msg , fill ) character ( * ) :: msg character :: fill integer :: n , i n = ( 78 - len ( msg )) / 2 write ( * , '(80a)' ) ( fill , i = 1 , n ), ' ' , msg , ' ' , ( fill , i = 1 , n - 1 ) end subroutine centered_heading integer function freefile () integer :: u logical :: used do u = 20 , 999 inquire ( unit = u , opened = used ) if (. not . used ) then freefile = u return end if end do !if we get here then we're out of unit numbers write ( * , 20 ) stop 255 20 format ( 'ERROR: Failed to find an unused unit number' ) end function freefile subroutine skip_comments ( unit ) INTEGER unit CHARACTER ( 1000 ) c c = '*' DO while ( c ( 1 : 1 ) == '*' . or . c ( 1 : 1 ) == '!' . or . c ( 1 : 1 ) == '#' ) READ ( unit = unit , fmt = '(a)' , end = 100 , err = 100 ) c enddo !        go to beginning of record BACKSPACE ( unit ) 100 RETURN !....................................................................... end subroutine skip_comments !----------------------------------------------------------------------- subroutine getlin ( intxt , outtxt ) !arguments CHARACTER ( * ), intent ( out ) :: intxt character ( * ), intent ( in ), optional :: outtxt if ( present ( outtxt )) then write ( * , '(a)' , advance = 'no' ) outtxt end if READ ( * , '(a)' ) intxt !....................................................................... end subroutine getlin !----------------------------------------------------------------------- subroutine upcase ( string ) !arguments character ( * ), intent ( inout ) :: string integer :: i , c do i = len_trim ( string ), 1 , - 1 c = ichar ( string ( i : i )) if ( c >= 97 . and . c <= 122 ) c = iand ( c , 223 ) string ( i : i ) = char ( c ) end do end subroutine upcase subroutine locase ( string ) !arguments character ( * ), intent ( inout ) :: string integer :: i , c do i = len ( string ), 1 , - 1 c = ior ( ichar ( string ( i : i )), 32 ) string ( i : i ) = char ( c ) end do end subroutine locase character ( len = 3 ) function onoff ( l ) !arguments logical :: l if ( l ) then onoff = 'on' else onoff = 'off' endif end function onoff integer function string_part ( string , separator , start ) !arguments character ( * ) :: string , separator integer :: start !locals integer :: totlen totlen = len_trim ( string ) string_part = index ( string ( start : totlen ), separator ) if ( string_part == 0 ) then string_part = totlen else string_part = string_part - 2 + start end if end function string_part real ( 8 ) function rtime () integer :: timevals ( 8 ) call date_and_time ( values = timevals ) rtime = timevals ( 3 ) * 24 * 3600 + timevals ( 5 ) * 3600 + timevals ( 6 ) * 60 + timevals ( 7 ) + 0.001 * timevals ( 8 ) end function rtime end module misc","tags":"","loc":"sourcefile/misc.f90.html","title":"misc.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  mpiglob.f90 !  by John Marelius & Anders Kaplan !  global variables for MPI parallell Qdyn !------------------------------------------------------------------------------! module mpiglob use nrgy ! types and variables used for calculation assignment type PAIR_ASSIGNMENT_TYPE integer :: start , end integer :: max end type PAIR_ASSIGNMENT_TYPE type NODE_ASSIGNMENT_TYPE type ( PAIR_ASSIGNMENT_TYPE ) :: pp , pw , ww , qp , qw end type NODE_ASSIGNMENT_TYPE !Gathering type MPI_NB_ENERGIES sequence real ( kind = dp ) :: lrf type ( NB_ENERGIES ) :: pp , pw , ww end type MPI_NB_ENERGIES !Gathering type MPI_NBQ_ENERGIES sequence type ( NB_ENERGIES ) :: qp , qw end type MPI_NBQ_ENERGIES ! global MPI data integer :: nodeid , numnodes , ierr integer , allocatable :: mpi_status (:,:) !Used for gathering d,E,EQ real ( kind = dp ), allocatable :: d_recv (:,:) type ( MPI_NB_ENERGIES ), allocatable :: E_recv (:), E_send (:) type ( MPI_NBQ_ENERGIES ), allocatable :: EQ_recv (:,:), EQ_send (:) integer , allocatable :: request_recv (:,:) !Book keeping of nb-pairs integer :: totnbpp , totnbpw , totnbww , totnbqp , totnbqw integer , dimension ( 5 ) :: nbxx , nbxx_tot !Balancing nodes !Keep track of how many nb-pairs each chargegroup will generate integer , allocatable :: nbpp_per_cgp (:) integer , allocatable :: nbpw_per_cgp (:) integer , allocatable :: nbww_per_cgp (:) integer , allocatable :: nbqp_per_cgp (:) integer , allocatable :: nbqw_per_cgp (:) end module mpiglob","tags":"","loc":"sourcefile/mpiglob.f90.html","title":"mpiglob.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  parse.f90 !  by John Marelius !  command parser !------------------------------------------------------------------------------! module PARSE use MISC implicit none !constants character ( * ), private , parameter :: MODULE_VERSION = '5.7' character ( * ), private , parameter :: MODULE_DATE = '2015-02-22' integer , parameter :: MAX_ARGS = 10 type substring integer :: istart , iend end type substring character ( 200 ) :: inbuf type ( substring ) :: argv ( 0 : MAX_ARGS ) integer :: argc = 0 , argp = 1 logical , private :: read_from_file = . false . !Enables input from file integer , private :: INFILE = 0 contains subroutine parse_startup () argc = 0 argp = 1 end subroutine parse_startup !-------------------------------------------------------------------------- logical function parse_open_file ( filename ) character ( * ) :: filename integer :: stat parse_open_file = . false . read_from_file = . true . INFILE = freefile () open ( unit = INFILE , file = filename , status = 'old' , form = 'formatted' , & action = 'read' , iostat = stat , access = 'sequential' ) if ( stat /= 0 ) then parse_open_file = . false . INFILE = 0 return endif parse_open_file = . true . end function parse_open_file !-------------------------------------------------------------------------- !Moved from Misc !-------------------------------------------------------------------------- integer function openit ( lun , fil , stat , frm , mode ) !arguments INTEGER lun CHARACTER ( * ) fil , stat , frm character ( * ) :: mode !locals integer :: errcode if ( trim ( fil ). eq . '' ) write ( * , * ) 'Invalid filename' errcode = - 1 !....................................................................... do while ( errcode /= 0 ) OPEN ( unit = lun , file = fil , status = stat , form = frm , & iostat = errcode , action = mode ) if ( errcode /= 0 ) then WRITE ( * , 10 ) trim ( fil ), lun , errcode CALL get_string_arg ( fil , ' >>>>> Enter a new file name (or nothing to cancel): ' ) if ( fil == '' . or . fil == 'nothing' ) exit end if end do openit = errcode 10 format ( '>>>>> Failed to open ' , a , ' (unit ' , i2 , ' error code ' , i4 , ')' ) !....................................................................... end function openit !-------------------------------------------------------------------------- !split text in inbuf into subroutine split integer :: p logical :: ws_flag logical :: quote_flag character , save :: TAB = achar ( 9 ) integer :: inlen integer :: trimlen ( 1 ) argc = 0 argp = 1 ws_flag = . true . quote_flag = . false . trimlen = len_trim ( inbuf ) inlen = trimlen ( 1 ) do p = 1 , inlen if ( inbuf ( p : p ) == '\"' ) then if ( quote_flag ) then !closing quotation mark quote_flag = . false . ws_flag = . true . else !opening quotation mark quote_flag = . true . !set to accept all characters (like ' ') in string ws_flag = . true . !set to begin string at next positon end if elseif (( inbuf ( p : p ) == ' ' . or . inbuf ( p : p ) == TAB ) . and . . not . quote_flag ) then if (. not . ws_flag ) argv ( argc )% iend = p - 1 ws_flag = . true . elseif ( ws_flag ) then argc = argc + 1 if ( argc > MAX_ARGS ) then write ( * , * ) 'WARNING: Command argument overflow' exit end if argv ( argc )% istart = p argv ( argc )% iend = p !step up character by character ws_flag = . false . else argv ( argc )% iend = p !step up character by character ws_flag = . false . end if end do end subroutine split !-------------------------------------------------------------------------- subroutine getline () do if ( read_from_file ) then read ( INFILE , '(a200)' ) inbuf else read ( * , '(a200)' ) inbuf endif inbuf = adjustl ( inbuf ) !only exit if not a comment line if ( scan ( inbuf ( 1 : 1 ), '!#*' ) == 0 ) exit end do call split end subroutine getline !-------------------------------------------------------------------------- subroutine get_string_arg ( arg , prompt ) !arguments character ( * ), intent ( out ) :: arg character ( * ), optional , intent ( in ) :: prompt do while ( argp > argc ) if ( present ( prompt )) write ( unit =* , fmt = '(a)' , advance = 'no' ) prompt call getline end do arg = inbuf ( argv ( argp )% istart : argv ( argp )% iend ) argp = argp + 1 end subroutine get_string_arg !-------------------------------------------------------------------------- subroutine get_line_arg ( arg , prompt ) !arguments character ( * ), intent ( out ) :: arg character ( * ), optional , intent ( in ) :: prompt do while ( argp > argc ) if ( present ( prompt )) write ( unit =* , fmt = '(a)' , advance = 'no' ) prompt call getline end do !return the rest of the line arg = inbuf ( argv ( argp )% istart : len_trim ( inbuf )) call parse_reset !reset argument counter - new line next time end subroutine get_line_arg !-------------------------------------------------------------------------- logical function get_string_single_line ( arg , prompt ) !arguments character ( * ), intent ( out ) :: arg character ( * ), optional , intent ( in ) :: prompt if ( argc == 0 ) then if ( present ( prompt )) write ( unit =* , fmt = '(a)' , advance = 'no' ) prompt call getline end if if ( argp > argc ) then arg = '' get_string_single_line = . false . else arg = inbuf ( argv ( argp )% istart : argv ( argp )% iend ) argp = argp + 1 get_string_single_line = . true . end if end function get_string_single_line !-------------------------------------------------------------------------- subroutine parse_reset argc = 0 argp = 1 end subroutine parse_reset !-------------------------------------------------------------------------- integer function get_int_arg ( prompt ) !arguments character ( * ), optional , intent ( in ) :: prompt !locals integer :: value 1 do while ( argp > argc ) if ( present ( prompt )) write ( unit =* , fmt = '(a)' , advance = 'no' ) prompt call getline end do read ( inbuf ( argv ( argp )% istart : argv ( argp )% iend ), fmt =* , err = 100 ) value get_int_arg = value argp = argp + 1 return 100 write ( * , * ) 'Please enter an integer value!' call parse_reset goto 1 end function get_int_arg !-------------------------------------------------------------------------- real function get_real_arg ( prompt ) !arguments character ( * ), optional , intent ( in ) :: prompt !locals real :: value 1 do while ( argp > argc ) if ( present ( prompt )) write ( unit =* , fmt = '(a)' , advance = 'no' ) prompt call getline end do read ( inbuf ( argv ( argp )% istart : argv ( argp )% iend ), fmt =* , err = 100 ) value get_real_arg = value argp = argp + 1 return 100 write ( * , * ) 'Please enter a number!' call parse_reset goto 1 end function get_real_arg !-------------------------------------------------------------------------- end module PARSE","tags":"","loc":"sourcefile/parse.f90.html","title":"parse.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  prefs.f90 !  by John Marelius !  preference setting handler !------------------------------------------------------------------------------! module PREFS implicit none !constants character ( * ), private , parameter :: MODULE_VERSION = '5.7' character ( * ), private , parameter :: MODULE_DATE = '2015-02-22' integer , private :: max_prefs , nprefs integer , parameter , private :: default_max = 20 integer , parameter :: PREF_LEN = 200 character ( len = 2 ), private :: separator type , private :: PREF character ( len = 40 ) :: name logical :: is_integer , is_real , is_string integer , pointer :: ival real , pointer :: rval character ( len = PREF_LEN ), pointer :: sval end type PREF type ( PREF ), private , allocatable :: p (:) !private procedures private :: lookup contains subroutine pref_initialize ( max ) !args integer , optional :: max if ( present ( max )) then max_prefs = max else max_prefs = default_max end if allocate ( p ( max_prefs )) p (:)% is_integer = . false . p (:)% is_real = . false . p (:)% is_string = . false . nprefs = 0 separator ( 1 : 1 ) = ' ' separator ( 2 : 2 ) = char ( 9 ) end subroutine pref_initialize logical function pref_add ( name , ival , rval , sval ) !args character ( * ), target :: name integer , target , optional :: ival real , target , optional :: rval character ( * ), target , optional :: sval if ( nprefs == max_prefs ) then pref_add = . false . else nprefs = nprefs + 1 p ( nprefs )% name = name if ( present ( ival )) then p ( nprefs )% is_integer = . true . p ( nprefs )% ival => ival pref_add = . true . elseif ( present ( rval )) then p ( nprefs )% is_real = . true . p ( nprefs )% rval => rval pref_add = . true . elseif ( present ( sval )) then p ( nprefs )% is_string = . true . p ( nprefs )% sval => sval pref_add = . true . else pref_add = . false . end if end if end function pref_add subroutine pref_list ( heading ) !args character ( * ), optional :: heading !locals integer :: i if ( present ( heading )) then write ( * , '(a)' ) heading end if 10 format ( i2 , '.' , 1 x , a , t40 , i10 ) 20 format ( i2 , '.' , 1 x , a , t40 , f10 . 4 ) 30 format ( i2 , '.' , 1 x , a , t40 , a ) do i = 1 , nprefs if ( p ( i )% is_integer ) then write ( * , 10 ) i , p ( i )% name , p ( i )% ival elseif ( p ( i )% is_real ) then write ( * , 20 ) i , p ( i )% name , p ( i )% rval elseif ( p ( i )% is_string ) then write ( * , 30 ) i , p ( i )% name , p ( i )% sval end if end do end subroutine pref_list logical function pref_set ( string , inval ) !args character ( * ), intent ( in ) :: string character ( * ), intent ( in ), optional :: inval !locals integer :: i character ( len = 40 ) :: name character ( len = PREF_LEN ) :: value integer :: name_end , readstat character ( len = PREF_LEN ) :: line if ( present ( inval )) then name = string value = inval else !split string into name and value line = adjustl ( string ) name_end = scan ( line , separator ) - 1 if ( name_end == - 1 ) name_end = len_trim ( line ) name = line ( 1 : name_end ) if ( name_end > len_trim ( line ) - 2 ) then value = '' else value = line ( name_end + 2 : len_trim ( line )) end if end if pref_set = . false . i = lookup ( name ) if ( i > 0 ) then if ( p ( i )% is_integer ) then read ( value , * , iostat = readstat ) p ( i )% ival if ( readstat == 0 ) pref_set = . true . elseif ( p ( i )% is_real ) then read ( value , * , iostat = readstat ) p ( i )% rval if ( readstat == 0 ) pref_set = . true . elseif ( p ( i )% is_string ) then p ( i )% sval = adjustl ( trim ( value )) pref_set = . true . end if if (. not . pref_set ) then write ( * , 900 ) adjustl ( trim ( value )) 900 format ( '>>>>> ERROR: Invalid value ' , a ) end if end if end function pref_set integer function lookup ( name ) !args character ( * ), intent ( in ) :: name !locals integer :: i integer :: readstat lookup = 0 do i = 1 , nprefs if ( p ( i )% name == name ) then lookup = i exit end if end do if ( lookup == 0 ) then !try numeric read ( name , * , iostat = readstat ) i if ( readstat == 0 . and . i >= 1 . and . i <= nprefs ) then lookup = i else write ( * , 910 ) trim ( name ) 910 format ( 'There is no preference named ' , a ) end if end if end function lookup end module PREFS","tags":"","loc":"sourcefile/prefs.f90.html","title":"prefs.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  module: prep.f90 !  by Johan Aqvist & John Marelius !  topology preparation, solvation, validation and PDB I/O !------------------------------------------------------------------------------! module prep use trj use parse use prmfile use indexer use prefs use maskmanip implicit none !constants character ( * ), private , parameter :: MODULE_VERSION = '5.7' character ( * ), private , parameter :: MODULE_DATE = '2015-02-22' !library !max number of library entries integer , parameter :: max_entry = 1000 !max atoms in a residue (only used when reading PDB file) integer , parameter :: max_atlib = 500 integer , parameter :: max_cgplib = 100 integer , parameter :: max_atcgplib = 100 !FF parameters integer , parameter :: max_old_atyps = 100 !Extra bonds(S-S bridges etc.) integer , parameter :: max_extrabnd = 100 !Topology integer , parameter :: max_lib = 1000 integer , parameter :: max_long = 10000 integer , parameter :: max_conn = 10 !default values for user-settable variables !minimum solvent - solute heavy atom distance for solvation real , target :: solvent_pack = 2.4 !average heavy atom number density of proteins real , target :: rho_solute = 0.05794 ! atoms / A**3 !maximum cross-linking bond distance real , target :: max_xlink = 2.1 character ( len = 200 ), target :: solvent_names = '' !Random numbers for H generation integer , target :: random_seed_solute = 179857 integer , target :: random_seed_solvent = 758971 !variables !  Library information !------------------------------------------------------------------------------- type lib_bond_type integer ( AI ) :: i , j end type lib_bond_type !for explicit improper definitions +/- and 4-char. atom names type lib_imp_type character ( len = 1 + 4 ) :: i , j , k , l end type lib_imp_type type lib_rule_type integer :: kind integer :: atom ( 4 ) real :: value end type lib_rule_type integer , parameter :: build_rule_torsion = 1 type lib_entry_type integer :: nat , nbnd , nimp , ncgp , nrules integer :: head , tail logical :: hetatm , solvent real :: density character ( len = 4 ) :: nam character ( len = 8 ) :: sybyltype character ( len = 4 ), pointer :: atnam (:) character ( len = keylength ), pointer :: tac_lib (:) real , pointer :: crg_lib (:) type ( lib_rule_type ), pointer :: rules (:) type ( lib_bond_type ), pointer :: bnd (:) type ( lib_imp_type ), pointer :: imp (:) integer ( ai ), pointer :: natcgp (:) integer ( ai ), pointer :: switch (:) integer ( ai ), pointer :: atcgp (:,:) end type lib_entry_type integer :: nlibres type ( lib_entry_type ), target :: lib ( max_entry ) ! topology generation flags !------------------------------------------------------------------------------- logical :: have_prm_file_name = . false . logical :: have_solute_sphere = . false . logical :: have_title = . false . logical :: have_solvent_boundary = . false . logical :: boundary_set = . false . !     FF parameter information ! --- Bond parameters integer :: nbnd_prm integer :: nbnd_types type bond_type_type character ( len = keylength ) :: taci , tacj integer :: cod end type bond_type_type type bond_prm_type type ( bondlib_type ) :: prm character ( len = 2 ) :: SYBYLtype end type bond_prm_type type ( bond_type_type ), allocatable :: bnd_types (:) type ( bond_prm_type ), allocatable :: bnd_prm (:) ! --- Angle parameters type angle_type_type character ( len = keylength ) :: taci , tacj , tack integer :: cod end type angle_type_type type ( angle_type_type ), allocatable :: ang_types (:) type ( anglib_type ), allocatable :: ang_prm (:) integer :: nang_types integer :: nang_prm ! --- torsion parameters type torsion_type_type character ( len = keylength ) :: taci , tacj , tack , tacl integer :: cod end type torsion_type_type type ( torsion_type_type ), allocatable :: tor_types (:) type ( torlib_type ), allocatable :: tor_prm (:) integer :: ntor_types integer :: ntor_prm type tor_codes integer :: ncod integer :: cod ( 10 ) end type tor_codes ! --- improper torsion parameters type imp_prm_type character ( len = keylength ) :: taci , tacj , tack , tacl type ( implib_type ) :: prm end type imp_prm_type type ( imp_prm_type ), allocatable :: imp_prm (:) integer :: nimp_prm logical :: imp_explicit !explicit or automatic defs ! --- coordinate information integer :: natom , nat_wat , nwat character ( len = 100 ) :: coord_source = '' character ( len = 80 ) :: auto_name = '' integer , parameter :: trj_unit = 17 integer :: trj_frame = 0 character ( len = 180 ) :: trj_filnam type ( mask_type ) :: mask ! --- extra bonds(s-s bridges etc.) integer :: nextrabnd type ( bond_type ) :: extrabnd ( max_extrabnd ) !     things needed for topology generation !----------------------------------------------------------------------- logical , allocatable :: makeh (:) integer , allocatable :: nconn (:) integer , allocatable :: iconn (:,:) real ( 8 ) :: pi , deg2rad !temporary storage for solvent coordinates real ( 8 ), allocatable :: xw (:,:,:) !solvent coordinates zyx,atom,molecule !flag for solvent molecules not clashing with any solute heavy atom logical , allocatable :: keep (:) !residue code for solvent integer :: irc_solvent !residue name for solvent character ( len = 4 ) :: solvent_name ! --- flag to keep track of missing parameters without bailing out logical :: topo_ok = . false . logical :: ff_ok = . false . !       memory management integer , private :: alloc_status !private subroutine private :: check_alloc contains !------------------------------------------------------------------------------! ! subroutine: prep_startup ! !------------------------------------------------------------------------------! subroutine prep_startup logical :: l !initialize used modules call topo_startup ! empty call prmfile_startup ! empty call parse_startup ! some code call index_startup ! empty !initialize preference module & add user-settable variables call pref_initialize () !        ! allocates mem for p(:) l = pref_add ( 'solvent_pack' , rval = solvent_pack ) l = pref_add ( 'solvent_names' , sval = solvent_names ) l = pref_add ( 'solute_density' , rval = rho_solute ) l = pref_add ( 'random_seed_solute' , ival = random_seed_solute ) l = pref_add ( 'random_seed_solvent' , ival = random_seed_solvent ) pi = 4.0 * atan ( 1.0 ) deg2rad = pi / 18 0.0 !make sure all arrays are allocated so that solvation can be done !without reading solute pdb file call allocate_for_pdb ( 1 , 1 , 1 ) call cleartop ! clears pdb filename and prm name call clearpdb !get rid of old PDB data end subroutine prep_startup !------------------------------------------------------------------------------! ! subroutine: allocate_for_pdb ! !------------------------------------------------------------------------------! subroutine allocate_for_pdb ( atoms , residues , molecules ) !arguments integer , intent ( in ) :: atoms , residues , molecules allocate ( xtop ( 3 * atoms ), heavy ( atoms ), makeH ( atoms ), & res ( residues ), istart_mol ( molecules ), & stat = alloc_status ) if ( alloc_status /= 0 ) then write ( * , * ) 'ERROR: Out of memory when allocating arrays for new atoms' stop 255 end if end subroutine allocate_for_pdb !------------------------------------------------------------------------------! ! subroutine: prep_shutdown ! !------------------------------------------------------------------------------! subroutine prep_shutdown call topo_deallocate call index_shutdown call mask_finalize ( mask ) call trj_shutdown end subroutine prep_shutdown !------------------------------------------------------------------------------! ! subroutine: clearlib ! !------------------------------------------------------------------------------! subroutine clearlib lib_files = '' nlibres = 0 end subroutine clearlib !------------------------------------------------------------------------------! ! subroutine: check_alloc ! !------------------------------------------------------------------------------! subroutine check_alloc ( message ) !arguments character ( * ) message if ( alloc_status . ne . 0 ) then write ( * , * ) & '>>> Out of memory trying to allocate ' , message stop 255 end if end subroutine check_alloc !------------------------------------------------------------------------------! ! subroutine: addbond ! !------------------------------------------------------------------------------! subroutine addbond ! *** local variables integer :: ia , ja real ( 8 ) :: bond_dist , rij ( 3 ) character ( len = 80 ) :: reply integer :: readstat call get_string_arg ( reply , & '-----> First atom (number or residue:atom_name): ' ) if ( scan ( reply , ':' ) > 0 ) then !got res:at ia = get_atom_from_descriptor ( reply ) if ( ia == 0 ) then write ( * , 910 ) trim ( reply ) 910 format ( '>>>>> ERROR: Could not find atom ' , a ) return end if else !got atom number read ( reply , * , iostat = readstat ) ia if ( readstat /= 0 ) then write ( * , 910 ) trim ( reply ) return end if end if if ( ia > nat_pro . or . ia < 1 ) then write ( * , '(a)' ) 'Out of range!' return end if call get_string_arg ( reply , & '-----> Second atom (number or residue:atom_name): ' ) if ( scan ( reply , ':' ) > 0 ) then !got res:at ja = get_atom_from_descriptor ( reply ) if ( ja == 0 ) then write ( * , 910 ) trim ( reply ) return end if else !got atom number read ( reply , * , iostat = readstat ) ja if ( readstat /= 0 ) then write ( * , 910 ) trim ( reply ) return end if end if if ( ja > nat_pro . or . ja < 1 ) then write ( * , '(a)' ) 'Out of range!' return elseif ( ja == ia ) then write ( * , '(a)' ) 'First and second atom must be different!' return end if rij (:) = xtop ( 3 * ia - 2 : 3 * ia ) - xtop ( 3 * ja - 2 : 3 * ja ) bond_dist = sqrt ( dot_product ( rij , rij )) if ( bond_dist > max_xlink ) then write ( * , 100 ) bond_dist 100 format ( '>>> WARNING: Bond distance is' , f6 . 2 , ' A.' ) call get_string_arg ( reply , '-----> Make bond anyway (y/n)? ' ) call upcase ( reply ) if ( reply /= 'Y' . and . reply /= 'YES' ) then return end if end if if ( nextrabnd < max_extrabnd ) then nextrabnd = nextrabnd + 1 extrabnd ( nextrabnd )% i = ia extrabnd ( nextrabnd )% j = ja else write ( * , 900 ) max_extrabnd 900 format ( '>>>>> ERROR: Too many extra bonds. (Max ' , i5 , ')' ) end if end subroutine addbond !------------------------------------------------------------------------------! ! subroutine: clearbond ! !------------------------------------------------------------------------------! subroutine clearbond !clear extra bonds nextrabnd = 0 end subroutine clearbond !------------------------------------------------------------------------------! ! subroutine: angle_ene ! !------------------------------------------------------------------------------! subroutine angle_ene ( emax , nlarge , av_ene ) ! *** local variables integer i , j , k , ia , ic , istart , iend , i3 , j3 , k3 , nlarge real rji ( 3 ), rjk ( 3 ), bji , bjk , scp , angle , da , ae , dv , f1 , di ( 3 ),& dk ( 3 ) real emax , av_ene istart = 1 iend = nangles nlarge = 0 av_ene = 0 do ia = istart , iend i = ang ( ia )% i j = ang ( ia )% j k = ang ( ia )% k ic = ang ( ia )% cod if ( ic == 0 ) then !missing parameter write ( * , '(4i5,1x,a)' ) ia , i , j , k , 'MISSING PARAMETERS' cycle end if i3 = i * 3 - 3 j3 = j * 3 - 3 k3 = k * 3 - 3 rji ( 1 ) = xtop ( i3 + 1 ) - xtop ( j3 + 1 ) rji ( 2 ) = xtop ( i3 + 2 ) - xtop ( j3 + 2 ) rji ( 3 ) = xtop ( i3 + 3 ) - xtop ( j3 + 3 ) rjk ( 1 ) = xtop ( k3 + 1 ) - xtop ( j3 + 1 ) rjk ( 2 ) = xtop ( k3 + 2 ) - xtop ( j3 + 2 ) rjk ( 3 ) = xtop ( k3 + 3 ) - xtop ( j3 + 3 ) bji = sqrt ( rji ( 1 ) ** 2 + rji ( 2 ) ** 2 + rji ( 3 ) ** 2 ) bjk = sqrt ( rjk ( 1 ) ** 2 + rjk ( 2 ) ** 2 + rjk ( 3 ) ** 2 ) scp = ( rji ( 1 ) * rjk ( 1 ) + rji ( 2 ) * rjk ( 2 ) + rji ( 3 ) * rjk ( 3 ) ) scp = scp / ( bji * bjk ) if ( scp > 1.0 ) scp = 1.0 if ( scp < - 1.0 ) scp = - 1.0 angle = acos ( scp ) da = angle - anglib ( ic )% ang0 * pi / 18 0. ae = 0.5 * anglib ( ic )% fk * da ** 2 av_ene = av_ene + ae if ( ae > emax ) then nlarge = nlarge + 1 write ( * , '(5i5,4f8.2)' ) ia , i , j , k , ic , anglib ( ic )% fk ,& anglib ( ic )% ang0 , angle * 18 0. / pi , ae endif enddo if ( nangles /= 0 ) av_ene = av_ene / real ( nangles ) !....................................................................... end subroutine angle_ene !------------------------------------------------------------------------------! ! function: anglecode ! !------------------------------------------------------------------------------! integer function anglecode ( taci , tacj , tack ) !arguments character ( * ), intent ( in ) :: taci , tacj , tack ! *** local variables integer i character ( len = KEYLENGTH ) :: ti , tj , tk ti = wildcard_tac ( taci ) tj = wildcard_tac ( tacj ) tk = wildcard_tac ( tack ) !....................................................................... do i = 1 , nang_types if (( ti == ang_types ( i )% taci . and . tj == ang_types ( i )% tacj & . and . tk == ang_types ( i )% tack ) . or . ( ti == ang_types ( i )% tack & . and . tj == ang_types ( i )% tacj . and . tk == ang_types ( i )% taci )) then anglecode = ang_types ( i )% cod return endif enddo anglecode = 0 write ( * , '(a,3(1x,a8))' ) '>>> Missing angle type for atom types' & , ti , tj , tk topo_ok = . false . !....................................................................... end function anglecode !------------------------------------------------------------------------------! ! subroutine: bond_ene ! !------------------------------------------------------------------------------! subroutine bond_ene ( emax , nlarge , av_ene ) ! *** local variables integer i , j , ib , ic , istart , iend , i3 , j3 , nlarge real rij ( 3 ), b , db , be , dv , emax , av_ene !....................................................................... istart = 1 iend = nbonds nlarge = 0 av_ene = 0 do ib = istart , iend i = bnd ( ib )% i j = bnd ( ib )% j ic = bnd ( ib )% cod if ( ic == 0 ) then !missing parameter write ( * , '(3i5,1x,a)' ) ib , i , j , 'MISSING PARAMETERS' cycle end if i3 = i * 3 - 3 j3 = j * 3 - 3 rij ( 1 ) = xtop ( j3 + 1 ) - xtop ( i3 + 1 ) rij ( 2 ) = xtop ( j3 + 2 ) - xtop ( i3 + 2 ) rij ( 3 ) = xtop ( j3 + 3 ) - xtop ( i3 + 3 ) b = sqrt ( rij ( 1 ) ** 2 + rij ( 2 ) ** 2 + rij ( 3 ) ** 2 ) db = b - bondlib ( ic )% bnd0 be = 0.5 * bondlib ( ic )% fk * db ** 2 av_ene = av_ene + be if ( be > emax ) then nlarge = nlarge + 1 write ( * , '(4i5,4f8.2)' ) ib , i , j , ic , bondlib ( ic )% fk ,& bondlib ( ic )% bnd0 , b , be endif enddo if ( nbonds /= 0 ) av_ene = av_ene / real ( nbonds ) return !....................................................................... end subroutine bond_ene !------------------------------------------------------------------------------! ! function: wildcard_tac ! !------------------------------------------------------------------------------! character ( keylength ) function wildcard_tac ( taci ) !arguments character ( * ), intent ( in ) :: taci ! *** local variables integer :: hash_pos !find # sign and truncate there - will match anything after hash_pos = scan ( taci , '#' ) if ( hash_pos > 0 ) then wildcard_tac = taci ( 1 : hash_pos - 1 ) else wildcard_tac = taci endif end function wildcard_tac !------------------------------------------------------------------------------! ! function: bondcode ! !------------------------------------------------------------------------------! integer function bondcode ( taci , tacj ) !arguments character ( * ), intent ( in ) :: taci , tacj ! *** local variables character ( len = keylength ) :: ti , tj integer i integer :: leni , lenj integer :: score , max_score = 0 , max_cod !....................................................................... ti = wildcard_tac ( taci ) tj = wildcard_tac ( tacj ) do i = 1 , nbnd_types if ( ti == bnd_types ( i )% taci . and . tj == bnd_types ( i )% tacj & . or . tj == bnd_types ( i )% taci . and . ti == bnd_types ( i )% tacj ) then bondcode = bnd_types ( i )% cod return endif enddo write ( * , '(a,2(1x,a8))' ) '>>> Missing bond type for atom types' & , ti , tj topo_ok = . false . bondcode = 0 !....................................................................... end function bondcode !------------------------------------------------------------------------------! ! subroutine: changeimp ! !------------------------------------------------------------------------------! subroutine changeimp ! *** local variables integer ii , ip , i , j , k , l , noptimp , nchange , nlarge real emax , av_ene !....................................................................... write ( * , '(/,a)' ) '      Two options:  1. change specified impropers' write ( * , '(a)' ) '                                      2. change all with E > Emax(k <---> l)' CALL prompt ( '-----> Which option [1/2]: ' ) READ ( * , * ) noptimp if ( noptimp == 1 ) then CALL prompt ( '-----> No. of impropers to be changed = ' ) READ ( * , * ) nchange do ii = 1 , nchange CALL prompt ( '-----> Give: Impr-no., i, j, k, l : ' ) READ ( * , * ) ip , i , j , k , l imp ( ip )% i = i imp ( ip )% j = j imp ( ip )% k = k imp ( ip )% l = l enddo endif if ( noptimp == 2 ) then CALL prompt ( '-----> Give an energy threshold [kcal/mol] = ' ) READ ( * , * ) emax nchange = 0 CALL impr_ene ( emax , nchange , av_ene , 1 ) write ( * , '(a,f8.2)' ) '< impr. tors energy > = ' , av_ene write ( * , '(a,i5)' ) 'No. of changed imps   = ' , nchange CALL impr_ene ( emax , nlarge , av_ene , 0 ) write ( * , '(a,i5)' ) 'No. above Emax now        = ' , nlarge write ( * , '(a,f8.2)' ) '< impr. tors energy > = ' , av_ene endif write ( * , * ) return !....................................................................... end subroutine changeimp subroutine checkangs ! *** local variables integer nlarge real emax , av_ene !....................................................................... write ( * , * ) emax = get_real_arg ( '-----> Give an energy threshold [kcal/mol] = ' ) write ( * , '(/,a)' ) 'angle  atoms i--j--k code force-k   ang_0   angle  energy' CALL angle_ene ( emax , nlarge , av_ene ) write ( * , '(a,i5)' ) 'No. above Emax   = ' , nlarge write ( * , '(a,f8.2)' ) '< angle energy > = ' , av_ene write ( * , * ) end subroutine checkangs subroutine checkbonds ! *** local variables integer nlarge real emax , av_ene !....................................................................... write ( * , * ) emax = get_real_arg ( '-----> Give an energy threshold [kcal/mol] = ' ) write ( * , '(/,a)' ) ' bond atoms i-j code force-k  bond_0   dist.  energy' CALL bond_ene ( emax , nlarge , av_ene ) write ( * , '(a,i5)' ) 'No. above Emax   = ' , nlarge write ( * , '(a,f8.2)' ) '< bond energy >  = ' , av_ene write ( * , * ) end subroutine checkbonds subroutine checkimps ! *** local variables integer nlarge real emax , av_ene !....................................................................... write ( * , * ) emax = get_real_arg ( '-----> Give an energy threshold [kcal/mol] = ' ) write ( * , '(/,a)' ) & 'impr atoms i--j--k--l    code force-k   imp_0     phi  energy' CALL impr_ene ( emax , nlarge , av_ene , 0 ) write ( * , '(a,i5)' ) 'No. above Emax            = ' , nlarge write ( * , '(a,f8.2)' ) '< impr. tors energy > = ' , av_ene write ( * , * ) return !....................................................................... end subroutine checkimps subroutine checktors ! *** local variables integer nlarge real emax , av_ene !....................................................................... write ( * , * ) emax = get_real_arg ( '-----> Give an energy threshold [kcal/mol] = ' ) write ( * , '(/,a,a)' ) ' tors    atoms i--j--k--l code force-k   mult.   delta' , '        phi  energy' CALL tors_ene ( emax , nlarge , av_ene ) write ( * , '(a,i5)' ) 'No. above Emax     = ' , nlarge write ( * , '(a,f8.2)' ) '< torsion energy > = ' , av_ene write ( * , * ) return !....................................................................... end subroutine checktors function cross_product ( a , b ) real ( 8 ) :: a ( 3 ), b ( 3 ), cross_product ( 3 ) cross_product ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross_product ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross_product ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end function cross_product subroutine xlink !add cross-linking bonds like SS-bridges !locals integer :: ires , jres , iat , jat , i , j , b integer :: irc , jrc real :: d2 character ( len = 1 ) :: reply if (. not . check_residues ()) then return end if if (. not . topo_ok ) then write ( * , 90 ) 90 format ( 'Making solute bond list.' ) call make_solute_bonds end if write ( * , 92 ) max_xlink 92 format ( 'Searching for non-bonded heavy atom pairs closer than' , f6 . 2 , ' A.' ) !loop over all residue pairs do ires = 1 , ( nres_solute - 1 ) irc = res ( ires )% irc do jres = ires + 1 , nres_solute jrc = res ( jres )% irc do iat = 1 , lib ( irc )% nat i = iat + res ( ires )% start - 1 if (. not . heavy ( i )) cycle !skip hydrogens jloop : do jat = 1 , lib ( jrc )% nat - 1 j = jat + res ( jres )% start - 1 if (. not . heavy ( j )) cycle !skip hydrogens !check distance d2 = ( xtop ( 3 * i - 2 ) - xtop ( 3 * j - 2 )) ** 2 + & ( xtop ( 3 * i - 1 ) - xtop ( 3 * j - 1 )) ** 2 + ( xtop ( 3 * i ) - xtop ( 3 * j )) ** 2 if ( d2 < max_xlink ** 2 ) then !found atom pair within limit �, loop over all bonds do b = 1 , nbonds if ( bnd ( b )% i == i . and . bnd ( b )% j == j ) cycle jloop if ( bnd ( b )% i == j . and . bnd ( b )% j == i ) cycle jloop end do !By now we know the atoms are not bonded write ( * , 100 , advance = 'no' ) i , trim ( lib ( irc )% nam ), & ires , trim ( lib ( irc )% atnam ( iat )), & j , trim ( lib ( jrc )% nam ), jres , & trim ( lib ( jrc )% atnam ( jat )), sqrt ( d2 ) !add read ( * , * ) reply if ( reply == 'N' . or . reply == 'n' ) cycle if ( nextrabnd < max_extrabnd ) then nextrabnd = nextrabnd + 1 extrabnd ( nextrabnd )% i = i extrabnd ( nextrabnd )% j = j else write ( * , 900 ) max_extrabnd 900 format ( '>>>>> ERROR: Too many extra bonds. (Max ' , i5 , ')' ) end if end if end do jloop end do end do end do !issue a warning if the topology was already made. if ( nextrabnd > 0 ) then write ( * , 110 ) nextrabnd 110 format ( i3 , ' bonds were added.' ) if ( topo_ok ) then write ( * , 120 ) end if 120 format ( 'You need to regenerate the topology with the added bonds.' ) end if 100 format ( 'Atoms' , i6 , 1 x , a , 1 x , i5 , ':' , a , ' and' , i6 , 1 x , a , 1 x , i5 , ':' , a , ' are' , f5 . 2 , ' A apart. Connect [Y/n]?' ) end subroutine xlink integer function impcode ( taci , tacj , tack , tacl ) !arguments character ( KEYLENGTH ) :: taci , tacj , tack , tacl ! *** local variables integer i character ( KEYLENGTH ) :: ti , tj , tk , tl logical :: found1 , found2 , found3 , found4 ti = wildcard_tac ( taci ) tj = wildcard_tac ( tacj ) tk = wildcard_tac ( tack ) tl = wildcard_tac ( tacl ) !....................................................................... !find a match with four types (i and j and k and l) !       do i = 1, nimp_prm !               if( (ti == imp_prm(i)%taci .or. & !                        ti == imp_prm(i)%tacj .or. & !                        ti == imp_prm(i)%tack .or. & !                        ti == imp_prm(i)%tacl) .and. & ! !                       (tj == imp_prm(i)%taci .or. & !                        tj == imp_prm(i)%tacj .or. & !                        tj == imp_prm(i)%tack .or. & !                        tj == imp_prm(i)%tacl) .and. & ! !                       (tk == imp_prm(i)%taci .or. & !                        tk == imp_prm(i)%tacj .or. & !                        tk == imp_prm(i)%tack .or. & !                        tk == imp_prm(i)%tacl) .and. & ! !                       (tl == imp_prm(i)%taci .or. & !                        tl == imp_prm(i)%tacj .or. & !                        tl == imp_prm(i)%tack .or. & !                        tl == imp_prm(i)%tacl)) then ! !                       impcode = i !                       return !               endif !       enddo !find a match with four types (i and j and k and l) do i = 1 , nimp_prm found1 = . false . found2 = . false . found3 = . false . found4 = . false . if ( ti == imp_prm ( i )% taci ) then found1 = . true . else if ( ti == imp_prm ( i )% tacj ) then found2 = . true . else if ( ti == imp_prm ( i )% tack ) then found3 = . true . else if ( ti == imp_prm ( i )% tacl ) then found4 = . true . endif if ((. not . found1 ) . and . ( tj == imp_prm ( i )% taci )) then found1 = . true . else if ((. not . found2 ) . and . ( tj == imp_prm ( i )% tacj )) then found2 = . true . else if ((. not . found3 ) . and . ( tj == imp_prm ( i )% tack )) then found3 = . true . else if ((. not . found4 ) . and . ( tj == imp_prm ( i )% tacl )) then found4 = . true . endif if ((. not . found1 ) . and . ( tk == imp_prm ( i )% taci )) then found1 = . true . else if ((. not . found2 ) . and . ( tk == imp_prm ( i )% tacj )) then found2 = . true . else if ((. not . found3 ) . and . ( tk == imp_prm ( i )% tack )) then found3 = . true . else if ((. not . found4 ) . and . ( tk == imp_prm ( i )% tacl )) then found4 = . true . endif if ((. not . found1 ) . and . ( tl == imp_prm ( i )% taci )) then found1 = . true . else if ((. not . found2 ) . and . ( tl == imp_prm ( i )% tacj )) then found2 = . true . else if ((. not . found3 ) . and . ( tl == imp_prm ( i )% tack )) then found3 = . true . else if ((. not . found4 ) . and . ( tl == imp_prm ( i )% tacl )) then found4 = . true . endif if ( found1 . and . found2 . and . found3 . and . found4 ) then impcode = i return endif enddo !now we have to handle force fields differently select case ( ff_type ) case ( FF_GROMOS , FF_AMBER ) !find a match with three types (j and k and l) or !(i and j and k) do i = 1 , nimp_prm if ( imp_prm ( i )% taci == '' . and . imp_prm ( i )% tacl /= '' ) then ! for ?  A*  B  C   ... if (( tj == imp_prm ( i )% tacj . and . & tk == imp_prm ( i )% tack . and . & tl == imp_prm ( i )% tacl ) . or . & ( tj == imp_prm ( i )% tacj . and . & tk == imp_prm ( i )% tacl . and . & tl == imp_prm ( i )% tack ) . or . & ( tj == imp_prm ( i )% tacj . and . & ti == imp_prm ( i )% tack . and . & tl == imp_prm ( i )% tacl ) . or . & ( tj == imp_prm ( i )% tacj . and . & ti == imp_prm ( i )% tacl . and . & tl == imp_prm ( i )% tack ) . or . & ( tj == imp_prm ( i )% tacj . and . & ti == imp_prm ( i )% tack . and . & tk == imp_prm ( i )% tacl ) . or . & ( tj == imp_prm ( i )% tacj . and . & ti == imp_prm ( i )% tacl . and . & tk == imp_prm ( i )% tack )) then impcode = i return endif elseif ( imp_prm ( i )% taci /= '' . and . imp_prm ( i )% tacl == '' ) then ! and for A*  B  C  ?  (2nd half) ... if (( tj == imp_prm ( i )% taci . and . & tk == imp_prm ( i )% tacj . and . & tl == imp_prm ( i )% tack ) . or . & ( tj == imp_prm ( i )% taci . and . & tk == imp_prm ( i )% tack . and . & tl == imp_prm ( i )% tacj ) . or . & ( tj == imp_prm ( i )% taci . and . & tj == imp_prm ( i )% tacj . and . & ti == imp_prm ( i )% tack ) . or . & ( tj == imp_prm ( i )% taci . and . & tj == imp_prm ( i )% tack . and . & ti == imp_prm ( i )% tacj ) . or . & ( tj == imp_prm ( i )% taci . and . & tk == imp_prm ( i )% tacj . and . & ti == imp_prm ( i )% tack ) . or . & ( tj == imp_prm ( i )% taci . and . & tk == imp_prm ( i )% tack . and . & ti == imp_prm ( i )% tacj )) then impcode = i return endif endif enddo !find a match with two types (j and  (i or k or l)) do i = 1 , nimp_prm if ( imp_prm ( i )% taci == '' . and . imp_prm ( i )% tacl == '' ) then if (( tj == imp_prm ( i )% tacj . and . tl == imp_prm ( i )% tack ) . or . & ( tj == imp_prm ( i )% tack . and . tl == imp_prm ( i )% tacj ) . or . & ( tj == imp_prm ( i )% tacj . and . tk == imp_prm ( i )% tack ) . or . & ( tj == imp_prm ( i )% tack . and . tk == imp_prm ( i )% tacj ) . or . & ( tj == imp_prm ( i )% tacj . and . ti == imp_prm ( i )% tack ) . or . & ( tj == imp_prm ( i )% tack . and . ti == imp_prm ( i )% tacj ) . or . & ( tk == imp_prm ( i )% tacj . and . tl == imp_prm ( i )% tack ) . or . & ( tk == imp_prm ( i )% tack . and . tl == imp_prm ( i )% tacj ) . or . & ( tk == imp_prm ( i )% tacj . and . tj == imp_prm ( i )% tack ) . or . & ( tk == imp_prm ( i )% tack . and . tj == imp_prm ( i )% tacj ) . or . & ( tk == imp_prm ( i )% tacj . and . ti == imp_prm ( i )% tack ) . or . & ( tk == imp_prm ( i )% tack . and . ti == imp_prm ( i )% tacj )) then impcode = i return endif endif enddo !find a match with only type of j atom do i = 1 , nimp_prm if ( imp_prm ( i )% taci == '' . and . imp_prm ( i )% tack == '' . and . & imp_prm ( i )% tacl == '' ) then if ( tj == imp_prm ( i )% tacj ) then impcode = i return endif endif enddo case ( FF_CHARMM ) !find a match with three types (j and k and l) or !(i and j and k) do i = 1 , nimp_prm if ( imp_prm ( i )% taci /= '' . and . imp_prm ( i )% tacl == '' ) then if (( ti == imp_prm ( i )% taci . and . & tj == imp_prm ( i )% tacj . and . & tk == imp_prm ( i )% tack ) . or . & ( ti == imp_prm ( i )% taci . and . & tj == imp_prm ( i )% tack . and . & tk == imp_prm ( i )% tacj ) . or . & ( ti == imp_prm ( i )% taci . and . & tj == imp_prm ( i )% tacj . and . & tl == imp_prm ( i )% tack ) . or . & ( ti == imp_prm ( i )% taci . and . & tj == imp_prm ( i )% tack . and . & tl == imp_prm ( i )% tacj ) . or . & ( ti == imp_prm ( i )% taci . and . & tk == imp_prm ( i )% tacj . and . & tl == imp_prm ( i )% tack ) . or . & ( ti == imp_prm ( i )% taci . and . & tk == imp_prm ( i )% tack . and . & tl == imp_prm ( i )% tacj ) . or . & ( tl == imp_prm ( i )% taci . and . & tj == imp_prm ( i )% tacj . and . & tk == imp_prm ( i )% tack ) . or . & ( tl == imp_prm ( i )% taci . and . & tj == imp_prm ( i )% tack . and . & tk == imp_prm ( i )% tacj ) . or . & ( tl == imp_prm ( i )% taci . and . & tj == imp_prm ( i )% tacj . and . & ti == imp_prm ( i )% tack ) . or . & ( tl == imp_prm ( i )% taci . and . & tj == imp_prm ( i )% tack . and . & ti == imp_prm ( i )% tacj ) . or . & ( tl == imp_prm ( i )% taci . and . & tk == imp_prm ( i )% tacj . and . & ti == imp_prm ( i )% tack ) . or . & ( tl == imp_prm ( i )% taci . and . & tk == imp_prm ( i )% tack . and . & ti == imp_prm ( i )% tacj )) then impcode = i return endif endif enddo !find a match with two types (j and  (i or k or l)) do i = 1 , nimp_prm if ( imp_prm ( i )% taci == '' . and . imp_prm ( i )% tacl == '' ) then if (( ti == imp_prm ( i )% tacj . and . tl == imp_prm ( i )% tack ) . or . & ( ti == imp_prm ( i )% tack . and . tl == imp_prm ( i )% tacj ) . or . & ( ti == imp_prm ( i )% tacj . and . tk == imp_prm ( i )% tack ) . or . & ( ti == imp_prm ( i )% tack . and . tk == imp_prm ( i )% tacj ) . or . & ( ti == imp_prm ( i )% tacj . and . tj == imp_prm ( i )% tack ) . or . & ( ti == imp_prm ( i )% tack . and . tj == imp_prm ( i )% tacj ) . or . & ( tl == imp_prm ( i )% tacj . and . ti == imp_prm ( i )% tack ) . or . & ( tl == imp_prm ( i )% tack . and . ti == imp_prm ( i )% tacj ) . or . & ( tl == imp_prm ( i )% tacj . and . tk == imp_prm ( i )% tack ) . or . & ( tl == imp_prm ( i )% tack . and . tk == imp_prm ( i )% tacj ) . or . & ( tl == imp_prm ( i )% tacj . and . tj == imp_prm ( i )% tack ) . or . & ( tl == imp_prm ( i )% tack . and . tj == imp_prm ( i )% tacj )) then impcode = i return endif endif enddo !find a match with only type of j atom do i = 1 , nimp_prm if ( imp_prm ( i )% taci == '' . and . imp_prm ( i )% tack == '' . and . & imp_prm ( i )% tacl == '' ) then if ( ti == imp_prm ( i )% tacj ) then impcode = i return endif endif enddo end select impcode = 0 write ( * , '(a,4(1x,a8))' ) '>>> Missing improper type for atom types' , & ti , tj , tk , tl topo_ok = . false . !....................................................................... end function impcode subroutine impr_ene ( emax , nlarge , av_ene , mode ) ! *** local variables integer i , j , k , l , ip , ic , i3 , j3 , k3 , l3 , nlarge , mode real rji ( 3 ), rjk ( 3 ), rkl ( 3 ), rnj ( 3 ), rnk ( 3 ), bj , bk , scp , & phi , sgn , pe , dv , rki ( 3 ), rlj ( 3 ), dp ( 12 ), arg , f1 , di ( 3 ), & dl ( 3 ) real emax , av_ene !....................................................................... nlarge = 0 av_ene = 0 do ip = 1 , nimps i = imp ( ip )% i j = imp ( ip )% j k = imp ( ip )% k l = imp ( ip )% l ic = imp ( ip )% cod if ( ic == 0 ) then !missing parameter write ( * , '(5i5,1x,a)' ) ip , i , j , k , l , 'MISSING PARAMETERS' cycle end if i3 = i * 3 - 3 j3 = j * 3 - 3 k3 = k * 3 - 3 l3 = l * 3 - 3 rji ( 1 ) = xtop ( i3 + 1 ) - xtop ( j3 + 1 ) rji ( 2 ) = xtop ( i3 + 2 ) - xtop ( j3 + 2 ) rji ( 3 ) = xtop ( i3 + 3 ) - xtop ( j3 + 3 ) rjk ( 1 ) = xtop ( k3 + 1 ) - xtop ( j3 + 1 ) rjk ( 2 ) = xtop ( k3 + 2 ) - xtop ( j3 + 2 ) rjk ( 3 ) = xtop ( k3 + 3 ) - xtop ( j3 + 3 ) rkl ( 1 ) = xtop ( l3 + 1 ) - xtop ( k3 + 1 ) rkl ( 2 ) = xtop ( l3 + 2 ) - xtop ( k3 + 2 ) rkl ( 3 ) = xtop ( l3 + 3 ) - xtop ( k3 + 3 ) rnj ( 1 ) = rji ( 2 ) * rjk ( 3 ) - rji ( 3 ) * rjk ( 2 ) rnj ( 2 ) = rji ( 3 ) * rjk ( 1 ) - rji ( 1 ) * rjk ( 3 ) rnj ( 3 ) = rji ( 1 ) * rjk ( 2 ) - rji ( 2 ) * rjk ( 1 ) rnk ( 1 ) = - rjk ( 2 ) * rkl ( 3 ) + rjk ( 3 ) * rkl ( 2 ) rnk ( 2 ) = - rjk ( 3 ) * rkl ( 1 ) + rjk ( 1 ) * rkl ( 3 ) rnk ( 3 ) = - rjk ( 1 ) * rkl ( 2 ) + rjk ( 2 ) * rkl ( 1 ) bj = sqrt ( rnj ( 1 ) ** 2 + rnj ( 2 ) ** 2 + rnj ( 3 ) ** 2 ) bk = sqrt ( rnk ( 1 ) ** 2 + rnk ( 2 ) ** 2 + rnk ( 3 ) ** 2 ) scp = ( rnj ( 1 ) * rnk ( 1 ) + rnj ( 2 ) * rnk ( 2 ) + rnj ( 3 ) * rnk ( 3 ) ) / ( bj * bk ) if ( scp > 1.0 ) scp = 1.0 if ( scp < - 1.0 ) scp = - 1.0 phi = acos ( scp ) sgn = rjk ( 1 ) * ( rnj ( 2 ) * rnk ( 3 ) - rnj ( 3 ) * rnk ( 2 ) ) + rjk ( 2 )& * ( rnj ( 3 ) * rnk ( 1 ) - rnj ( 1 ) * rnk ( 3 ) ) + rjk ( 3 ) * ( rnj ( 1 ) & * rnk ( 2 ) - rnj ( 2 ) * rnk ( 1 ) ) if ( sgn < 0 ) phi = - phi ! ---   energy if ( imp_type == 1 ) then !harmonic arg = phi - implib ( ic )% imp0 * pi / 18 0. arg = arg - 2. * pi * nint ( arg / ( 2. * pi ) ) dv = implib ( ic )% fk * arg pe = 0.5 * dv * arg else !periodic arg = 2 * phi - implib ( ic )% imp0 * pi / 18 0. pe = implib ( ic )% fk * ( 1 + cos ( arg )) dv = - 2 * implib ( ic )% fk * sin ( arg ) end if av_ene = av_ene + pe if ( pe > emax ) then nlarge = nlarge + 1 if ( mode == 0 ) write ( * , '(6i5,5f8.2)' ) ip , i , j , k , l , ic , & implib ( ic )% fk , implib ( ic )% imp0 , phi * 18 0. / pi , pe if ( mode == 1 ) then imp ( ip )% i = i imp ( ip )% j = j imp ( ip )% k = l imp ( ip )% l = k endif endif enddo if ( nimps /= 0 ) av_ene = av_ene / real ( nimps ) !....................................................................... end subroutine impr_ene subroutine listres ! *** local variables integer i , iat , ires type ( LIB_ENTRY_TYPE ), pointer :: lp !....................................................................... ires = get_int_arg ( '-----> Residue number: ' ) if ( ires > nres . or . ires == 0 ) then write ( * , * ) 'Out of range!' return end if if (. not . check_residues ()) return lp => lib ( res ( ires )% irc ) write ( * , '(a,i5,a,a)' ) 'Residue ' , ires , ' is ' , res ( ires )% name write ( * , '(a)' ) 'Atom name  tac     charge ' do i = 1 , lp % nat iat = res ( ires )% start - 1 + i write ( * , '(i5,1x,a4,a8,f8.4)' ) iat , lp % atnam ( i ),& lp % tac_lib ( i ), lp % crg_lib ( i ) enddo write ( * , * ) end subroutine listres subroutine listseq ! *** local variables integer i !....................................................................... write ( * , '(a,/)' ) 'Sequence listing:' write ( * , 100 ) ( i , res ( i )% name , i = 1 , nres ) 100 format ( 9 ( i4 , '-' , a4 )) write ( * , * ) end subroutine listseq subroutine make14list ! *** local variables integer :: it , i , j , ioff , l n14nbrs = 0 n14long = 0 list14 (:, :) = . false . itloop : do it = 1 , ntors i = tor ( it )% i j = tor ( it )% l if ( i < j ) then ioff = j - i if ( ioff <= max_nbr_range ) then if (. not . list14 ( ioff , i )) then n14nbrs = n14nbrs + 1 list14 ( ioff , i ) = . true . end if ELSE do l = 1 , n14long if ( list14long ( 1 , l ) == i . and . list14long ( 2 , l ) == j ) then !it's already in here cycle itloop end if end do n14long = n14long + 1 list14long ( 1 , n14long ) = i list14long ( 2 , n14long ) = j endif ELSE ioff = i - j if ( ioff <= max_nbr_range ) then if (. not . list14 ( ioff , j )) then n14nbrs = n14nbrs + 1 list14 ( ioff , j ) = . true . end if ELSE do l = 1 , n14long if ( list14long ( 1 , l ) == j . and . list14long ( 2 , l ) == i ) then !it's already in here cycle itloop end if end do n14long = n14long + 1 list14long ( 1 , n14long ) = j list14long ( 2 , n14long ) = i endif endif enddo itloop write ( * , 100 ) n14nbrs write ( * , 110 ) n14long 100 format ( 'Made    ' , i6 , ' entries in the 1-4 neighbour list.' ) 110 format ( 'Made    ' , i6 , ' entries in the long-range 1-4 neighbour list.' ) !....................................................................... end subroutine make14list subroutine makeangles ! *** local variables integer ib , jb , ia , i , j , k , iaci , iacj , iack logical :: used ( nang_prm + max_extrabnd ) integer :: itrans ( nang_prm + max_extrabnd ) !....................................................................... nangles = 0 nangles_solute = 0 do ib = 1 , nbonds_solute - 1 !skip special bonds used only to specify shake constraints if ( bnd ( ib )% cod == 0 ) cycle if ( bondlib ( bnd ( ib )% cod )% fk == 0. ) cycle do jb = ib + 1 , nbonds_solute if ( bnd ( jb )% cod == 0 ) cycle if ( bondlib ( bnd ( jb )% cod )% fk == 0. ) cycle if ( bnd ( ib )% i == bnd ( jb )% i ) then nangles = nangles + 1 ang ( nangles )% i = bnd ( ib )% j ang ( nangles )% j = bnd ( ib )% i ang ( nangles )% k = bnd ( jb )% j elseif ( bnd ( ib )% i == bnd ( jb )% j ) then nangles = nangles + 1 ang ( nangles )% i = bnd ( ib )% j ang ( nangles )% j = bnd ( ib )% i ang ( nangles )% k = bnd ( jb )% i elseif ( bnd ( ib )% j == bnd ( jb )% i ) then nangles = nangles + 1 ang ( nangles )% i = bnd ( ib )% i ang ( nangles )% j = bnd ( ib )% j ang ( nangles )% k = bnd ( jb )% j elseif ( bnd ( ib )% j == bnd ( jb )% j ) then nangles = nangles + 1 ang ( nangles )% i = bnd ( ib )% i ang ( nangles )% j = bnd ( ib )% j ang ( nangles )% k = bnd ( jb )% i endif enddo enddo nangles_solute = nangles write ( * , 100 ) nangles_solute , 'solute' 100 format ( 'Made    ' , i6 , 1 x , a , ' angles.' ) do ib = nbonds_solute + 1 , nbonds - 1 !skip special bonds used only to specify shake constraints if ( bondlib ( bnd ( ib )% cod )% fk == 0. ) cycle do jb = ib + 1 , nbonds if ( bondlib ( bnd ( jb )% cod )% fk == 0. ) cycle if ( bnd ( ib )% i == bnd ( jb )% i ) then nangles = nangles + 1 ang ( nangles )% i = bnd ( ib )% j ang ( nangles )% j = bnd ( ib )% i ang ( nangles )% k = bnd ( jb )% j elseif ( bnd ( ib )% i == bnd ( jb )% j ) then nangles = nangles + 1 ang ( nangles )% i = bnd ( ib )% j ang ( nangles )% j = bnd ( ib )% i ang ( nangles )% k = bnd ( jb )% i elseif ( bnd ( ib )% j == bnd ( jb )% i ) then nangles = nangles + 1 ang ( nangles )% i = bnd ( ib )% i ang ( nangles )% j = bnd ( ib )% j ang ( nangles )% k = bnd ( jb )% j elseif ( bnd ( ib )% j == bnd ( jb )% j ) then nangles = nangles + 1 ang ( nangles )% i = bnd ( ib )% i ang ( nangles )% j = bnd ( ib )% j ang ( nangles )% k = bnd ( jb )% i endif enddo enddo write ( * , 100 ) nangles - nangles_solute , 'solvent' do ia = 1 , nangles ang ( ia )% cod = anglecode ( tac ( iac ( ang ( ia )% i )), tac ( iac ( ang ( ia )% j )), tac ( iac ( ang ( ia )% k ))) if ( ang ( ia )% cod == 0 ) then write ( * , * ) 'atoms: ' , ang ( ia )% i , ang ( ia )% j , ang ( ia )% k endif enddo ! --- Make a list of actual angle types to be used used (:) = . false . nangcod = 0 do i = 1 , nangles !       workaround to permit missing params if ( ang ( i )% cod /= 0 ) then if (. not . used ( ang ( i )% cod )) then used ( ang ( i )% cod ) = . true . nangcod = nangcod + 1 itrans ( ang ( i )% cod ) = nangcod !copy all parameters for this angle type from parameter list to top anglib ( nangcod ) = ang_prm ( ang ( i )% cod ) ang ( i )% cod = nangcod ELSE ang ( i )% cod = itrans ( ang ( i )% cod ) endif endif enddo end subroutine makeangles subroutine make_solute_bonds !make solute bond list !used only by xlink routine to make solute bond list to check new !bonds against !deallocate old bond list if ( allocated ( bnd )) deallocate ( bnd ) !allocate topology arrays (set max_atom etc call topo_set_max ( nat_pro , max_lib , max_long ) !make space for new topology allocate ( bnd ( max_bonds ), stat = alloc_status ) if ( alloc_status /= 0 ) then write ( * , * ) 'ERROR: Out of memory when allocating bond list' stop 255 end if nbonds = 0 !make solute bonds nbonds_solute = makesomebonds ( 1 , nres_solute ) end subroutine make_solute_bonds subroutine makebonds !locals integer :: nbonds_solvent , nbonds_extra integer :: i !clear bonds nbonds = 0 !make solute bonds nbonds_solute = makesomebonds ( 1 , nres_solute ) write ( * , 100 ) nbonds_solute , 'solute' 100 format ( 'Made    ' , i6 , 1 x , a , ' bonds.' ) !make extra bonds nbonds_extra = makeextrabonds () !extra bonds count as solute bonds nbonds_solute = nbonds_solute + nbonds_extra write ( * , 100 ) nbonds_extra , 'extra' !make solvent bonds nbonds_solvent = makesomebonds ( nres_solute + 1 , nres ) write ( * , 100 ) nbonds_solvent , 'solvent' end subroutine makebonds integer function makeextrabonds () !locals integer :: ix , ib , iaci , iacj character ( len = KEYLENGTH ) :: taci , tacj ! --- Add extra bonds like S-S bridges makeextrabonds = 0 extra : do ix = 1 , nextrabnd do ib = 1 , nbonds if (( bnd ( ib )% i == extrabnd ( ix )% i . and . bnd ( ib )% j == extrabnd ( ix )% j ) & . or . ( bnd ( ib )% j == extrabnd ( ix )% i & . and . bnd ( ib )% i == extrabnd ( ix )% j )) then write ( * , 8 ) extrabnd ( ix )% i , extrabnd ( ix )% j cycle extra end if end do nbonds = nbonds + 1 makeextrabonds = makeextrabonds + 1 bnd ( nbonds )% i = extrabnd ( ix )% i bnd ( nbonds )% j = extrabnd ( ix )% j taci = tac ( iac ( bnd ( nbonds )% i )) tacj = tac ( iac ( bnd ( nbonds )% j )) bnd ( nbonds )% cod = bondcode ( taci , tacj ) end do extra 8 format ( '>>> WARNING: Atoms' , i5 , ' and' , i5 , ' are already bonded.' ) end function makeextrabonds subroutine set_bondcodes !locals integer :: ib , iaci , iacj logical :: used ( nbnd_prm ) integer :: itrans ( nbnd_prm ) character ( len = keylength ) :: taci , tacj do ib = 1 , nbonds iaci = iac ( bnd ( ib )% i ) iacj = iac ( bnd ( ib )% j ) taci = tac ( iac ( bnd ( ib )% i )) tacj = tac ( iac ( bnd ( ib )% j )) bnd ( ib )% cod = bondcode ( taci , tacj ) IF ( bnd ( ib )% cod == 0 ) then WRITE ( * , * ) 'atoms: ' , bnd ( ib )% i , bnd ( ib )% j ENDIF end do !Make a list of actual bond types to be used used (:) = . false . nbndcod = 0 do ib = 1 , nbonds !       workaround to permit missing param's if ( bnd ( ib )% cod /= 0 ) then if (. not . used ( bnd ( ib )% cod )) then used ( bnd ( ib )% cod ) = . true . nbndcod = nbndcod + 1 itrans ( bnd ( ib )% cod ) = nbndcod bondlib ( nbndcod ) = bnd_prm ( bnd ( ib )% cod )% prm SYBYL_bond_type ( nbndcod ) = bnd_prm ( bnd ( ib )% cod )% SYBYLtype bnd ( ib )% cod = nbndcod ELSE bnd ( ib )% cod = itrans ( bnd ( ib )% cod ) endif endif enddo end subroutine set_bondcodes integer function makesomebonds ( startres , endres ) !arguments integer :: startres , endres ! *** local variables integer :: i , ib , ires , imol makesomebonds = 0 if ( startres > endres ) return !if no solvent !determine starting molecule imol = 0 do i = 1 , nmol if ( istart_mol ( i ) == res ( startres )% start ) exit imol = imol + 1 end do if ( imol >= nmol ) then write ( * , '(a)' ) '>>>>> ERROR: Inconsistent molecule/residue start atoms' return end if do ires = startres , endres ! ---   start new molecule or attach to chain if ( nmol > imol . and . res ( ires )% start == istart_mol ( imol + 1 ) ) then !it is a new molecule imol = imol + 1 elseif ( lib ( res ( ires - 1 )% irc )% tail > 0 . and . & lib ( res ( ires )% irc )% head > 0 ) then !make tail-to-head bond nbonds = nbonds + 1 makesomebonds = makesomebonds + 1 bnd ( nbonds )% i = res ( ires - 1 )% start - 1 + lib ( res ( ires - 1 )% irc )% tail bnd ( nbonds )% j = res ( ires )% start - 1 + lib ( res ( ires )% irc )% head endif ! ---   Build bonds in the residue do i = 1 , lib ( res ( ires )% irc )% nbnd nbonds = nbonds + 1 makesomebonds = makesomebonds + 1 bnd ( nbonds )% i = res ( ires )% start - 1 + lib ( res ( ires )% irc )% bnd ( i )% i bnd ( nbonds )% j = res ( ires )% start - 1 + lib ( res ( ires )% irc )% bnd ( i )% j enddo enddo !....................................................................... end function makesomebonds subroutine makeexlist ! *** local variables integer ib , ia , i , j , ioff !....................................................................... nexnbrs = 0 nexlong = 0 listex (:, :) = . false . do ib = 1 , nbonds i = bnd ( ib )% i j = bnd ( ib )% j if ( i < j ) then ioff = j - i if ( ioff <= max_nbr_range ) then nexnbrs = nexnbrs + 1 listex ( ioff , i ) = . true . ELSE nexlong = nexlong + 1 listexlong ( 1 , nexlong ) = i listexlong ( 2 , nexlong ) = j endif ELSE ioff = i - j if ( ioff <= max_nbr_range ) then nexnbrs = nexnbrs + 1 listex ( ioff , j ) = . true . ELSE nexlong = nexlong + 1 listexlong ( 1 , nexlong ) = j listexlong ( 2 , nexlong ) = i endif endif enddo do ia = 1 , nangles i = ang ( ia )% i j = ang ( ia )% k if ( i < j ) then ioff = j - i if ( ioff <= max_nbr_range ) then nexnbrs = nexnbrs + 1 listex ( ioff , i ) = . true . ELSE nexlong = nexlong + 1 listexlong ( 1 , nexlong ) = i listexlong ( 2 , nexlong ) = j endif ELSE ioff = i - j if ( ioff <= max_nbr_range ) then nexnbrs = nexnbrs + 1 listex ( ioff , j ) = . true . ELSE nexlong = nexlong + 1 listexlong ( 1 , nexlong ) = j listexlong ( 2 , nexlong ) = i endif endif enddo write ( * , 100 ) nexnbrs write ( * , 110 ) nexlong 100 format ( 'Made    ' , i6 , ' entries in list of excluded neighbours.' ) 110 format ( 'Made    ' , i6 , ' entries in list of long-range excluded neighbours.' ) return !....................................................................... end subroutine makeexlist subroutine makehyds !local variables integer :: i , nH_solute , nH_solvent , nH_required real :: r integer :: atom , residue nH_required = 0 !reassign heavy atom flag based on masses from parameter file do i = 1 , nat_pro heavy ( i ) = . false . if ( iaclib ( iac ( i ))% mass >= 4.0 ) heavy ( i ) = . true . if ( makeH ( i )) nH_required = nH_required + 1 enddo r = randm ( random_seed_solute , seed_only = . true .) nH_solute = 0 do residue = 1 , nres_solute do atom = res ( residue )% start , & res ( residue )% start + lib ( res ( residue )% irc )% nat - 1 nH_solute = nH_solute + genH ( atom , residue ) end do end do write ( * , 100 ) nH_solute , 'solute' 100 format ( 'Made    ' , i6 , 1 x , a , ' hydrogens.' ) !use a separate random number sequence for solvent r = randm ( random_seed_solvent , seed_only = . true .) nH_solvent = 0 do residue = nres_solute + 1 , nres do atom = res ( residue )% start , & res ( residue )% start + lib ( res ( residue )% irc )% nat - 1 nH_solvent = nH_solvent + genH ( atom , residue ) end do end do write ( * , 100 ) nH_solvent , 'solvent' if ( nH_solute + nH_solvent /= nH_required ) write ( * , '(a,i5,/)' ) & '>>> Warning, no. of hydrogens required = ' , nH_required makeH (:) = . false . !don't need to redo when making topology end subroutine makehyds integer function genH ( j , residue ) !arguments integer , intent ( in ) :: j , residue !locals real ( 8 ) :: xj ( 3 ), xk ( 3 ) integer :: ligand , H , kt , lt real ( 8 ) :: old_xH ( 3 ), xH ( 3 ), V , Vtot , dV ( 3 ), dvLast ( 3 ), gamma , dVtot ( 3 ) real ( 8 ) :: VtotLast real ( 8 ) :: dx ( 3 ), dx_line , rms_dV real ( 8 ), parameter :: convergence_criterum = 0.1 real ( 8 ), parameter :: dV_scale = 0.025 real ( 8 ), parameter :: max_dx = 1. !max_dx is max distance of line search step in first CG iteration (�) real ( 8 ) :: local_min = 30 real ( 8 ) :: tors_fk = 1 0. integer , parameter :: max_cg_iterations = 100 , max_line_iterations = 35 integer :: cgiter , lineiter real ( 8 ) :: bnd0 integer :: nHang , Hang_atom ( max_conn ) integer :: Hang_code ( max_conn ) integer :: rule type ( LIB_ENTRY_TYPE ), pointer :: lp integer :: a , b , axis real ( 8 ) :: bond_length , db real ( 8 ) :: rjH ( 3 ), rjk ( 3 ), bjHinv , bjkinv real ( 8 ) :: scp , angle , angle_deg , dVangle , da , f1 real ( 8 ) :: xkt ( 3 ), xlt ( 3 ), rjkt ( 3 ), rktlt ( 3 ) real ( 8 ) :: rnj ( 3 ), rnk ( 3 ), bj , bk real ( 8 ) :: phi , phi_deg , sgn , dVtors , arg , dH ( 3 ) logical :: flipped integer :: setH integer , parameter :: nsetH = 5 !number of times to flip, if local min, and retry genH = 0 xj (:) = xtop ( 3 * j - 2 : 3 * j ) !First find the bond, angle and torsion parameters to use !loop over connected atoms do ligand = 1 , nconn ( j ) H = iconn ( ligand , j ) !is it an unmade H? if ( makeH ( H )) then !make this H !find the bond potential do b = 1 , nbonds if (( bnd ( b )% i == j . and . bnd ( b )% j == H ) . or . & ( bnd ( b )% j == j . and . bnd ( b )% i == H )) then if ( bnd ( b )% cod > 0 ) then bnd0 = bondlib ( bnd ( b )% cod )% bnd0 else bnd0 = 1. !default when missing parameters endif exit end if end do !a unique Hbond_code will always be found !because list of connections is based on bond list !find all the angles nHang = 0 do a = 1 , nangles if ( ang ( a )% j == j . and . ang ( a )% cod > 0 ) then if ( ang ( a )% i == H . and . . not . makeH ( ang ( a )% k )) then nHang = nHang + 1 Hang_atom ( nHang ) = ang ( a )% k Hang_code ( nHang ) = ang ( a )% cod elseif ( ang ( a )% k == H . and . . not . makeH ( ang ( a )% i )) then nHang = nHang + 1 Hang_atom ( nHang ) = ang ( a )% i Hang_code ( nHang ) = ang ( a )% cod end if end if end do !look up build rule lp => lib ( res ( residue )% irc ) do rule = lp % nrules , 1 , - 1 if ( lp % rules ( rule )% kind == BUILD_RULE_TORSION ) then if ( lp % rules ( rule )% atom ( 1 ) == H - res ( residue )% start + 1 . and . & lp % rules ( rule )% atom ( 2 ) == j - res ( residue )% start + 1 ) then exit end if end if end do !find the torsion rule defined in the library, if any if ( rule > 0 ) then kt = lp % rules ( rule )% atom ( 3 ) + res ( residue )% start - 1 lt = lp % rules ( rule )% atom ( 4 ) + res ( residue )% start - 1 xkt (:) = xtop ( 3 * kt - 2 : 3 * kt ) xlt (:) = xtop ( 3 * lt - 2 : 3 * lt ) rjkt (:) = xkt (:) - xj (:) rktlt (:) = xlt (:) - xkt (:) rnk (:) = - cross_product ( rjkt , rktlt ) bk = sqrt ( dot_product ( rnk , rnk )) end if !generate initial coordinates for H !random vector do axis = 1 , 3 xH ( axis ) = randm () - . 5 end do !normalise to unit length and scale by bond length from lib. bond_length = sqrt ( dot_product ( xH , xH )) xH (:) = xH (:) / bond_length * bnd0 !place near atom j xH (:) = xH (:) + xj (:) !                       write(*,800) 0,H,xH(:) !conjugate gradient minimisation do setH = 1 , nsetH do cgiter = 1 , max_cg_iterations !                               write(*,9, advance='no') cgiter 9 format ( 'cg step' , i3 , ':' ) !do line search dx_line = max_dx * 2. ** ( - cgiter ) flipped = . false . do lineiter = 1 , max_line_iterations Vtot = 0 dVtot (:) = 0 !calc. potential & gradient !angles rjH (:) = xH (:) - xj (:) do a = 1 , nHang xk (:) = xtop ( 3 * Hang_atom ( a ) - 2 : 3 * Hang_atom ( a )) rjk (:) = xk (:) - xj (:) bjHinv = 1. / sqrt ( dot_product ( rjH , rjH )) bjkinv = 1. / sqrt ( dot_product ( rjk , rjk )) ! calculate scp and angv scp = dot_product ( rjH , rjk ) * bjHinv * bjkinv if ( scp > 1. ) then scp = 1. else if ( scp < - 1. ) then scp = - 1.0 end if angle = acos ( scp ) angle_deg = angle / deg2rad ! calculate da and dv da = angle - anglib ( Hang_code ( a ))% ang0 * deg2rad V = 0.5 * anglib ( Hang_code ( a ))% fk * da ** 2 Vtot = Vtot + V dVangle = anglib ( Hang_code ( a ))% fk * da ! calculate f1 f1 = sin ( angle ) ! avoid division by zero if ( abs ( f1 ) < 1.e-12 ) then f1 = - 1.e12 else f1 = - 1.0 / f1 end if dV (:) = dVangle & * ( f1 * ( rjk (:) * bjHinv * bjkinv - scp * rjH (:) * bjHinv * bjHinv )) dVtot (:) = dVtot (:) + dV (:) end do !torsion if ( rule > 0 ) then rnj ( 1 ) = rjH ( 2 ) * rjkt ( 3 ) - rjH ( 3 ) * rjkt ( 2 ) rnj ( 2 ) = rjH ( 3 ) * rjkt ( 1 ) - rjH ( 1 ) * rjkt ( 3 ) rnj ( 3 ) = rjH ( 1 ) * rjkt ( 2 ) - rjH ( 2 ) * rjkt ( 1 ) bj = sqrt ( dot_product ( rnj , rnj )) scp = dot_product ( rnj , rnk ) / ( bj * bk ) if ( scp > 1.0 ) scp = 1.0 if ( scp < - 1.0 ) scp = - 1.0 phi = acos ( scp ) phi_deg = phi / deg2rad sgn = rjkt ( 1 ) * ( rnj ( 2 ) * rnk ( 3 ) - rnj ( 3 ) * rnk ( 2 ) ) & + rjkt ( 2 ) * ( rnj ( 3 ) * rnk ( 1 ) - rnj ( 1 ) * rnk ( 3 ) ) & + rjkt ( 3 ) * ( rnj ( 1 ) * rnk ( 2 ) - rnj ( 2 ) * rnk ( 1 ) ) if ( sgn < 0 ) phi = - phi arg = phi - lp % rules ( rule )% value * deg2rad V = tors_fk * ( 1.0 + cos ( arg )) !note changed sign of dVtors to get min (not max) at rule value dVtors = + tors_fk * sin ( arg ) ! ---       forces f1 = sin ( phi ) if ( abs ( f1 ) . lt . 1.e-12 ) f1 = 1.e-12 f1 = - 1.0 / f1 dH (:) = f1 * ( rnk (:) / ( bj * bk ) - scp * rnj (:) / ( bj * bj )) dV (:) = dVtors * cross_product ( rjk , dH ) dVtot (:) = dVtot (:) + dV (:) end if if ( cgiter == 1 . and . lineiter == 1 ) then !its the start of the search, use the gradient vector dvLast (:) = dVtot (:) elseif ( VtotLast < Vtot ) then dx_line = - dx_line !next step back flipped = . true . endif rms_dV = sqrt ( abs ( dot_product ( dVtot , dVLast ))) if ( rms_dV < convergence_criterum / 10 ) then exit !reached a potential minimum along the search line endif !update position in line search dx (:) = - dVLast (:) / sqrt ( dot_product ( dVlast , dVLast )) * dx_line if ( flipped ) dx_line = 0.5 * dx_line !reduce step size only after first change of direction VtotLast = Vtot xH (:) = xH (:) + dx (:) end do !lineiter !                               write(*,*) lineiter rjH (:) = xH (:) - xj (:) bond_length = sqrt ( dot_product ( rjH , rjH )) rjH (:) = rjH (:) / bond_length * bnd0 !adjust bond length xH (:) = xj (:) + rjH (:) rms_dV = sqrt ( dot_product ( dVtot , dVtot )) if ( rms_dV < convergence_criterum ) then if ( Vtot < local_min ) then !found global min exit else !it's a local min - flip 180 deg. dVlast (:) = - dVlast (:) xH (:) = xj (:) - rjH (:) end if end if !get new gradient search direction gamma = dot_product ( dVtot , dVlast ) / dot_product ( dVlast , dVlast ) !use conjugate gradient dVlast (:) = dVtot (:) - gamma * dVlast (:) end do !cgiter !Check if local min -> restart iteration ; problem with conversion if ( Vtot > local_min ) then !it's a local min - flip 180 deg. dVlast (:) = - dVlast (:) xH (:) = xj (:) - rjH (:) else exit end if end do !setH !check if not converged if ( cgiter >= max_cg_iterations . and . Vtot > 3.0 ) then !display warning write ( * , 900 ) H , j , Vtot 900 format ( '>>> WARNING: Positioning of hydrogen' , i6 ,& ' bound to atom' , i6 , ' didn''t converge.' , / , & 'Potential is ' , f8 . 3 , ' kcal/mol.' ) end if !copy coordinates to topology xtop ( 3 * H - 2 : 3 * H ) = xH (:) !clear makeH flag makeH ( H ) = . false . genH = genH + 1 end if end do !hydrogens to make end function genh subroutine makeimps ! *** local variables integer :: i !....................................................................... nimps = 0 nimps_solute = 0 do i = 1 , nat_pro if ( nconn ( i ) == 3 ) then nimps = nimps + 1 if ( i <= nat_solute ) nimps_solute = nimps_solute + 1 imp ( nimps )% i = iconn ( 1 , i ) imp ( nimps )% j = i imp ( nimps )% k = iconn ( 2 , i ) imp ( nimps )% l = iconn ( 3 , i ) end if enddo end subroutine makeimps subroutine imp_params ! *** local variables integer i , ii , iaci , iacj , iack , iacl integer iused ( nimp_prm + max_extrabnd ), itrans ( nimp_prm + max_extrabnd ) do i = 1 , nimps iaci = iac ( imp ( i )% i ) iacj = iac ( imp ( i )% j ) iack = iac ( imp ( i )% k ) iacl = iac ( imp ( i )% l ) imp ( i )% cod = impcode ( tac ( iaci ), tac ( iacj ), tac ( iack ), tac ( iacl )) if ( imp ( i )% cod == 0 ) then write ( * , 20 ) imp ( i )% i , imp ( i )% j , imp ( i )% k , imp ( i )% l end if enddo 20 format ( 'Atoms of missing improper:' , 4 i5 ) ! --- Make a list of actual angle types to be used iused (:) = 0 nimpcod = 0 do i = 1 , nimps !       workaround to permit missing param's if ( imp ( i )% cod /= 0 ) then if ( iused ( imp ( i )% cod ) == 0 ) then iused ( imp ( i )% cod ) = 1 nimpcod = nimpcod + 1 itrans ( imp ( i )% cod ) = nimpcod implib ( nimpcod ) = imp_prm ( imp ( i )% cod )% prm imp ( i )% cod = nimpcod ELSE imp ( i )% cod = itrans ( imp ( i )% cod ) endif endif enddo write ( * , 100 ) nimps_solute , 'solute' write ( * , 100 ) nimps - nimps_solute , 'solvent' 100 format ( 'Made    ' , i6 , 1 x , a , ' impropers.' ) !....................................................................... end subroutine imp_params integer function find_atom ( ires , atom ) !arguments integer :: ires character ( len = 5 ) :: atom !locals integer :: my_res , iat , irc character ( len = 4 ) :: my_atom integer :: mol1 , mol2 if ( atom ( 1 : 1 ) == '-' ) then my_res = ires - 1 my_atom = atom ( 2 : 5 ) elseif ( atom ( 1 : 1 ) == '+' ) then my_res = ires + 1 my_atom = atom ( 2 : 5 ) else my_res = ires my_atom = atom ( 1 : 4 ) end if find_atom = 0 !first may not refer backwards and last may not refer ahead if ( my_res < 1 . or . my_res > nres ) then !can't move outside terminal residues - skip return end if !check if moving outside molecule if ( ires /= my_res ) then do mol1 = 1 , nmol if ( res ( ires )% start < istart_mol ( mol1 + 1 )) exit end do do mol2 = 1 , nmol if ( res ( my_res )% start < istart_mol ( mol2 + 1 )) exit end do if ( mol1 /= mol2 ) return !crossed molecule boundary end if irc = res ( my_res )% irc !get residue code do iat = 1 , lib ( irc )% nat if ( lib ( irc )% atnam ( iat ) == my_atom ) then find_atom = res ( my_res )% start + iat - 1 exit end if end do if ( ires == my_res . and . find_atom == 0 ) then !we have an error: an atom in _this_ residue was not found topo_ok = . false . write ( * , 120 ) my_atom , lib ( irc )% nam , ires end if 120 format ( '>>>>> ERROR: There is no atom named ' , a4 , ' in residue ' , a4 , i5 , '.' ) end function find_atom subroutine makeimps_explicit !generate impropers using definitions in library file ! *** local variables integer :: ires , irc , iimp , i nimps = 0 nimps_solute = 0 do ires = 1 , nres !loop over residues irc = res ( ires )% irc do iimp = 1 , lib ( irc )% nimp !loop over improper defs nimps = nimps + 1 if ( ires <= nres_solute ) nimps_solute = nimps_solute + 1 imp ( nimps )% i = find_atom ( ires , lib ( irc )% imp ( iimp )% i ) imp ( nimps )% j = find_atom ( ires , lib ( irc )% imp ( iimp )% j ) imp ( nimps )% k = find_atom ( ires , lib ( irc )% imp ( iimp )% k ) imp ( nimps )% l = find_atom ( ires , lib ( irc )% imp ( iimp )% l ) if ( imp ( nimps )% i == 0 . or . imp ( nimps )% j == 0 . or . & imp ( nimps )% k == 0 . or . imp ( nimps )% l == 0 ) then !not found nimps = nimps - 1 !take a step back, discard this one if ( ires <= nres_solute ) nimps_solute = nimps_solute - 1 end if end do end do end subroutine makeimps_explicit subroutine maketop !check if library is loaded if (. not . check_residues ()) return !       bail out if readparm failed if (. not . ff_ok ) then write ( * , 900 ) 900 format ( '>>>>> ERROR: Force field parameters not loaded.' ) return end if topo_ok = . false . !check if boundaries are set if (. not . boundary_set ) then write ( * , 910 ) 910 format ( '>>>>> ERROR: Boundary has not been set.' ) return end if if ( . not . have_solvent_boundary ) then xwcent (:) = xpcent (:) write ( * , 911 ) write ( * , 912 ) 911 format ( '>>>>> WARNING: System has not been solvated.' ) 912 format ( 'Using boundary center as solvent center.' ) end if if (. not . have_title ) then CALL get_line_arg ( title , '-----> Give this topology a title: ' ) have_title = . true . end if topo_ok = . true . !now hope for the best !deallocate old topology if any if ( allocated ( iac )) deallocate ( iac ) if ( allocated ( crg )) deallocate ( crg ) if ( allocated ( cgpatom )) deallocate ( cgpatom ) if ( allocated ( list14 )) deallocate ( list14 ) if ( allocated ( listex )) deallocate ( listex ) if ( allocated ( nconn )) deallocate ( nconn ) if ( allocated ( iconn )) deallocate ( iconn ) if ( allocated ( bnd )) deallocate ( bnd ) if ( allocated ( bondlib )) deallocate ( bondlib ) if ( allocated ( SYBYL_bond_type )) deallocate ( SYBYL_bond_type ) if ( allocated ( ang )) deallocate ( ang ) if ( allocated ( anglib )) deallocate ( anglib ) if ( allocated ( tor )) deallocate ( tor ) if ( allocated ( torlib )) deallocate ( torlib ) if ( allocated ( imp )) deallocate ( imp ) if ( allocated ( implib )) deallocate ( implib ) if ( allocated ( list14long )) deallocate ( list14long ) if ( associated ( listexlong )) deallocate ( listexlong ) if ( allocated ( cgp )) deallocate ( cgp ) if ( allocated ( nconn )) deallocate ( nconn ) if ( allocated ( iconn )) deallocate ( iconn ) if ( allocated ( excl )) deallocate ( excl ) if ( allocated ( shell )) deallocate ( shell ) !allocate topology arrays (set max_atom etc call topo_set_max ( nat_pro , max_lib , max_long ) !make space for new topology allocate ( iac ( max_atom ), & crg ( max_atom ), & cgpatom ( max_atom ), & list14 ( max_nbr_range , max_atom ), & listex ( max_nbr_range , max_atom ), & nconn ( max_atom ), iconn ( max_conn , max_atom ), & stat = alloc_status ) if ( alloc_status /= 0 ) then write ( * , * ) 'ERROR: Out of memory when allocating topology arrays' stop 255 end if if ( . not . use_PBC ) then allocate ( excl ( max_atom ), shell ( max_atom ), stat = alloc_status ) if ( alloc_status /= 0 ) then write ( * , * ) 'ERROR: Out of memory when allocating topology arrays' stop 255 end if end if allocate ( bnd ( max_bonds ), & bondlib ( max_bondlib ), & SYBYL_bond_type ( max_bondlib ), & ang ( max_angles ), & anglib ( max_anglib ), & tor ( max_tors ), & torlib ( max_torlib ), & imp ( max_imps ), & implib ( max_implib ), & stat = alloc_status ) if ( alloc_status /= 0 ) then write ( * , * ) 'ERROR: Out of memory when allocating topology arrays' stop 255 end if allocate ( list14long ( 2 , max_14long ), & listexlong ( 2 , max_exlong ), & cgp ( max_cgp ), & stat = alloc_status ) if ( alloc_status /= 0 ) then write ( * , * ) 'ERROR: Out of memory when allocating topology arrays' stop 255 end if !set date of creation call date_and_time ( creation_date ) !set atom types, charges, charge groups CALL set_iac if (. not . topo_ok ) return call set_solvent_type CALL set_crg CALL makebonds call set_bondcodes call makeconn CALL makeangles CALL maketors if ( imp_explicit ) then call makeimps_explicit !explicit (from lib.) generation else CALL makeimps !automatic generation end if call imp_params !set codes & filter out unused types CALL make14list CALL makeexlist CALL makehyds !generate hydrogens CALL set_cgp !assigns all cgp() within exclusion radius call set_default_mask !       Now check if we have missing parameters if ( topo_ok ) then write ( * , '(a)' ) 'Topology successfully generated.' else write ( * , '(/,a,/)' ) 'ERROR: There are missing parameters!' write ( * , '(a)' ) 'You need to add parameters and do readprm + maketop again.' write ( * , 100 ) trim ( prm_file ) endif 100 format ( 'parameter file: ' , a ) end subroutine maketop subroutine set_default_mask !make atom mask including all atoms !first get rid of old mask call mask_finalize ( mask ) !allocate new mask call mask_initialize ( mask ) !add all atoms (in_mask is not used) call mask_all ( mask ) end subroutine set_default_mask subroutine makeconn !locals integer :: i , ib nconn (:) = 0 ! --- Make a list of connections to each atom do i = 1 , nat_pro nconn ( i ) = 0 do ib = 1 , nbonds if ( bnd ( ib )% i == i ) then nconn ( i ) = nconn ( i ) + 1 iconn ( nconn ( i ), i ) = bnd ( ib )% j ELSEif ( bnd ( ib )% j == i ) then nconn ( i ) = nconn ( i ) + 1 iconn ( nconn ( i ), i ) = bnd ( ib )% i endif enddo enddo end subroutine makeconn subroutine maketors ! *** local variables integer i , j , ic , jc , ib , it , iaci , iacj , iack , iacl integer iused ( ntor_prm + max_extrabnd ), itrans ( ntor_prm + max_extrabnd ) type ( TOR_CODES ) :: torcodes integer :: icod ! --- Make the torsion list ntors = 0 ntors_solute = 0 do ib = 1 , nbonds do ic = 1 , nconn ( bnd ( ib )% i ) i = iconn ( ic , bnd ( ib )% i ) if ( i /= bnd ( ib )% j ) then do jc = 1 , nconn ( bnd ( ib )% j ) j = iconn ( jc , bnd ( ib )% j ) if ( j /= bnd ( ib )% i ) then if ( i /= j ) then iaci = iac ( i ) iacj = iac ( bnd ( ib )% i ) iack = iac ( bnd ( ib )% j ) iacl = iac ( j ) torcodes = torcode ( tac ( iaci ), tac ( iacj ), tac ( iack ), tac ( iacl )) if ( torcodes % ncod == 0 ) then write ( * , * ) 'atoms: ' , i , bnd ( ib )% i , bnd ( ib )% j , j endif do icod = 1 , torcodes % ncod ntors = ntors + 1 if ( i <= nat_solute ) ntors_solute = ntors_solute + 1 tor ( ntors )% i = i tor ( ntors )% j = bnd ( ib )% i tor ( ntors )% k = bnd ( ib )% j tor ( ntors )% l = j tor ( ntors )% cod = torcodes % cod ( icod ) end do !                               tor(ntors)%cod = torcode(tac(iaci), tac(iacj), tac(iack), tac(iacl)) !                                                  workaround to allow missing param's !                               if(tor(ntors)%cod /=0) then !                                       if(tor_prm(tor(ntors)%cod)%rmult <= - 1.0) then !                                               more_terms = .true. !                                               do while(more_terms) !                                                       ntors = ntors + 1 !                                                       if(i <= nat_solute) ntors_solute = ntors_solute + 1 !                                                       tor(ntors)%i = tor(ntors - 1)%i !                                                       tor(ntors)%j = tor(ntors - 1)%j !                                                       tor(ntors)%k = tor(ntors - 1)%k !                                                       tor(ntors)%l = tor(ntors - 1)%l !                                                       tor(ntors)%cod = tor(ntors - 1)%cod + 1 !                                                       more_terms = .false. !                                                       if(tor_prm(tor(ntors)%cod)%rmult <= -1.0)  & !                                                               more_terms = .true. !                                               enddo !                                       endif !                               endif endif endif enddo endif enddo enddo ! --- Make a list of actual torsion types to be used iused ( 1 : ntor_prm ) = 0 ntorcod = 0 do i = 1 , ntors !          workaround to permit missing param's if ( tor ( i )% cod /= 0 ) then if ( iused ( tor ( i )% cod ) == 0 ) then iused ( tor ( i )% cod ) = 1 ntorcod = ntorcod + 1 itrans ( tor ( i )% cod ) = ntorcod torlib ( ntorcod ) = tor_prm ( tor ( i )% cod ) tor ( i )% cod = ntorcod ELSE tor ( i )% cod = itrans ( tor ( i )% cod ) endif endif enddo write ( * , 100 ) ntors_solute , 'solute' write ( * , 100 ) ntors - ntors_solute , 'solvent' 100 format ( 'Made    ' , i6 , 1 x , a , ' torsions.' ) !....................................................................... end subroutine maketors subroutine prompt ( outtxt ) ! *** local variables CHARACTER ( * ) outtxt !....................................................................... write ( * , '(a,$)' ) outtxt return !....................................................................... end subroutine prompt real FUNCTION randm ( seed , seed_only ) !arguments integer , intent ( in ), optional :: seed logical , intent ( in ), optional :: seed_only ! *** Local variables integer , parameter :: m = 100000000 , m1 = 10000 , mult = 31415821 integer , save :: irand = 0 integer :: irandh , irandl , multh , multl real :: r if ( present ( seed )) then irand = mod ( iabs ( seed ), m ) end if if ( present ( seed_only )) return ! ! --- multiply irand by mult, but take into account that overflow must ! --- be discarded, and do not generate an error. ! irandh = irand / m1 irandl = mod ( irand , m1 ) multh = mult / m1 multl = mod ( mult , m1 ) ! irand = mod ( irandh * multl + irandl * multh , m1 ) * m1 + irandl * & multl irand = mod ( irand + 1 , m ) ! ! --- convert irand to a real random number between 0 and 1. ! r = real ( irand / 10 ) * 10 / real ( m ) if (( r <= 0.e0 ) . or .( r > 1.e0 ) ) r = 0.e0 randm = r !....................................................................... end FUNCTION randm subroutine oldreadlib ( filnam ) !arguments character ( * ) :: filnam ! *** local variables character :: line * 200 integer :: irec , i , iat , ires , j , igp , ntot real :: qtot , qgrp , qtot_grp ! some extra arrays used only for allocation. This circumvents ! an unaligned access error on Digital UNIX 4.0 / Digital FORTRAN ! (Compiler bug?) character ( len = KEYLENGTH ), pointer :: tac_lib (:) character ( len = 4 ), pointer :: atnam (:) real , pointer :: crg_lib (:) integer ( AI ), pointer :: natcgp (:), switch (:) integer ( AI ), pointer :: atcgp (:,:) type ( LIB_BOND_TYPE ), pointer :: bnd (:) integer :: stat 1 format ( a , t7 , a , t14 , a , t21 , a , t28 , a ) 2 format ( a4 ) 3 format ( t9 , i3 ) 4 format ( t14 , f5 . 2 ) 5 format ( t23 , i3 ) 6 format ( t31 , i3 ) if ( openit ( 1 , filnam , 'old' , 'formatted' , 'read' ) /= 0 ) then write ( * , '(a,a)' ) '>>>>>ERROR: Could not open library file ' , & trim ( filnam ) return end if write ( * , '(/,a,a,/)' ) 'Reading molecular library ' , trim ( filnam ) write ( * , 1 ) 'name' , 'atoms' , 'net Q' , 'bonds' , 'Q-grps' do irec = 1 , 99999 call skip_comments ( 1 ) READ ( 1 , '(a80)' ) line if ( line == 'end' ) exit BACKSPACE ( 1 ) nlibres = nlibres + 1 if ( nlibres > max_entry ) then write ( * , * ) 'ERROR: Too many library entries!' write ( * , * ) '(This problem may be solved by increasing max_entry.)' exit end if ires = nlibres ! ---      Read entry name lib ( nlibres )% SYBYLTYPE = '****' lib ( nlibres )% HETATM = . false . !don't use new feature lib ( nlibres )% solvent = . false . !don't use new feature lib ( nlibres )% density = 0 !don't use new feature read ( 1 , '(a)' ) line READ ( line , fmt =* , err = 9 , end = 9 ) lib ( nlibres )% nam , lib ( nlibres )% SYBYLTYPE 9 write ( * , 2 , advance = 'no' ) lib ( nlibres )% nam ! ---      Read no. of atoms, at. no., name, iac, charge READ ( 1 , * , iostat = stat ) lib ( nlibres )% nat if ( stat /= 0 ) then write ( * , * ) write ( * , * ) 'Incorrect input!' return endif write ( * , 3 , advance = 'no' ) lib ( nlibres )% nat allocate ( atnam ( lib ( nlibres )% nat )) lib ( nlibres )% atnam => atnam allocate ( tac_lib ( lib ( nlibres )% nat )) lib ( nlibres )% tac_lib => tac_lib allocate ( crg_lib ( lib ( nlibres )% nat )) lib ( nlibres )% crg_lib => crg_lib qtot = 0 do i = 1 , lib ( nlibres )% nat READ ( 1 , * ) iat , lib ( nlibres )% atnam ( iat ), lib ( nlibres )% tac_lib ( iat ), & lib ( nlibres )% crg_lib ( iat ) qtot = qtot + lib ( nlibres )% crg_lib ( iat ) enddo write ( * , 4 , advance = 'no' ) qtot ! ---      Read no. of bonds, bond list, tail/head connections READ ( 1 , * ) lib ( nlibres )% nbnd allocate ( bnd ( lib ( nlibres )% nbnd ), stat = alloc_status ) lib ( nlibres )% bnd => bnd write ( * , 5 , advance = 'no' ) lib ( nlibres )% nbnd do i = 1 , lib ( nlibres )% nbnd READ ( 1 , * ) lib ( nlibres )% bnd ( i )% i , lib ( nlibres )% bnd ( i )% j enddo READ ( 1 , * ) lib ( nlibres )% head , lib ( nlibres )% tail ! ---      Read charge group info READ ( 1 , * ) lib ( nlibres )% ncgp write ( * , 6 ) lib ( nlibres )% ncgp allocate ( atcgp ( max ( max_atcgplib , lib ( nlibres )% nat ), lib ( nlibres )% ncgp )) lib ( nlibres )% atcgp => atcgp allocate ( natcgp ( lib ( nlibres )% ncgp ), switch ( lib ( nlibres )% ncgp )) lib ( nlibres )% natcgp => natcgp lib ( nlibres )% switch => switch qtot_grp = 0. ntot = 0 do i = 1 , lib ( nlibres )% ncgp READ ( 1 , * ) lib ( nlibres )% natcgp ( i ), lib ( nlibres )% switch ( i ) ntot = ntot + lib ( nlibres )% natcgp ( i ) READ ( 1 , * ) lib ( nlibres )% atcgp ( 1 : lib ( nlibres )% natcgp ( i ), i ) qgrp = 0 do j = 1 , lib ( nlibres )% natcgp ( i ) !The Cray compiler doesn't like lib(nlibres)%crg_lib(lib(nlibres)%atcgp(j, i)) igp = lib ( nlibres )% atcgp ( j , i ) qgrp = qgrp + lib ( nlibres )% crg_lib ( igp ) enddo !check fractional charges if ( abs ( qgrp - nint ( qgrp ) ) > 0.000001 ) then write ( * , 130 ) qgrp , i end if qtot_grp = qtot_grp + qgrp enddo !check total charge & atom count consistency if ( ntot /= lib ( nlibres )% nat ) then write ( * , 150 ) endif if ( abs ( qtot - qtot_grp ) > 0.000001 ) then write ( * , 160 ) end if enddo close ( 1 ) write ( * , 110 ) nlibres 110 format ( / , 'Accumulated no. of library entries loaded =' , i4 , / ) 130 format ( '>>> Warning: fractional charge = ' , f8 . 5 , ' on group no.' , i3 ) 150 format ( '>>> ERROR: charge group atom count does not match total atom count!' ) 160 format ( '>>> ERROR: Sum of charge group charges not equal to sum of all charges!' ) end subroutine oldreadlib subroutine readlib ( file ) !arguments character ( * ), optional :: file ! *** local variables character :: line * 200 , filnam * 200 integer :: irec , i , iat , ires , j , igp , ntot real :: qtot , qgrp , qtot_grp character ( len = 80 ) :: resnam integer :: res_count logical :: prm_res integer :: cgp_read ( max_atcgplib ) !some extra arrays used only for allocation. This circumvents !an unaligned access error on Digital UNIX 4.0 / Digital FORTRAN !(Compiler bug?) character ( len = KEYLENGTH ), pointer :: tac_lib (:) character ( len = 4 ), pointer :: atnam (:) real , pointer :: crg_lib (:) integer ( AI ), pointer :: natcgp (:), switch (:) integer ( AI ), pointer :: atcgp (:,:) type ( LIB_BOND_TYPE ), pointer :: bnd (:) type ( LIB_IMP_TYPE ), pointer :: imp (:) logical :: lib_exists character ( len = 8 ) :: atnam1 , atnam2 , atnam3 , atnam4 integer :: atno1 , atno2 , atno3 , atno4 logical :: yes integer :: atoms_in_rule , readstat 1 format ( 10 a7 ) 2 format ( a4 ) 3 format ( i7 ) 4 format ( f7 . 2 ) 7 format ( 4 x , a ) !....................................................................... res_count = 0 if ( present ( file )) then filnam = file else call get_string_arg ( filnam , '-----> Name of molecular library: ' ) end if inquire ( file = filnam , exist = lib_exists ) if (. not . lib_exists ) then write ( * , 10 ) trim ( filnam ) return end if if ( lib_files == '' ) then lib_files = filnam elseif ( len_trim ( lib_files ) < 200 - len_trim ( filnam )) then lib_files = trim ( lib_files ) // \";\" // trim ( filnam ) end if if (. not . prm_open ( filnam )) then !if reading fails try old format write ( * , '(a)' ) '>>>>>WARNING: Attempting to read old-style library file.' call oldreadlib ( filnam ) return end if 10 format ( '>>>>> ERROR: ' , a , ' does not exist.' ) write ( * , '(/,a,a,/)' ) 'Reading molecular library ' , trim ( filnam ) write ( * , 2 , advance = 'no' ) 'name' write ( * , 1 ) 'atoms' , 'net Q' , 'bonds' , 'rules' , 'imps' , 'Q-grps' !loop over all titles in file do while ( prm_get_next_title ( resnam )) call check_overload ( resnam ) nlibres = nlibres + 1 res_count = res_count + 1 lib ( nlibres )% nam = resnam ( 1 : len ( lib ( nlibres )% nam )) !copy name write ( * , 2 , advance = 'no' ) lib ( nlibres )% nam lib ( nlibres )% SYBYLTYPE = '****' lib ( nlibres )% HETATM = . false . lib ( nlibres )% solvent = . false . if ( prm_open_section ( 'info' )) then !read info if ( prm_get_string_by_key ( 'SYBYLTYPE' , line )) then lib ( nlibres )% SYBYLTYPE = line ( 1 : len ( lib ( nlibres )% SYBYLTYPE )) end if yes = prm_get_string_by_key ( 'PDBTYPE' , line , 'ATOM' ) call upcase ( line ) if ( trim ( line ) == 'HETATM' ) then lib ( nlibres )% HETATM = . true . elseif ( trim ( line ) /= 'ATOM' ) then write ( * , '(a,a)' ) '>>>>>WARNING: Unknown PBBtype ' , trim ( line ) end if yes = prm_get_logical_by_key ( 'solvent' , lib ( nlibres )% solvent ,. false .) if ( lib ( nlibres )% solvent ) then solvent_names = trim ( solvent_names ) // lib ( nlibres )% nam // ',' end if yes = prm_get_real_by_key ( 'density' , lib ( nlibres )% density , 0. ) end if ! ---      Read no. of atoms, at. no., name, iac, charge lib ( nlibres )% nat = prm_count ( 'atoms' ) if ( lib ( nlibres )% nat == 0 ) then write ( * , '(a,a)' ) '>>>>>ERROR: No atoms in residue ' , trim ( resnam ) !undo this residue nlibres = nlibres - 1 res_count = res_count - 1 exit end if write ( * , 3 , advance = 'no' ) lib ( nlibres )% nat allocate ( atnam ( lib ( nlibres )% nat )) !initialise atom name -> number index call index_create ( lib ( nlibres )% nat ) lib ( nlibres )% atnam => atnam allocate ( tac_lib ( lib ( nlibres )% nat )) lib ( nlibres )% tac_lib => tac_lib allocate ( crg_lib ( lib ( nlibres )% nat )) lib ( nlibres )% crg_lib => crg_lib qtot = 0 do i = 1 , lib ( nlibres )% nat prm_res = prm_get_line ( line ) READ ( line , * ) iat !Check numbering of atoms if ( iat > lib ( nlibres )% nat ) then write ( * , 119 ) iat end if READ ( line , * ) iat , lib ( nlibres )% atnam ( iat ), lib ( nlibres )% tac_lib ( iat ), & lib ( nlibres )% crg_lib ( iat ) if (. not . index_add ( lib ( nlibres )% atnam ( iat ), iat )) then !could not add - name duplication? write ( * , 120 ) iat , lib ( nlibres )% atnam ( iat ) end if !add also the number as an atom name write ( atnam1 , '(i4)' ) iat atnam1 = adjustl ( atnam1 ) if (. not . index_add ( atnam1 , iat )) then !could not add - number duplication? write ( * , 121 ) iat end if qtot = qtot + lib ( nlibres )% crg_lib ( iat ) enddo write ( * , 4 , advance = 'no' ) qtot ! ---      Read bond list lib ( nlibres )% nbnd = prm_count ( 'bonds' ) allocate ( bnd ( lib ( nlibres )% nbnd ), stat = alloc_status ) lib ( nlibres )% bnd => bnd write ( * , 3 , advance = 'no' ) lib ( nlibres )% nbnd do i = 1 , lib ( nlibres )% nbnd prm_res = prm_get_line ( line ) read ( line , * ) atnam1 , atnam2 if (. not . index_get ( atnam1 , atno1 )) then write ( * , 125 ) atnam1 , i cycle end if if (. not . index_get ( atnam2 , atno2 )) then write ( * , 126 ) atnam2 , i cycle end if lib ( nlibres )% bnd ( i )% i = atno1 lib ( nlibres )% bnd ( i )% j = atno2 enddo !read head and tail connections, if present lib ( nlibres )% head = 0 lib ( nlibres )% tail = 0 if ( prm_open_section ( 'connections' )) then !0 is returned if not found atno1 = 0 if ( prm_get_string_by_key ( 'head' , atnam1 )) then if ( atnam1 /= '0' . and . . not . index_get ( atnam1 , atno1 )) then write ( * , 127 ) atnam1 end if end if lib ( nlibres )% head = atno1 atno1 = 0 if ( prm_get_string_by_key ( 'tail' , atnam1 )) then if ( atnam1 /= '0' . and . . not . index_get ( atnam1 , atno1 )) then write ( * , 128 ) atnam1 end if end if lib ( nlibres )% tail = atno1 end if ! ---      Read hydrogen build rules lib ( nlibres )% nrules = prm_count ( 'build_rules' ) allocate ( lib ( nlibres )% rules ( lib ( nlibres )% nrules )) write ( * , 3 , advance = 'no' ) lib ( nlibres )% nrules ruleloop : do i = 1 , lib ( nlibres )% nrules !read kind prm_res = prm_get_field ( line ) call locase ( line ) if ( line == 'torsion' ) then lib ( nlibres )% rules ( i )% kind = BUILD_RULE_TORSION atoms_in_rule = 4 else lib ( nlibres )% rules ( i )% kind = 0 write ( * , 200 ) i , trim ( line ) 200 format ( '>>>>> ERROR: Unrecognised rule' , i2 , ' kind ' , a ) !skip to end of line yes = prm_get_field ( line , skip = . true .) !continue to next rule cycle ruleloop end if do iat = 1 , atoms_in_rule if (. not . prm_get_field ( line )) then lib ( nlibres )% rules ( i )% kind = 0 write ( * , 210 ) i 210 format ( '>>>>> ERROR: Read error at rule' , i2 ) yes = prm_get_field ( line , skip = . true .) !continue to next rule cycle ruleloop end if if (. not . index_get ( line , lib ( nlibres )% rules ( i )% atom ( iat ))) then lib ( nlibres )% rules ( i )% kind = 0 write ( * , 220 ) trim ( line ), i 220 format ( '>>>>> ERROR: Atom ' , a , ' not found in rule' , i2 ) yes = prm_get_field ( line , skip = . true .) !continue to next rule cycle ruleloop end if end do if (. not . prm_get_field ( line )) then lib ( nlibres )% rules ( i )% kind = 0 write ( * , 230 ) i 230 format ( '>>>>> ERROR: No value for rule ' , i2 ) yes = prm_get_field ( line , skip = . true .) cycle ruleloop end if read ( line , * , iostat = readstat ) lib ( nlibres )% rules ( i )% value if ( readstat /= 0 ) then lib ( nlibres )% rules ( i )% kind = 0 write ( * , 240 ) trim ( line ), i 240 format ( '>>>>> ERROR: Read error at rule ' , i2 ) end if yes = prm_get_field ( line , skip = . true .) end do ruleloop ! ---      Read improper list lib ( nlibres )% nimp = prm_count ( 'impropers' ) allocate ( imp ( lib ( nlibres )% nimp ), stat = alloc_status ) lib ( nlibres )% imp => imp write ( * , 3 , advance = 'no' ) lib ( nlibres )% nimp do i = 1 , lib ( nlibres )% nimp prm_res = prm_get_line ( line ) !note the order j,i,l,k used to conform with amber and charmm !parameter file conventions READ ( line , * ) lib ( nlibres )% imp ( i )% i , lib ( nlibres )% imp ( i )% j , & lib ( nlibres )% imp ( i )% k , lib ( nlibres )% imp ( i )% l enddo ! ---      Read charge group info lib ( nlibres )% ncgp = prm_count ( 'charge_groups' ) !if no chargegroups construct one if ( lib ( nlibres )% ncgp == 0 ) then write ( * , 7 ) 'none, creating default' lib ( nlibres )% ncgp = 1 allocate ( atcgp ( max ( max_atcgplib , lib ( nlibres )% nat ), 1 )) lib ( nlibres )% atcgp => atcgp allocate ( natcgp ( 1 ), switch ( 1 )) lib ( nlibres )% natcgp => natcgp lib ( nlibres )% switch => switch !create a charge group with all atoms lib ( nlibres )% switch ( 1 ) = 1 lib ( nlibres )% natcgp ( 1 ) = lib ( nlibres )% nat do i = 1 , lib ( nlibres )% nat lib ( nlibres )% atcgp ( i , 1 ) = i end do !pass consistencty test below qtot_grp = qtot ntot = lib ( nlibres )% nat else write ( * , 3 ) lib ( nlibres )% ncgp allocate ( atcgp ( max ( max_atcgplib , lib ( nlibres )% nat ), lib ( nlibres )% ncgp )) lib ( nlibres )% atcgp => atcgp allocate ( natcgp ( lib ( nlibres )% ncgp ), switch ( lib ( nlibres )% ncgp )) lib ( nlibres )% natcgp => natcgp lib ( nlibres )% switch => switch qtot_grp = 0. ntot = 0 do i = 1 , lib ( nlibres )% ncgp qgrp = 0. lib ( nlibres )% natcgp ( i ) = 0 do while ( prm_get_field ( line )) !get one number at a time if (. not . index_get ( line , igp )) then write ( * , 131 ) lib ( nlibres )% natcgp ( i ) + 1 , trim ( line ), i cycle end if !read(line, *) igp qgrp = qgrp + lib ( nlibres )% crg_lib ( igp ) lib ( nlibres )% natcgp ( i ) = lib ( nlibres )% natcgp ( i ) + 1 lib ( nlibres )% atcgp ( lib ( nlibres )% natcgp ( i ), i ) = igp end do lib ( nlibres )% switch ( i ) = lib ( nlibres )% atcgp ( 1 , i ) ntot = ntot + lib ( nlibres )% natcgp ( i ) !check fractional charges if ( abs ( qgrp - nint ( qgrp ) ) > 0.000001 ) then write ( * , 130 ) qgrp , i end if qtot_grp = qtot_grp + qgrp enddo !charge groups end if !charge groups defined !check total charge & atom count consistency if ( ntot /= lib ( nlibres )% nat ) then write ( * , 150 ) endif if ( abs ( qtot - qtot_grp ) > 0.000001 ) then write ( * , 160 ) end if end do !entries call prm_close write ( * , 110 ) nlibres 110 FORMAT ( / , 'Accumulated no. of library entries loaded =' , i4 , / ) 119 format ( '>>> ERROR: Atom' , i3 , ' has erraneos atom number.' ) 120 format ( '>>> ERROR: Atom' , i3 , ' has duplicated or invalid name ' , a ) 121 format ( '>>> ERROR: Atom' , i3 , ' has duplicated or invalid number.' ) 125 format ( '>>> ERROR: First atom named ' , a , ' in bond ' , i3 , ' not found' ) 126 format ( '>>> ERROR: Second atom named ' , a , ' in bond ' , i3 , ' not found' ) 127 format ( '>>> ERROR: Head atom named ' , a , ' not found' ) 128 format ( '>>> ERROR: Tail atom named ' , a , ' not found' ) 130 format ( '>>> Warning: fractional charge = ' , f8 . 5 , ' on group no.' , i3 ) 131 format ( '>>>>> ERROR: Atom' , i3 , ' named ' , a , ' of charge group' , i3 , ' not found.' ) 150 format ( '>>> ERROR: charge group atom count does not match total atom count!' ) 160 format ( '>>> ERROR: Sum of charge group charges not equal to sum of all charges!' ) end subroutine readlib subroutine check_overload ( resnam ) ! arguments character ( len = 80 ) :: resnam !locals integer :: i do i = 1 , nlibres if ( lib ( i )% nam == resnam ) then write ( * , 100 ) trim ( resnam ) 100 format ( '>>> WARNING: Overloading old definition of ' , a ) lib ( i )% nam = 'gone' exit end if end do end subroutine check_overload subroutine oldreadparm ( flag ) !       arguments LOGICAL flag ! *** local variables integer i , ityp , filestat character ( 200 ) :: line character ( len = KEYLENGTH ) :: taci , tacj , tack , tacl integer :: iaci , iacj , iack , iacl !....................................................................... !set default values for options which are not available in old param. file iuse_switch_atom = 1 !this is the default. It can be overridden !in old libraries by setting switch atoms to 0 !new parameter files have the keyword switch_atoms (sec. options) !to control this coulomb_constant = 33 2.0 imp_explicit = . false . imp_type = 1 !harmonic impropers ff_type = FF_GROMOS flag = . true . CALL skip_comments ( 2 ) i = 0 READ ( 2 , * , err = 1000 ) nbnd_prm CALL skip_comments ( 2 ) if ( allocated ( bnd_prm )) deallocate ( bnd_prm ) if ( allocated ( bnd_types )) deallocate ( bnd_types ) allocate ( bnd_prm ( nbnd_prm ), stat = alloc_status ) allocate ( bnd_types ( nbnd_prm ), stat = alloc_status ) call check_alloc ( 'bond parameters' ) do i = 1 , nbnd_prm READ ( 2 , * , err = 1000 ) iaci , iacj , bnd_prm ( i )% prm % fk , bnd_prm ( i )% prm % bnd0 bnd_types ( i )% taci = tac ( iaci ) bnd_types ( i )% tacj = tac ( iacj ) bnd_prm ( i )% SYBYLtype = '1 ' !set to default enddo write ( * , 110 ) nbnd_prm , 'bond types' CALL skip_comments ( 2 ) i = 0 READ ( 2 , * , err = 1010 ) nang_prm CALL skip_comments ( 2 ) if ( allocated ( ang_prm )) deallocate ( ang_prm ) allocate ( ang_prm ( nang_prm ), stat = alloc_status ) if ( allocated ( ang_types )) deallocate ( ang_types ) allocate ( ang_types ( nang_prm ), stat = alloc_status ) call check_alloc ( 'angle parameters' ) !set optional parameters to 0. ang_prm (:)% ureyfk = 0. ang_prm (:)% ureyr0 = 0. do i = 1 , nang_prm read ( 2 , '(a80)' , err = 1010 ) line read ( line , * , iostat = filestat ) iaci , iacj , iack , ang_prm ( i ) ang_types ( i )% taci = tac ( iaci ) ang_types ( i )% tacj = tac ( iacj ) ang_types ( i )% tack = tac ( iack ) !accept missing parameters but not read error if ( filestat > 0 ) goto 1010 enddo write ( * , 110 ) nang_prm , 'angle types' CALL skip_comments ( 2 ) i = 0 READ ( 2 , * , err = 1020 ) ntor_prm CALL skip_comments ( 2 ) if ( allocated ( tor_prm )) deallocate ( tor_prm ) allocate ( tor_prm ( ntor_prm ), stat = alloc_status ) if ( allocated ( tor_types )) deallocate ( tor_types ) allocate ( tor_types ( ntor_prm ), stat = alloc_status ) call check_alloc ( 'torsion parameters' ) do i = 1 , ntor_prm READ ( 2 , * , err = 1020 ) iaci , iacj , iack , iacl , tor_prm ( i ) tor_types ( i )% taci = tac ( iaci ) tor_types ( i )% tacj = tac ( iacj ) tor_types ( i )% tack = tac ( iack ) tor_types ( i )% tacl = tac ( iacl ) enddo write ( * , 110 ) ntor_prm , 'torsion types' CALL skip_comments ( 2 ) i = 0 READ ( 2 , * , err = 1030 ) nimp_prm CALL skip_comments ( 2 ) if ( allocated ( imp_prm )) deallocate ( imp_prm ) allocate ( imp_prm ( nimp_prm ), stat = alloc_status ) call check_alloc ( 'improper parameters' ) do i = 1 , nimp_prm READ ( 2 , * , err = 1030 ) iacj , iack , imp_prm ( i )% prm imp_prm ( i )% taci = '' !not used imp_prm ( i )% tacj = tac ( iacj ) imp_prm ( i )% tack = tac ( iack ) imp_prm ( i )% tacl = '' !not used enddo write ( * , 110 ) nimp_prm , 'improper types' CALL skip_comments ( 2 ) i = 0 READ ( 2 , * , err = 1040 ) natyps READ ( 2 , * , err = 1040 ) ivdw_rule READ ( 2 , * , err = 1040 ) el14_scale CALL skip_comments ( 2 ) !if no PDB file read (blank topology) if ( allocated ( iaclib )) deallocate ( iaclib ) max_atyps = max_old_atyps allocate ( iaclib ( max_atyps )) if ( allocated ( SYBYL_atom_type )) deallocate ( SYBYL_atom_type ) allocate ( SYBYL_atom_type ( max_atyps )) if ( allocated ( tac )) deallocate ( tac ) allocate ( tac ( max_atyps )) !clear atom type parameters do i = 1 , max_atyps iaclib ( i )% avdw (:) = 0. iaclib ( i )% bvdw (:) = 0. iaclib ( i )% mass = 0. SYBYL_atom_type ( i ) = '     ' tac ( i ) = '' end do call index_create ( natyps ) do i = 1 , natyps READ ( 2 , * , err = 1040 ) ityp , iaclib ( ityp )% avdw ( 1 ), iaclib ( ityp )% avdw ( 2 ), & iaclib ( ityp )% bvdw ( 1 ), iaclib ( ityp )% avdw ( 3 ), iaclib ( ityp )% bvdw ( 3 ), & iaclib ( ityp )% mass iaclib ( ityp )% bvdw ( 2 ) = iaclib ( ityp )% bvdw ( 1 ) write ( taci , '(i4)' ) ityp tac ( ityp ) = adjustl ( taci ) if (. not . index_add ( tac ( ityp ), ityp )) then write ( * , 130 ) tac ( i ) end if enddo write ( * , 110 ) natyps , 'atom types' CALL skip_comments ( 2 ) i = 0 READ ( 2 , * , err = 1050 ) nlj2 CALL skip_comments ( 2 ) if ( allocated ( lj2 )) deallocate ( lj2 ) allocate ( lj2 ( nlj2 )) do i = 1 , nlj2 READ ( 2 , * , err = 1050 ) lj2 ( i )% i , lj2 ( i )% j enddo write ( * , 110 ) nlj2 , 'LJ type 2 pairs' write ( * , '(a,/)' ) 'Force field parameters successfully read.' return 110 format ( 'Read ' , i4 , ' ' , a ) 120 format ( '>>> ERROR: Failed to read ' , a , ' number ' , i4 ) 130 format ( '>>> ERROR: Could not enumerate atom type ' , a , '. Duplicate name?' ) 1000 write ( * , 120 ) 'bond type' , i flag = . false . return 1010 write ( * , 120 ) 'angle type' , i flag = . false . return 1020 write ( * , 120 ) 'torsion type' , i flag = . false . return 1030 write ( * , 120 ) 'improper type' , i flag = . false . return 1040 write ( * , 120 ) 'atom type' , i flag = . false . return 1050 write ( * , 120 ) 'LJ type 2 pair' , i flag = . false . return !....................................................................... end subroutine oldreadparm subroutine readff !read parameters if (. not . have_prm_file_name ) then call get_string_arg ( prm_file , '-----> Name of FF parameter file: ' ) have_prm_file_name = . true . endif inquire ( file = prm_file , exist = have_prm_file_name ) if (. not . have_prm_file_name ) then write ( * , 10 ) trim ( prm_file ) return end if 10 format ( '>>>>> ERROR: ' , a , ' does not exist.' ) if (. not . prm_open ( prm_file )) then !if reading fails try old format write ( * , '(a)' ) '>>>>>WARNING: Attempting to read old-style parameter file.' if ( openit ( 2 , prm_file , 'old' , 'formatted' , 'read' ) /= 0 ) return CALL oldreadparm ( ff_ok ) close ( 2 ) else call readparm ( prm_file ) !this will set global flag topo_ok call prm_close end if end subroutine readff subroutine readparm ( filnam ) !       arguments character ( * ) :: filnam ! *** local variables integer :: i , ityp , j character ( len = 200 ) :: line , restofline real :: rdummy logical :: ldummy character ( len = KEYLENGTH ) :: taci , tacj , tack , tacl integer :: iaci , iacj , iack , iacl character ( len = 80 ) :: section logical :: SYBYL_warn = . false . integer :: naliases type ( BOND_PRM_TYPE ) :: bnd_prm_tmp type ( ANGLIB_TYPE ) :: ang_prm_tmp type ( TORLIB_TYPE ) :: tor_prm_tmp !....................................................................... ff_ok = . false . write ( * , 10 ) 10 format ( / , 'Reading force field parameter file.' ) !parameter file is opened by maketop if (. not . prm_open_section ( 'options' )) then write ( * , * ) '>>> WARNING: Options section not found in parameter file.' write ( * , * ) '    Trying to read old style parameter file:' call prm_close () if ( openit ( 2 , filnam , 'old' , 'formatted' , 'read' ) /= 0 ) return CALL oldreadparm ( ff_ok ) close ( 2 ) return end if if ( prm_get_string_by_key ( 'name' , forcefield )) then write ( * , 20 ) trim ( forcefield ) end if 20 format ( 'Forcefield name:' , t32 , a ) if (. not . prm_get_string_by_key ( 'type' , line )) then !also accept the keyword force_field for the same purpose ldummy = prm_get_string_by_key ( 'force_field' , line , 'GROMOS' ) end if call upcase ( line ) write ( * , 22 ) trim ( line ) select case ( line ) case ( 'GROMOS' ) ff_type = FF_GROMOS case ( 'AMBER' ) ff_type = FF_AMBER case ( 'CHARMM' ) ff_type = FF_CHARMM case default write ( * , 24 ) return end select 22 format ( 'Forcefield type:' , t32 , a ) 24 format ( '>>>>> ERROR: forcefield type must be one of GROMOS, AMBER, CHARMM' ) if (. not . prm_get_string_by_key ( 'vdw_rule' , line )) then write ( * , * ) '>>> ERROR: vdw_rule in options section not found in parameter file.' return end if call upcase ( line ) write ( * , 30 ) trim ( line ) 30 format ( 'Lennard-Jones combination rule:' , t32 , a ) if ( line ( 1 : 9 ) == 'GEOMETRIC' ) then ivdw_rule = 1 else if ( line ( 1 : 10 ) == 'ARITHMETIC' ) then ivdw_rule = 2 else write ( * , * ) '>>> ERROR: vdw_rule must be geometric or arithmetic.' return end if if (. not . prm_get_real_by_key ( 'scale_14' , rdummy )) then write ( * , * ) '>>> ERROR: scale_14 in options section not found in parameter file.' return end if el14_scale = real ( rdummy , 8 ) write ( * , 40 ) el14_scale 40 format ( 'Scaling of 1-4 electrostatics:' , t31 , f6 . 3 ) if ( prm_get_logical_by_key ( 'switch_atoms' , ldummy )) then if ( ldummy ) then iuse_switch_atom = 1 write ( * , 50 ) 'switching atoms' else iuse_switch_atom = 0 write ( * , 50 ) 'any atoms' end if else iuse_switch_atom = 1 !default write ( * , 50 ) 'switching atoms' end if 50 format ( 'Cut-off rule:' , t32 , a ) !read improper potential type (harmonic (default) or periodic) ldummy = prm_get_string_by_key ( 'improper_potential' , line , 'HARMONIC' ) call upcase ( line ) write ( * , 60 ) trim ( line ) 60 format ( 'Improper potential:' , t32 , a ) if ( line == 'HARMONIC' ) then imp_type = 1 else if ( line == 'PERIODIC' ) then imp_type = 2 else write ( * , * ) '>>> ERROR: improper_potential must be harmonic or periodic.' return end if !read improper definition scheme (automatic (default) or explicit) ldummy = prm_get_string_by_key ( 'improper_definition' , line , 'AUTOMATIC' ) call upcase ( line ) write ( * , 70 ) trim ( line ) 70 format ( 'Improper generation:' , t32 , a ) if ( line == 'AUTOMATIC' ) then imp_explicit = . false . else if ( line == 'EXPLICIT' ) then imp_explicit = . true . else write ( * , * ) '>>> ERROR: improper_definition must be automatic or explicit.' return end if if (. not . prm_get_real_by_key ( 'coulomb_constant' , rdummy )) then print '(a)' , 'Coulomb constant is set to the default value of 332.' !write(*,*) 'Coulomb constant is set to the default value of 332.' coulomb_constant = 33 2.0 else coulomb_constant = real ( rdummy , 8 ) write ( * , 80 ) coulomb_constant end if 80 format ( 'Coulomb constant:' , t32 , f8 . 4 ) section = 'atom_types' natyps = prm_count ( section ) if ( natyps == 0 ) then write ( * , * ) '>>> ERROR: No atom_types defined.' return end if !if no PDB file read (blank topology) if ( allocated ( iaclib )) deallocate ( iaclib ) allocate ( iaclib ( natyps )) if ( allocated ( SYBYL_atom_type )) deallocate ( SYBYL_atom_type ) allocate ( SYBYL_atom_type ( natyps )) if ( allocated ( tac )) deallocate ( tac ) allocate ( tac ( natyps )) !clear atom type parameters do i = 1 , natyps iaclib ( i )% avdw (:) = 0. iaclib ( i )% bvdw (:) = 0. iaclib ( i )% mass = 0. SYBYL_atom_type ( i ) = '     ' tac ( i ) = '' end do !change number of atom types in topology max_atyps = natyps !initialize atom type lookup table call index_create ( natyps ) do i = 1 , natyps if (. not . prm_get_line ( line )) goto 1040 READ ( line , * , iostat = j ) tac ( i ), iaclib ( i )% avdw ( 1 ), iaclib ( i )% avdw ( 2 ), & iaclib ( i )% bvdw ( 1 ), iaclib ( i )% avdw ( 3 ), & iaclib ( i )% bvdw ( 3 ), iaclib ( i )% mass , SYBYL_atom_type ( i ) iaclib ( i )% bvdw ( 2 ) = iaclib ( i )% bvdw ( 1 ) if ( j > 0 ) goto 1040 if ( j < 0 ) SYBYL_warn = . true . if (. not . index_add ( tac ( i ), i )) then write ( * , 130 ) tac ( i ) end if enddo write ( * , 110 ) natyps , 'atom types' if ( SYBYL_warn ) write ( * , '(a)' ) & '>>>>> WARNING: No SYBYL name for one or more atom types.' SYBYL_warn = . false . !reset section = 'atom_aliases' naliases = prm_count ( section ) if ( naliases > 0 ) call index_resize ( natyps + naliases ) do i = 1 , naliases if (. not . prm_get_string_string ( taci , tacj )) then goto 1060 !make tac1 an alias for tac2 elseif (. not . index_alias ( taci , tacj )) then write ( * , 140 ) i , trim ( section ), tacj goto 1060 end if end do write ( * , 110 ) naliases , 'atom type alias names' j = 0 do i = 1 , natyps if (. not . index_get ( tac ( i ), ityp )) then write ( * , '(a,a,a)' ) 'ERROR: Failed to retrieve atom type ' , tac ( i ), ' from index.' else j = j + 1 end if end do if ( j < natyps ) then write ( * , * ) '>>>>> ERROR: Bug in indexer, not all atom types found.' call prm_close return end if section = 'LJ_type2_pairs' nlj2 = prm_count ( section ) if ( allocated ( lj2 )) deallocate ( lj2 ) allocate ( lj2 ( nlj2 )) do i = 1 , nlj2 if (. not . prm_get_string_string ( taci , tacj )) goto 1050 if (. not . index_get ( taci , iaci )) then write ( * , 140 ) i , trim ( section ), taci goto 1050 end if lj2 ( i )% i = iaci if (. not . index_get ( tacj , iacj )) then write ( * , 140 ) i , trim ( section ), tacj goto 1050 end if lj2 ( i )% j = iacj enddo write ( * , 110 ) nlj2 , 'LJ type 2 pairs' section = 'bonds' nbnd_types = prm_count ( section ) nbnd_prm = 0 !will accumulate this while reading if ( allocated ( bnd_prm )) deallocate ( bnd_prm ) if ( allocated ( bnd_types )) deallocate ( bnd_types ) allocate ( bnd_prm ( nbnd_types ), stat = alloc_status ) allocate ( bnd_types ( nbnd_types ), stat = alloc_status ) call check_alloc ( 'bond parameters' ) bnd_prm_tmp % SYBYLtype = '   ' bondloop : do i = 1 , nbnd_types if (. not . prm_get_line ( line )) goto 1000 read ( line , * , iostat = j ) taci , tacj , bnd_prm_tmp if ( j > 0 ) goto 1000 if ( j < 0 ) SYBYL_warn = . true . if (. not . index_get ( taci , iaci )) then write ( * , 140 ) i , trim ( section ), taci goto 1060 end if if (. not . index_get ( tacj , iacj )) then write ( * , 140 ) i , trim ( section ), tacj goto 1060 end if !make sure to expand any aliases bnd_types ( i )% taci = tac ( iaci ) bnd_types ( i )% tacj = tac ( iacj ) do j = 1 , nbnd_prm if ( bnd_prm ( j )% prm % fk == bnd_prm_tmp % prm % fk . and . bnd_prm ( j )% prm % bnd0 == bnd_prm_tmp % prm % bnd0 ) then bnd_types ( i )% cod = j cycle bondloop !skip to next endif end do nbnd_prm = nbnd_prm + 1 bnd_prm ( nbnd_prm ) = bnd_prm_tmp bnd_types ( i )% cod = nbnd_prm end do bondloop write ( * , 110 ) nbnd_types , 'bond types' write ( * , 110 ) nbnd_prm , 'unique bond parameters' if ( SYBYL_warn ) write ( * , '(a)' ) & '>>>>> WARNING: No SYBYL bond type for one or more bond types.' SYBYL_warn = . false . !reset section = 'angles' nang_types = prm_count ( section ) nang_prm = 0 !accumulate unique parameters while reading if ( nang_types == 0 ) then write ( * , * ) '>>> ERROR: Angles section not found in parameter file.' return end if if ( allocated ( ang_prm )) deallocate ( ang_prm ) allocate ( ang_prm ( nang_types ), stat = alloc_status ) if ( allocated ( ang_types )) deallocate ( ang_types ) allocate ( ang_types ( nang_types ), stat = alloc_status ) call check_alloc ( 'angle parameters' ) !set optional parameters to 0. ang_prm (:)% ureyfk = 0. ang_prm (:)% ureyr0 = 0. !need to set optional parameters to 0 in ang_prm_tmp, above has no effect (???) ang_prm_tmp % ureyfk = 0. ang_prm_tmp % ureyr0 = 0. angloop : do i = 1 , nang_types if (. not . prm_get_line ( line )) goto 1010 read ( line , * , iostat = j ) taci , tacj , tack , ang_prm_tmp !accept missing parameters but not read error if ( j > 0 ) goto 1060 if (. not . index_get ( taci , iaci )) then write ( * , 140 ) i , trim ( section ), taci goto 1060 end if if (. not . index_get ( tacj , iacj )) then write ( * , 140 ) i , trim ( section ), tacj goto 1060 end if if (. not . index_get ( tack , iack )) then write ( * , 140 ) i , trim ( section ), tack goto 1060 end if !make sure to expand any aliases ang_types ( i )% taci = tac ( iaci ) ang_types ( i )% tacj = tac ( iacj ) ang_types ( i )% tack = tac ( iack ) do j = 1 , nang_prm if ( ang_prm ( j )% fk == ang_prm_tmp % fk . and . & ang_prm ( j )% ang0 == ang_prm_tmp % ang0 . and . & ang_prm ( j )% ureyfk == ang_prm_tmp % ureyfk . and . & ang_prm ( j )% ureyr0 == ang_prm_tmp % ureyr0 ) then ang_types ( i )% cod = j cycle angloop !skip to next endif end do nang_prm = nang_prm + 1 ang_prm ( nang_prm ) = ang_prm_tmp ang_types ( i )% cod = nang_prm end do angloop write ( * , 110 ) nang_types , 'angle types' write ( * , 110 ) nang_prm , ' unique angle parameters' section = 'torsions' ntor_types = prm_count ( section ) ntor_prm = 0 !accumulate unique parameters while reading if ( ntor_types == 0 ) then write ( * , * ) '>>> ERROR: Torsions section not found in parameter file.' return end if if ( allocated ( tor_prm )) deallocate ( tor_prm ) allocate ( tor_prm ( ntor_types ), stat = alloc_status ) if ( allocated ( tor_types )) deallocate ( tor_types ) allocate ( tor_types ( ntor_types ), stat = alloc_status ) call check_alloc ( 'torsion parameters' ) torloop : do i = 1 , ntor_types if (. not . prm_get_line ( line )) goto 1020 read ( line , * , err = 1020 ) taci , tacj , tack , tacl , tor_prm_tmp if ( index_get ( taci , iaci , allow_wildcard = . true .)) then if ( iaci > 0 ) then tor_types ( i )% taci = tac ( iaci ) else !wildcard found tor_types ( i )% taci = '' endif else !atom type not found and not a wildcard => error write ( * , 140 ) i , trim ( section ), taci goto 1060 end if if ( index_get ( tacj , iacj , allow_wildcard = . true .)) then if ( iacj > 0 ) then tor_types ( i )% tacj = tac ( iacj ) else tor_types ( i )% tacj = '' endif else write ( * , 140 ) i , trim ( section ), tacj goto 1060 end if if ( index_get ( tack , iack , allow_wildcard = . true .)) then if ( iack > 0 ) then tor_types ( i )% tack = tac ( iack ) else tor_types ( i )% tack = '' endif else write ( * , 140 ) i , trim ( section ), tack goto 1060 end if if ( index_get ( tacl , iacl , allow_wildcard = . true .)) then if ( iacl > 0 ) then tor_types ( i )% tacl = tac ( iacl ) else tor_types ( i )% tacl = '' endif else !this field may be 0 tor_types ( i )% tacl = '' end if do j = 1 , ntor_prm if ( tor_prm ( j )% fk == tor_prm_tmp % fk . and . & tor_prm ( j )% rmult == tor_prm_tmp % rmult . and . & tor_prm ( j )% deltor == tor_prm_tmp % deltor . and . & tor_prm ( j )% paths == tor_prm_tmp % paths ) then tor_types ( i )% cod = j cycle torloop !skip to next endif end do ntor_prm = ntor_prm + 1 tor_prm ( ntor_prm ) = tor_prm_tmp tor_types ( i )% cod = ntor_prm end do torloop write ( * , 110 ) ntor_types , 'torsion types' write ( * , 110 ) ntor_prm , 'unique torsion parameters' section = 'impropers' nimp_prm = prm_count ( section ) if ( ntor_prm == 0 ) then write ( * , * ) '>>> ERROR: Impropers section not found in parameter file.' return end if if ( allocated ( imp_prm )) deallocate ( imp_prm ) allocate ( imp_prm ( nimp_prm ), stat = alloc_status ) call check_alloc ( 'improper parameters' ) do i = 1 , nimp_prm if (. not . prm_get_line ( line )) goto 1030 read ( line , * , err = 1030 ) taci , tacj , tack , tacl , imp_prm ( i )% prm if ( index_get ( taci , iaci )) then imp_prm ( i )% taci = tac ( iaci ) else !this field may be wild-card imp_prm ( i )% taci = '' end if if ( index_get ( tacj , iacj )) then imp_prm ( i )% tacj = tac ( iacj ) else !this field may be wild-card imp_prm ( i )% tacj = '' end if if ( index_get ( tack , iack )) then imp_prm ( i )% tack = tac ( iack ) else !this field may be wild-card imp_prm ( i )% tack = '' end if if ( index_get ( tacl , iacl )) then imp_prm ( i )% tacl = tac ( iacl ) else !this field may be wild-card imp_prm ( i )% tacl = '' end if end do write ( * , 110 ) nimp_prm , 'improper types' write ( * , '(a,/)' ) 'Force field parameters successfully read.' ff_ok = . true . call prm_close () return 110 format ( 'Read ' , i4 , ' ' , a ) 120 format ( '>>> ERROR: Failed to read ' , a , ' number ' , i4 ) 130 format ( '>>> ERROR: Could not enumerate atom type ' , a , '. Duplicate name?' ) 140 format ( '>>> ERROR at line ' , i3 , ' of section ' , a , ': Atom type ' , a , ' not found.' ) 1000 write ( * , 120 ) 'bond type' , i call prm_close () return 1010 write ( * , 120 ) 'angle type' , i call prm_close () return 1020 write ( * , 120 ) 'torsion type' , i call prm_close () return 1030 write ( * , 120 ) 'improper type' , i call prm_close () return 1040 write ( * , 120 ) 'atom type' , i call prm_close () return 1050 write ( * , 120 ) 'LJ type 2 pair' , i call prm_close () return 1060 write ( * , 120 ) trim ( section ), i call prm_close () return !....................................................................... end subroutine readparm subroutine clearpdb nres = 0 nres_solute = 0 nmol = 0 nat_pro = 0 nat_solute = 0 topo_ok = . false . if ( allocated ( makeH )) deallocate ( makeH ) if ( allocated ( heavy )) deallocate ( heavy ) if ( allocated ( xtop )) deallocate ( xtop ) if ( allocated ( res )) deallocate ( res ) if ( allocated ( istart_mol )) deallocate ( istart_mol ) end subroutine clearpdb subroutine cleartop !forget the name of the parameter file have_prm_file_name = . false . have_solute_sphere = . false . have_title = . false . topo_ok = . false . end subroutine cleartop logical function countpdb ( pdb_fileno , atoms , residues , molecules ) !count atoms, residues and molecules in a pdb file !arguments integer :: pdb_fileno , atoms , residues , molecules !locals integer :: resno , oldno character ( len = 4 ) :: resnam , atnam , oldresnam character ( len = 80 ) :: line real :: xtmp ( 3 ) integer :: atoms_in_res , atoms_in_file integer :: rescode , oldrescode ! old 10        format(13x,a4,a4,i5,4x,3f8.3) 10 format ( 12 x , a5 , a3 , 2 x , i4 , 4 x , 3 f8 . 3 ) countpdb = . true . atoms = 0 residues = 0 molecules = 1 atoms_in_file = 0 rescode = 0 oldrescode = 0 oldno = 0 do read ( pdb_fileno , '(a)' , end = 100 ) line if ( adjustl ( line ) == 'GAP' . or . line ( 1 : 6 ) == 'TER   ' ) then molecules = molecules + 1 oldrescode = 0 !avoid implicit gap check else if ( line ( 1 : 6 ) /= 'HETATM' . and . line ( 1 : 6 ) /= 'ATOM  ' ) then write ( * , '(a,/,a)' ) '>>>WARNING: ignoring unrecognised line in PDB file' , trim ( line ) else READ ( line , 10 , end = 100 , err = 200 ) atnam , resnam , resno , xtmp ( 1 : 3 ) if ( resno /= oldno ) then if ( rescode /= 0 ) then !check it if ( atoms_in_res > lib ( rescode )% nat ) then write ( * , 12 ) oldresnam , oldno countpdb = . false . end if atoms = atoms + lib ( rescode )% nat end if !lookup the new one do rescode = nlibres , 1 , - 1 if ( lib ( rescode )% nam == resnam ) exit end do if ( rescode == 0 ) then write ( * , 11 ) resno , resnam countpdb = . false . end if !check for implicit GAP if ( oldrescode /= 0 . and . rescode /= 0 ) then if ( lib ( oldrescode )% tail == 0 . or . & lib ( rescode )% head == 0 ) then molecules = molecules + 1 end if end if !remember previous rescode oldrescode = rescode oldno = resno oldresnam = resnam atoms_in_res = 0 residues = residues + 1 else if ( oldrescode /= 0 . and . resnam /= oldresnam ) then !numbering problem? write ( * , 13 ) oldresnam , resno , resnam countpdb = . false . end if atoms_in_file = atoms_in_file + 1 atoms_in_res = atoms_in_res + 1 end if !rewind but leave open end do !branch here at EOF !take care of last residue 100 if ( rescode /= 0 ) then !check it if ( atoms_in_res > lib ( rescode )% nat ) then write ( * , 12 ) oldresnam , oldno countpdb = . false . end if atoms = atoms + lib ( rescode )% nat end if write ( * , 15 ) atoms_in_file , atoms rewind ( pdb_fileno ) if ( atoms_in_file == 0 ) countpdb = . false . return 200 rewind ( pdb_fileno ) !error exit point write ( * , 16 ) line countpdb = . false . 16 format ( '>>>>> ERROR found in line: ' , a80 ) 11 format ( '>>>>> ERROR: Residue number ' , i5 , ' is of unknown type ' , a4 ) 12 format ( '>>>>> ERROR: Too many atoms in residue ' , a4 , 1 x , i5 ) 13 format ( '>>>>> ERROR: Two residues with same number: ' , a , i5 , 1 x , a ) 15 format ( 'PDB file contains' , i6 , ' atoms.' , / , & 'The number of atoms in the topology will be' , i6 ) end function countpdb subroutine readpdb () ! *** local variables character ( len = 256 ) :: pdb_file CHARACTER atnam_tmp * 4 , resnam_tmp * 4 character ( len = 80 ) :: line integer resnum_tmp , oldnum , irec , i , atom_id ( max_atlib ), j real xtmp ( 3 ) LOGICAL res_found , at_found integer :: first_res_of_mol logical :: last_line_was_gap integer :: atoms , residues , molecules !....................................................................... write ( * , * ) call get_string_arg ( pdb_file , '-----> Name of PDB file: ' ) if ( openit ( 3 , pdb_file , 'old' , 'formatted' , 'read' ) /= 0 ) return REWIND ( 3 ) ! !       PDB format(we need only atom name, res. name, number and coords): !   The format is !   1. |    1 -  6    |   A6    | Record ID (eg ATOM, HETATM) !   2. |    7 - 11    |   I5    | Atom serial number !   -  |   12 - 12    |   1X    | Blank !   3. |   13 - 16    |   A4    | Atom name (eg \" CA \" , \" ND1\") !   4. |   17 - 17    |   A1    | Alternative location code (if any) !   5. |   18 - 20    |   A3    | Standard 3-letter amino acid code for residue !   -  |   21 - 21    |   1X    | Blank !   6. |   22 - 22    |   A1    | Chain identifier code !   7. |   23 - 26    |   I4    | Residue sequence number !   8. |   27 - 27    |   A1    | Insertion code (if any) !   -  |   28 - 30    |   3X    | Blank !   9. |   31 - 38    |  F8.3   | Atom's x-coordinate !  10. |   39 - 46    |  F8.3   | Atom's y-coordinate !  11. |   47 - 54    |  F8.3   | Atom's z-coordinate !  12. |   55 - 60    |  F6.2   | Occupancy value for atom !  13. |   61 - 66    |  F6.2   | B-value (thermal factor) ! !Old format line  10    FORMAT(13x,a4,a4,i5,4x,3f8.3) !Format if all is read  10      format(a6,i5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3f8.3) 10 format ( 12 x , a5 , a3 , 2 x , i4 , 4 x , 3 f8 . 3 ) !       progress output formats 20 format ( 'molecule ' , i4 , ': ' , a4 , i5 ) 21 format ( ' - ' , a4 , i5 ) 22 format ( '>>>>> ERROR: The check of the PDB file failed.' ) 23 format ( '>>> WARNING: Multiple GAP lines at line' , i5 ) oldnum = 0 !get rid of old topology but not FF params call topo_deallocate ( keep_ff = . true .) if (. not . countpdb ( 3 , atoms , residues , molecules )) then write ( * , 22 ) close ( 3 ) return end if CALL clearpdb !get rid of old PDB data. call allocate_for_pdb ( atoms , residues , molecules ) !make space for new topology !clear hydrogen make flags makeH (:) = . false . !reset molecule counter nmol = 1 istart_mol ( 1 ) = 1 irec = 0 do read ( 3 , '(a)' , end = 100 ) line irec = irec + 1 if ( adjustl ( line ) == 'GAP' . or . line ( 1 : 6 ) == 'TER   ' ) then if ( last_line_was_gap ) then write ( * , 23 ) irec else !set gap flag - new molecule will be recognised later last_line_was_gap = . true . end if else if ( line ( 1 : 6 ) /= 'HETATM' . and . line ( 1 : 6 ) /= 'ATOM  ' ) then !do nothing else READ ( line , 10 , end = 100 , err = 200 ) atnam_tmp , resnam_tmp , & resnum_tmp , xtmp ( 1 : 3 ) ! ---   New residue ? if ( resnum_tmp /= oldnum ) then ! ---      Check if old residue was OK... if ( nres /= 0 ) then do i = 1 , lib ( res ( nres )% irc )% nat if ( lib ( res ( nres )% irc )% atnam ( i )( 1 : 1 ) /= 'H' ) then !heavy heavy ( res ( nres )% start - 1 + i ) = . true . makeH ( res ( nres )% start - 1 + i ) = . false . if ( atom_id ( i ) == 0 ) then !not found write ( * , '(/,a,a,a,i5,/)' ) '>>> Heavy atom ' ,& lib ( res ( nres )% irc )% atnam ( i ), & ' missing in residue ' , oldnum goto 210 end if else !hydrogen heavy ( res ( nres )% start - 1 + i ) = . false . !flag hydrogens to be generated if ( atom_id ( i ) == 0 ) then !it was not in the file and needs to be made makeH ( res ( nres )% start - 1 + i ) = . true . end if end if enddo endif !look up new residue in library res_found = . false . nres = nres + 1 res ( nres )% start = nat_pro + 1 do i = 1 , nlibres if ( resnam_tmp == lib ( i )% nam ) then res_found = . true . res ( nres )% name = lib ( i )% nam res ( nres )% irc = i exit endif enddo if (. not . res_found ) then write ( * , '(/,a,a,/)' ) '>>> Residue not found in library: ' , & resnam_tmp goto 210 endif !clear atom read flags do i = 1 , lib ( res ( nres )% irc )% nat atom_id ( i ) = 0 enddo !check for implicit GAP, i.e. this residue and previous !have no tail or head connections, respectively. !Do this unless this is the first residue !Don't do it if previous line was gap (already done) if ( nres > 1 ) then if ( last_line_was_gap . or . & lib ( res ( nres - 1 )% irc )% tail == 0 . or . & lib ( res ( nres )% irc )% head == 0 ) then nmol = nmol + 1 istart_mol ( nmol ) = nat_pro + 1 if ( first_res_of_mol /= oldnum ) then write ( * , 21 ) res ( nres - 1 )% name , oldnum else write ( * , * ) end if end if end if last_line_was_gap = . false . !if new molecule write output if ( nat_pro + 1 == istart_mol ( nmol )) then write ( * , 20 , advance = 'no' ) nmol , resnam_tmp , resnum_tmp first_res_of_mol = resnum_tmp end if nat_pro = nat_pro + lib ( res ( nres )% irc )% nat !set nat_solute = nat_pro unless residue is water if ( index ( solvent_names , trim ( resnam_tmp )) == 0 ) then nat_solute = nat_pro nres_solute = nres end if oldnum = resnum_tmp endif !new residue at_found = . false . do i = 1 , lib ( res ( nres )% irc )% nat if ( atnam_tmp == lib ( res ( nres )% irc )% atnam ( i )) then at_found = . true . atom_id ( i ) = 1 j = res ( nres )% start - 1 + i xtop ( j * 3 - 2 ) = xtmp ( 1 ) xtop ( j * 3 - 1 ) = xtmp ( 2 ) xtop ( j * 3 ) = xtmp ( 3 ) exit endif enddo !i if (. not . at_found ) then write ( * , '(/,a,a,a,i5,a,a,/)' ) '>>> Atom ' , atnam_tmp , & ' in residue no. ' , resnum_tmp , ' not found in library entry for ' , & lib ( res ( nres )% irc )% nam goto 210 endif !.not.at_found end if !line type enddo !branch here at EOF 100 close ( 3 ) if ( last_line_was_gap ) then write ( * , '(a)' ) '>>> Warning: PDB file ends with GAP line.' nmol = nmol - 1 !correct molecule count else !print last residue of last molecule if more than one if ( first_res_of_mol /= oldnum ) then write ( * , 21 ) resnam_tmp , oldnum else write ( * , * ) end if end if ! --- Check if last residue was OK... if ( nres > 0 ) then !avoid crashing when reading empty file do i = 1 , lib ( res ( nres )% irc )% nat if ( lib ( res ( nres )% irc )% atnam ( i )( 1 : 1 ) /= 'H' ) then !it is a heavy (non-H) atom heavy ( res ( nres )% start - 1 + i ) = . true . makeH ( res ( nres )% start - 1 + i ) = . false . if ( atom_id ( i ) == 0 ) then !it was not found write ( * , '(/,a,a,a,i5,/)' ) '>>> Heavy atom ' , & lib ( res ( nres )% irc )% atnam ( i ), ' missing in residue ' , oldnum goto 210 end if else !it is a hydrogen heavy ( res ( nres )% start - 1 + i ) = . false . if ( atom_id ( i ) == 0 ) then !it was not read from the file and should be gerenated makeH ( res ( nres )% start - 1 + i ) = . true . end if end if enddo end if nwat = ( nat_pro - nat_solute ) / 3 write ( * , 110 ) nmol , nres , nres_solute , nat_pro , nat_solute 110 format ( / , 'Successfully read PDB file with' , i5 , ' molecules,' , / ,& i5 , ' residues total (' , i5 , ' in solute).' , / ,& i5 , ' atoms total (' , i5 , ' in solute).' ) write ( * , '(/,a,/)' ) 'Sequence listing:' write ( * , '(16(a4,1x))' ) res ( 1 : nres )% name write ( * , * ) return !       error handling 200 write ( * , '(/,a,i5,/)' ) '>>> Read error on line ' , irec 210 write ( * , '(a)' ) 'Correct the PDB file and try readpdb again!' write ( * , '(a)' ) 'If the problem is in the library you need to correct it and do' ,& 'clearlib and readlib before trying readpdb again.' close ( 3 ) CALL clearpdb pdb_file = '' end subroutine readpdb subroutine readtop ! *** local variables character ( len = 200 ) :: filnam character ( len = 200 ) :: files_to_load integer :: i , j , ires logical :: loaded , res_found integer :: fn_start , fn_end , totlen character ( len = 4 ) :: resnam_tmp CALL get_string_arg ( filnam , '-----> Give name of(old) topology file: ' ) if ( openit ( 10 , filnam , 'old' , 'formatted' , 'read' ) /= 0 ) return !tell topo_read to allocate some extra space for bonds topo_ok = topo_read ( u = 10 , require_version = 2.0 , extrabonds = max_extrabnd ) close ( 10 ) if (. not . topo_ok ) return have_title = . true . call set_default_mask !sphere is defined if topology is version 4 or later if ( version >= 4 ) then have_solute_sphere = . true . have_solvent_boundary = . true . end if !boundary condition is defined if topology is version 4.30 or later if ( version >= 4.30 ) then boundary_set = . true . end if coord_source = 'topology' auto_name = filnam !for automatic naming of pdb and mol2 files nwat = ( nat_pro - nat_solute ) / 3 !reset makeH - don't need to make any hydrogens deallocate ( makeH , stat = alloc_status ) allocate ( makeH ( nat_pro )) makeH (:) = . false . if ( nlibres == 0 ) then !auto-load libraries write ( * , 100 ) 100 format ( 'Auto-loading libraries:' ) files_to_load = lib_files !clear lib file list lib_files = '' fn_start = 1 totlen = len_trim ( files_to_load ) do while ( fn_start < totlen ) fn_end = string_part ( files_to_load , ';' , fn_start ) filnam = files_to_load ( fn_start : fn_end ) call readlib ( trim ( filnam )) fn_start = fn_end + 2 end do end if !Annotate irc to residues to find atoms in residues. do ires = 1 , nres res_found = . false . resnam_tmp = res ( ires )% name do i = 1 , nlibres if ( resnam_tmp == lib ( i )% nam ) then res_found = . true . res ( ires )% irc = i exit end if enddo if (. not . res_found ) then write ( * , '(/,a,a,/)' ) '>>> ERROR Residue not found in loaded libraries: ' , & resnam_tmp end if end do end subroutine readtop subroutine readx ! *** local variables CHARACTER ( len = 80 ) :: filnam integer :: i integer ( 4 ) :: nat3 integer :: u CALL get_string_arg ( filnam , '-----> Give name of Q-coordinate file: ' ) u = freefile () if ( openit ( u , filnam , 'old' , 'unformatted' , 'read' ) /= 0 ) return !read number of coordinates (=3*natom) READ ( u ) nat3 rewind ( u ) natom = nat3 / 3 if ( natom /= nat_pro ) then write ( * , 20 ) natom 20 format ( '>>> Error:' , i6 , ' atoms in restart file does not match topology.' ) close ( u ) return endif READ ( u ) nat3 , xtop ( 1 : nat3 ) write ( * , '(a,/)' ) 'Coordinate file successfully read.' close ( u ) write ( coord_source , 100 ) trim ( filnam ) auto_name = filnam 100 format ( 'restart file ' , a ) end subroutine readx subroutine readnext integer :: filestat , nat3 logical :: isopen character ( len = 10 ) :: buf !trj_frame is the number of the record about to be read if (. not . trj_read ( xtop )) then call trj_close trj_frame = 0 write ( * , 900 ) 900 format ( '>>>>> ERROR: Trajectory read failure' ) else write ( buf , '(i8)' ) trj_frame write ( * , '(a,a)' ) 'Loaded trajectory frame ' , trim ( buf ) write ( coord_source , 100 ) trim ( trj_filnam ), trj_frame write ( auto_name , 110 ) trim ( trj_filnam ), trim ( adjustl ( buf )) trj_frame = trj_frame + 1 end if 100 format ( 'trajectrory file ' , a , ' frame ' , i6 ) 110 format ( a , '.' , a ) !for auto file naming trj_filnam.frame end subroutine readnext subroutine readframe ! *** local variables integer :: frame frame = get_int_arg ( '-----> Give frame number: ' ) if ( trj_seek ( frame )) then trj_frame = frame call readnext end if end subroutine readframe subroutine trajectory !locals character ( len = 80 ) :: reply if (. not . topo_ok ) then !can't do this without a topology return end if CALL get_string_arg ( trj_filnam , '-----> Give name of trajectory file: ' ) if ( trj_open ( trj_filnam )) then call get_string_arg ( reply , '-----> Use the trajectory atom mask (y/n)? ' ) if ( reply == 'y' . or . reply == 'Y' ) then call trj_clone_mask ( mask ) write ( * , 100 ) mask % included else write ( * , 110 ) trj_count (), trj_intersection ( mask ) end if end if trj_frame = 1 100 format ( 'There are' , i6 , ' atoms in the trajectory.' ) 110 format ( 'There are' , i6 , ' atoms in the trajectory.' , i6 ,& ' of these are in the mask' ) end subroutine trajectory subroutine modify_mask !locals character ( len = 80 ) :: mask_def integer :: atoms_added if (. not . topo_ok ) then write ( * , 900 ) 900 format ( '>>>>> ERROR: Cannot define mask without topology.' ) else write ( * , 120 ) mask % included 120 format ( 'The current mask contains' , i6 , ' atoms.' ) call get_line_arg ( mask_def , & '-----> Enter atom mask (''none'' to clear):' ) call upcase ( mask_def ) if ( mask_def == 'NONE' . or . mask_def == '0' ) then call mask_clear ( mask ) write ( * , 110 ) 110 format ( 'Mask cleared.' ) else atoms_added = mask_add ( mask , mask_def ) write ( * , 100 ) atoms_added , mask % included 100 format ( i6 , ' atoms added to mask which now contains' , i6 , ' atoms.' ) end if end if end subroutine modify_mask subroutine set_cgp ! *** local variables integer ires , igp , i , ntot , ntot_solute , i3 integer :: switchatom , ia , ncgp_skipped = 0 real :: r2 real ( 8 ) :: cgp_cent ( 3 ) integer :: nheavy ntot = 0 ntot_solute = 0 ncgp = 0 ncgp_solute = 0 !do exclusions here as well nexats = 0 nexwat = 0 if (. not . use_PBC ) excl (:) = . false . !set chargegroups for all atoms! do ires = 1 , nres do igp = 1 , lib ( res ( ires )% irc )% ncgp if ( use_PBC ) then r2 = - 1 !do not exclude elseif ( iuse_switch_atom == 1 ) then !exclude on basis of switching atom switchatom = res ( ires )% start - 1 + lib ( res ( ires )% irc )% switch ( igp ) if (. not . heavy ( switchatom )) then topo_ok = . false . write ( * , 900 ) igp , lib ( res ( ires )% irc )% nam 900 format ( '>>>>> ERROR: Switching atom of charged group' , i2 , ' of residue type ' , a4 , ' is not a heavy atom.' ) cycle !continue looping, do not exclude endif i3 = 3 * switchatom - 3 r2 = ( xtop ( i3 + 1 ) - xpcent ( 1 ) ) ** 2 & + ( xtop ( i3 + 2 ) - xpcent ( 2 ) ) ** 2 & + ( xtop ( i3 + 3 ) - xpcent ( 3 ) ) ** 2 else !exclude by charge group centre cgp_cent (:) = 0 do i = 1 , lib ( res ( ires )% irc )% natcgp ( igp ) ia = res ( ires )% start - 1 + lib ( res ( ires )% irc )% atcgp ( i , igp ) i3 = ia * 3 cgp_cent (:) = cgp_cent (:) + xtop ( i3 - 2 : i3 ) end do cgp_cent (:) = cgp_cent (:) / real ( lib ( res ( ires )% irc )% natcgp ( igp )) r2 = dot_product ( cgp_cent (:) - xpcent (:), cgp_cent (:) - xpcent (:)) endif if ( ( r2 < rexcl_o ** 2 ) . or . & ( ires > nres_solute . and . r2 < ( rexcl_o + 2. ) ** 2 )) then !is it inside? For solvent include up to 2� outside rexcl_o too ncgp = ncgp + 1 if ( ires <= nres_solute ) then ncgp_solute = ncgp_solute + 1 ntot_solute = ntot_solute + lib ( res ( ires )% irc )% natcgp ( igp ) endif cgp ( ncgp )% first = ntot + 1 cgp ( ncgp )% last = ntot + lib ( res ( ires )% irc )% natcgp ( igp ) cgp ( ncgp )% iswitch = res ( ires )% start - 1 + lib ( res ( ires )% irc )% switch ( igp ) do i = 1 , cgp ( ncgp )% last - cgp ( ncgp )% first + 1 ntot = ntot + 1 cgpatom ( ntot ) = res ( ires )% start - 1 + lib ( res ( ires )% irc )% atcgp ( i , igp ) enddo else nexats = nexats + lib ( res ( ires )% irc )% natcgp ( igp ) if ( ires > nres_solute ) then nexwat = nexwat + 1 endif ncgp_skipped = ncgp_skipped + 1 do i = 1 , lib ( res ( ires )% irc )% natcgp ( igp ) excl ( res ( ires )% start - 1 + lib ( res ( ires )% irc )% atcgp ( i , igp )) = . true . enddo endif enddo enddo if ( ntot + nexats /= nat_pro ) then write ( * , '(/,a,/)' ) '>>> Error in set_cgp: ntot+nexats /= nat_pro.' STOP endif write ( * , 100 ) 'Made' , ncgp_solute , ' solute' , ntot_solute write ( * , 100 ) 'Made' , ncgp - ncgp_solute , ' solvent' , ntot - ntot_solute if ( nexats > 0 ) then write ( * , 100 ) 'Skipped' , ncgp_skipped , 'excluded' , nexats endif if ( nexwat > 0 ) then write ( * , 110 ) nexwat endif if (. not . use_PBC ) then rwat = rwat_eff () write ( * , 140 ) rwat endif 100 format ( a , t8 , i6 , a , t23 , 'charge groups comprising a total of ' , i6 , ' atoms.' ) 110 format ( 'Excluded ' , i6 , ' water molecules.' ) 140 format ( 'Effective water radius                     :' , f6 . 2 ) end subroutine set_cgp subroutine set_crg ! *** local variables integer ires , i , ntot ntot = 0 do ires = 1 , nres do i = 1 , lib ( res ( ires )% irc )% nat ntot = ntot + 1 crg ( ntot ) = lib ( res ( ires )% irc )% crg_lib ( i ) enddo enddo if ( ntot /= nat_pro ) then write ( * , '(/,a,/)' ) '>>> Error in set_crg: ntot /= nat_pro.' STOP endif write ( * , 100 ) ntot 100 format ( 'Assigned' , i6 , ' atomic charges.' ) end subroutine set_crg subroutine set_iac ! *** local variables integer :: ires , i , ntot , iaci logical :: used ( max_atyps ) used (:) = . false . ntot = 0 !set atom types do ires = 1 , nres do i = 1 , lib ( res ( ires )% irc )% nat ntot = ntot + 1 if (. not . index_get ( lib ( res ( ires )% irc )% tac_lib ( i ), iaci )) then write ( * , 110 ) lib ( res ( ires )% irc )% tac_lib ( i ), i , ires topo_ok = . false . else used ( iaci ) = . true . iac ( ntot ) = iaci end if enddo enddo !this should never happen if ( ntot /= nat_pro ) then write ( * , '(/,a,/)' ) '>>>>> ERROR in set_iac: ntot /= nat_pro.' topo_ok = . false . endif do i = 1 , natyps if ( used ( i ) . and . iaclib ( i )% mass <= 0 ) then write ( * , 120 ) tac ( i ), iaclib ( i )% mass topo_ok = . false . end if end do if ( topo_ok ) write ( * , 100 ) nat_pro 100 format ( 'Assigned' , i6 , ' atom types.' ) 110 format ( '>>>>> ERROR: Atom type ' , a8 , ' not defined (atom' , i3 , ' of residue' , i5 , '.)' ) 120 format ( '>>>>> ERROR: Atom type ' , a8 , ' has mass ' , f6 . 2 ) end subroutine set_iac logical function set_irc_solvent () set_irc_solvent = . false . do irc_solvent = 1 , nlibres if ( lib ( irc_solvent )% nam == solvent_name ) exit end do if ( irc_solvent > nlibres ) then write ( * , 90 ) solvent_name 90 format ( '>>>>> ERROR: No solvent library entry named ' , a ,& ' has been loaded.' ) return end if write ( * , 95 ) solvent_name 95 format ( 'Library entry used to generate solvent  = ' , a10 ) set_irc_solvent = . true . end function set_irc_solvent subroutine set_solvent_type !set solvent type (SPC-like, TIP3P-like or general) !locals integer :: irc_solvent integer :: i , iac_H1 , iac_H2 logical :: dummy solvent_type = SOLVENT_GENERAL !any solvent at all? if ( nwat == 0 ) return !look up residue code of 1st solvent molecule irc_solvent = res ( nres_solute + 1 )% irc !is it a 3-atom molecule? if ( lib ( irc_solvent )% nat /= 3 ) return !check if all solvent molecules are of same type do i = nres_solute + 2 , nres if ( res ( i )% irc /= irc_solvent ) return end do !now we know all solvent molecules are the same type of 3-atomic molecules solvent_type = SOLVENT_3ATOM !further checks for SPC water, for which special optimisations can be used !check if atoms 2 and 3 are hydrogens if ( lib ( irc_solvent )% atnam ( 2 )( 1 : 1 ) /= 'H' . or . & lib ( irc_solvent )% atnam ( 3 )( 1 : 1 ) /= 'H' ) return !check hydrogen atom types dummy = index_get ( lib ( irc_solvent )% tac_lib ( 2 ), iac_H1 ) !check that both hydrogens are same type dummy = index_get ( lib ( irc_solvent )% tac_lib ( 3 ), iac_H2 ) if ( iac_H1 /= iac_H2 ) return !check if zero LJ params on H if ( all ( iaclib ( iac_H1 )% avdw (:) == 0. ) . and . & all ( iaclib ( iac_H1 )% bvdw (:) == 0. )) then solvent_type = SOLVENT_SPC end if end subroutine set_solvent_type integer function get_atom_from_descriptor ( aid ) !arguments character ( * ), intent ( in ) :: aid !string=residue:atom !locals integer :: separator_pos character ( len = 20 ) :: res_str character ( len = 5 ) :: atom_str integer :: filestat integer :: resnum , atnum get_atom_from_descriptor = 0 separator_pos = scan ( aid , ':' ) if ( separator_pos < 2 . or . separator_pos == len_trim ( aid )) return !no valid colon found res_str = aid ( 1 : separator_pos - 1 ) atom_str = aid ( separator_pos + 1 : len_trim ( aid )) read ( res_str , * , iostat = filestat ) resnum if ( filestat > 0 ) return get_atom_from_descriptor = find_atom ( resnum , atom_str ) end function get_atom_from_descriptor !Routine to call from other modules subroutine define_boundary_condition if (. not . set_boundary_condition ()) then call parse_reset ! clear command line return end if end subroutine define_boundary_condition !Set the boundary condition & read parameterts connected to the boundary. logical function set_boundary_condition () !locals character ( len = 80 ) :: kind_of_boundary !ask if to use simulation sphere or periodic box call get_string_arg ( kind_of_boundary , & '-----> Select kind of boundary: simulation sphere(1) or periodic box(2):' ) call upcase ( kind_of_boundary ) select case ( kind_of_boundary ) !sphere selected case ( 'SPHERE' , '1' ) use_PBC = . false . !set the flag !set the center and radius of the sphere if (. not . set_simulation_sphere ()) then call parse_reset !clear command line return end if boundary_set = . true . !box selected case ( 'BOX' , '2' ) use_PBC = . true . !set the center and radius of the box if (. not . set_solvent_box ()) then call parse_reset !clear command line return end if boundary_set = . true . case default write ( * , '(a)' ) '>>>>> ERROR: Unknown boundary' set_boundary_condition = . false . return end select set_boundary_condition = . true . end function set_boundary_condition logical function set_simulation_sphere () !get centre coordinates !as residue:atom or x y z !locals character ( len = 80 ) :: line integer :: filestat integer :: centre_atom real :: rwat_in , xwat_in set_simulation_sphere = . false . call get_string_arg ( line , '-----> Sphere centre (<x y z> or <residue:atom_name> or <\"mass\">): ' ) if ( scan ( line , ':' ) > 0 ) then !got res:at centre_atom = get_atom_from_descriptor ( line ) if ( centre_atom == 0 ) then write ( * , 900 ) trim ( line ) 900 format ( '>>>>> ERROR: Could not find centre atom ' , a ) return end if xpcent (:) = xtop ( 3 * centre_atom - 2 : 3 * centre_atom ) elseif ( scan ( line , 'mass' ) > 0 ) then !define center by center of mass if (. not . get_centre_by_mass ( xpcent (:))) then write ( * , * ) ( '>>>>> ERROR: Could not create centre ' ) return end if else !got x read ( line , * , iostat = filestat ) xpcent ( 1 ) if ( filestat > 0 ) then !invalid x coordinate return end if xwat_in = get_real_arg ( '-----> Sphere centre y: ' ) xpcent ( 2 ) = xwat_in xwat_in = get_real_arg ( '-----> Sphere centre z: ' ) xpcent ( 3 ) = xwat_in end if rwat_in = get_real_arg ( '-----> Simulation sphere radius: ' ) rexcl_o = rwat_in if ( rexcl_o <= 0. ) then write ( * , 800 ) rexcl_o 800 format ( '>>>>> ERROR: Invalid radius ' , f8 . 2 ) return end if write ( * , * ) write ( * , 100 ) xpcent (:) write ( * , 110 ) rexcl_o 100 format ( 'Simulation sphere centre                =   ' , 3 f8 . 3 ) 110 format ( 'Simulation radius                       =   ' , f8 . 3 ) set_simulation_sphere = . true . end function set_simulation_sphere logical function set_solvent_box () !locals integer :: i !loop index character ( len = 80 ) :: line integer :: centre_atom integer :: filestat real :: xwat_in , coord_in have_solvent_boundary = . false . set_solvent_box = . false . !the centre of the PCB-box call get_string_arg ( line , '-----> Periodic box centre (<x y z> or <residue:atom_name> or <\"mass\">): ' ) call upcase ( line ) if ( scan ( line , ':' ) > 0 ) then !got res:at centre_atom = get_atom_from_descriptor ( line ) if ( centre_atom == 0 ) then write ( * , 900 ) trim ( line ) 900 format ( '>>>>> ERROR: Could not find centre atom ' , a ) return end if boxcentre (:) = xtop ( 3 * centre_atom - 2 : 3 * centre_atom ) elseif ( line == 'MASS' ) then !define center by center of mass if (. not . get_centre_by_mass ( boxcentre (:))) then write ( * , * ) ( '>>>>> ERROR: Could not create centre ' ) return end if else !got x read ( line , * , iostat = filestat ) boxcentre ( 1 ) if ( filestat > 0 ) then !invalid x coordinate return end if xwat_in = get_real_arg ( '-----> Box centre y: ' ) boxcentre ( 2 ) = xwat_in xwat_in = get_real_arg ( '-----> Box centre z: ' ) boxcentre ( 3 ) = xwat_in end if !read the size of the box coord_in = get_real_arg ( '-----> Boxlength x-direction: ' ) boxlength ( 1 ) = coord_in coord_in = get_real_arg ( '-----> Boxlength y-direction: ' ) boxlength ( 2 ) = coord_in coord_in = get_real_arg ( '-----> Boxlength z-direction: ' ) boxlength ( 3 ) = coord_in if ( any ( boxlength (:) == 0.0 ) ) then inv_boxl (:) = 0.0 else inv_boxl (:) = 1.0 / boxlength (:) end if do i = 1 , 3 if ( boxlength ( i ) < 0 ) then write ( * , '(a)' ) '>>>>> WARNING: Boxlength with negative sign. Converting to positive.' boxlength ( i ) = - boxlength ( i ) end if end do have_solvent_boundary = . true . set_solvent_box = . true . end function set_solvent_box subroutine solvate ! Make sure boundary condition is set. if (. not . boundary_set ) then write ( * , '(a)' ) '>>>>> ERROR Boundary unknown' write ( * , '(a)' ) \"Use <boundary> to define boundary condition\" return end if if ( use_PBC ) then call solvate_box else call solvate_sphere end if end subroutine solvate subroutine solvate_box character ( len = 80 ) :: solvate_mode write ( * , '(a)' ) 'Using predefined boxcentre and boxlengths.' write ( * , 101 ) boxcentre write ( * , 102 ) boxlength 101 format ( 'Boxcentre (x,y,z)                :  ' , 3 f8 . 3 ) 102 format ( 'Boxlengths (x,y,z)               :  ' , 3 f8 . 3 ) !chose solvation mode call get_string_arg ( solvate_mode , & '-----> Select solvation mode: grid(1), file(2), restart(3): ' ) call upcase ( solvate_mode ) select case ( solvate_mode ) case ( 'GRID' , '1' ) call solvate_box_grid case ( 'FILE' , '2' ) call solvate_box_file case ( 'RESTART' , '3' ) call solvate_restart case default write ( * , '(a)' ) '>>>>> ERROR: Unknown mode of solvation.' call parse_reset return end select end subroutine solvate_box subroutine solvate_box_grid !solvate sphere using grid !locals real ( 8 ) :: xmin , xmax , ymin , ymax , zmin , zmax real ( 8 ) :: xgrid , ygrid , zgrid integer :: max_wat !max number of molecules integer :: waters_in_box real ( 8 ) :: radius2 , solvent_grid character ( len = 200 ) :: solvent !set water residue name call get_string_arg ( solvent , & '-----> Enter library entry name for water molecule: ' ) solvent_name = solvent ( 1 : 4 ) !get residue code for solvent if (. not . set_irc_solvent ()) return !calc cubic grid spacing from density if ( lib ( irc_solvent )% density > 0. ) then solvent_grid = lib ( irc_solvent )% density ** ( - 1 / 3. ) else write ( * , 900 ) lib ( irc_solvent )% nam 900 format ( '>>>>> ERROR: Density not set in library entry ' , a ) return end if !Make sure boxsize is consistent with the periodic boundary condition !changed to nearest integer (nint) from truncation (int)  /M.A. boxlength ( 1 ) = nint ( boxlength ( 1 ) / solvent_grid ) * solvent_grid boxlength ( 2 ) = nint ( boxlength ( 2 ) / solvent_grid ) * solvent_grid boxlength ( 3 ) = nint ( boxlength ( 3 ) / solvent_grid ) * solvent_grid !Calculate max number of waters possible max_wat = lib ( irc_solvent )% density * boxlength ( 1 ) * boxlength ( 2 ) * boxlength ( 3 ) allocate ( xw ( 3 , lib ( irc_solvent )% nat , max_wat ), keep ( max_wat ), stat = alloc_status ) call check_alloc ( 'water sphere coordinate array' ) xmin = boxcentre ( 1 ) - boxlength ( 1 ) / 2 + solvent_grid / 2 xmax = boxcentre ( 1 ) + boxlength ( 1 ) / 2 - solvent_grid / 2 ymin = boxcentre ( 2 ) - boxlength ( 2 ) / 2 + solvent_grid / 2 ymax = boxcentre ( 2 ) + boxlength ( 2 ) / 2 - solvent_grid / 2 zmin = boxcentre ( 3 ) - boxlength ( 3 ) / 2 + solvent_grid / 2 zmax = boxcentre ( 3 ) + boxlength ( 3 ) / 2 - solvent_grid / 2 write ( * , 100 ) boxlength ( 1 ), boxlength ( 2 ), boxlength ( 3 ), solvent_grid 100 format ( 'New boxlength                     = ' , 3 f8 . 2 , ' A' , / & 'Grid spacing                      = ' , f10 . 2 , ' A ' ) !Fill box with water !xmax+0.1 is needed for intel/windows. Otherwise the last loop step is skipped waters_in_box = 0 xgrid = xmin do while ( xgrid <= xmax + 0.1 ) ygrid = ymin do while ( ygrid <= ymax + 0.1 ) zgrid = zmin do while ( zgrid <= zmax + 0.1 ) waters_in_box = waters_in_box + 1 xw ( 1 , 1 , waters_in_box ) = xgrid xw ( 2 , 1 , waters_in_box ) = ygrid xw ( 3 , 1 , waters_in_box ) = zgrid !all the molecules inside are inside keep ( waters_in_box ) = . true . zgrid = zgrid + solvent_grid end do ygrid = ygrid + solvent_grid end do xgrid = xgrid + solvent_grid end do call add_solvent_to_topology ( waters_in_sphere = waters_in_box , & max_waters = waters_in_box , make_hydrogens = . true ., pack = solvent_pack ) deallocate ( xw , keep ) end subroutine solvate_box_grid subroutine solvate_box_file !local variables character ( len = 80 ) :: xwat_file integer :: fstat character ( len = 80 ) :: line real ( 8 ) :: boxl , waterbox_v , waterbox ( 1 : 3 ) character ( len = 6 ) :: sphere logical :: replicate integer :: extension ( 1 : 3 ) real ( 8 ) :: extensionbox_v , ext ( 3 , 3 ) integer :: nw , nnw ! water molecule counters integer :: i , j , k ! loop indices integer :: filestat ! error variable character ( len = 3 ) :: atomnames character ( len = 4 ) :: resnam ( 3 ) integer :: resno ( 3 ) integer :: nbox ! number of replicated boxes integer :: nwat_allocate real ( 8 ) :: xcm ( 3 ) ! center of the waterbox real ( 8 ) :: wshift ( 3 ) ! distance to move waters integer :: nwat_keep ! how many waters to keep real ( 8 ) :: temp ( 3 ) ! temporary coordinate !get the name of the file and open the file in unit 13 call get_string_arg ( xwat_file , '-----> Solvent file name: ' ) open ( unit = 13 , file = xwat_file , status = 'old' , form = 'formatted' , action = 'read' , iostat = fstat ) if ( fstat /= 0 ) then write ( * , '(a)' ) '>>>>> ERROR: Could not open water coordinate file.' call parse_reset return end if !read the size of the waterbox read ( 13 , '(a80)' ) line read ( line , * , iostat = fstat ) boxl if ( fstat /= 0 ) then write ( * , '(a)' ) '>>>>> ERROR: Size not specified in water file.' close ( 13 ) call parse_reset return end if if ( boxl < 0 ) then write ( * , '(a)' ) '>>>>> WARNING: Size with negative sign. Converting to positive.' boxl = - boxl end if !check if the file contains a sphere of water instead of a box read ( line , * , iostat = fstat ) boxl , sphere call upcase ( sphere ) if ( sphere == 'SPHERE' ) then write ( * , '(a)' ) '>>>>> ERROR: This file containts a sphere of water. Use a file with a box of water instead.' close ( 13 ) call parse_reset return end if !Compute waterbox volume and display the waterbox sidelength waterbox (:) = boxl waterbox_v = boxl ** 3 write ( * , '(a, f10.3)' ) 'Boxlength of solvent file               =' , waterbox ( 1 ) !Determine residue name to use for solvent molecule read ( 13 , 1 ) atomnames ( 1 : 1 ), solvent_name backspace ( 13 ) if ( . not . set_irc_solvent () ) then close ( 13 ) call parse_reset return else if ( lib ( irc_solvent )% nat /= 3 ) then write ( * , '(a)' ) '>>>>> ERROR: Solvate only works for 3-atom solvents (in this version).' close ( 13 ) call parse_reset return else if ( lib ( irc_solvent )% density <= 0. ) then write ( * , '(a, a)' ) '>>>>> ERROR: Density not set in library entry ' , lib ( irc_solvent )% nam close ( 13 ) call parse_reset return end if ! Estimate amount of memory to allocate for temporary waters if ( all ( boxlength (:) < waterbox ( 1 )) ) then ! don't need to replicate. 5% margin replicate = . false . nwat_allocate = int ( lib ( irc_solvent )% density * 1.05 * waterbox_v ) else ! the waterbox is not big enough replicate = . true . ! find out in wich direction replication is needed extension (:) = ceiling ( boxlength (:) / boxl ) extensionbox_v = extension ( 1 ) * extension ( 2 ) * extension ( 3 ) * waterbox_v nwat_allocate = int ( lib ( irc_solvent )% density * 1.05 * extensionbox_v ) end if allocate ( xw ( 3 , lib ( irc_solvent )% nat , nwat_allocate ), keep ( nwat_allocate ), stat = alloc_status ) call check_alloc ( 'temporary solvent coord. arrays' ) ! Coordinate reading. 1 format ( 13 x , a1 , 3 x , a4 , i5 , 4 x , 3 f8 . 3 ) nw = 0 do i = 1 , nwat_allocate - 1 read ( 13 , 1 , iostat = filestat , end = 10 ) & atomnames ( 1 : 1 ), resnam ( 1 ), resno ( 1 ), xw (:, 1 , nw + 1 ), & & atomnames ( 2 : 2 ), resnam ( 2 ), resno ( 2 ), xw (:, 2 , nw + 1 ), & & atomnames ( 3 : 3 ), resnam ( 3 ), resno ( 3 ), xw (:, 3 , nw + 1 ) !checking the read info if ( filestat > 0 ) then write ( * , 7 ) nw close ( 13 ) call parse_reset deallocate ( xw , keep ) return else if ( any ( resnam (:) /= solvent_name ) ) then write ( * , 8 ) solvent_name , nw close ( 13 ) call parse_reset deallocate ( xw , keep ) return else if ( any ( resno (:) /= resno ( 1 ) ) ) then write ( * , 9 ) nw close ( 13 ) call parse_reset deallocate ( xw , keep ) return else nw = nw + 1 end if end do 7 format ( '>>>>> ERROR: Read failure at molecule' , i6 ) 8 format ( '>>>>> ERROR: Residue name other than ' , a4 , ' found at molecule ' , i6 ) 9 format ( '>>>>> ERROR: Inconsistent residue numbering at molecule ' , i6 ) 10 write ( * , '(a, i10)' ) 'No. of molecules in solvent file ' , nw nnw = nw !Replicate if necessary if ( replicate ) then write ( * , '(a)' ) 'Replicating box of water...' ext (:, 1 ) = ( / boxl , 0. _ 8 , 0. _ 8 / ) ext (:, 2 ) = ( / 0. _ 8 , boxl , 0. _ 8 / ) ext (:, 3 ) = ( / 0. _ 8 , 0. _ 8 , boxl / ) nbox = 0 do k = 1 , 3 !the three coordinates if ( . not . extension ( k ) > 1 ) cycle do i = 1 , extension ( k ) - 1 nbox = nbox + 1 do j = 1 , nw nnw = nnw + 1 xw (:, 1 , nnw ) = xw (:, 1 , j ) + i * ext ( k ,:) xw (:, 2 , nnw ) = xw (:, 2 , j ) + i * ext ( k ,:) xw (:, 3 , nnw ) = xw (:, 3 , j ) + i * ext ( k ,:) end do waterbox ( k ) = waterbox ( k ) + boxl end do nw = nnw end do nw = nnw write ( * , '(a, i5, a)' ) 'Added' , nbox , ' boxes of water' write ( * , '(a, i10)' ) 'No of molecules after replication          = ' , nw end if !Compute the centre coordinates for the waterbox xcm (:) = sum ( sum ( xw , dim = 3 ), dim = 2 ) / ( nw * lib ( irc_solvent )% nat ) wshift (:) = boxcentre (:) - xcm (:) !Remove water molecules outside of periodic box nwat_keep = 0 do i = 1 , nw temp = xw (:, 1 , i ) if ( all ( temp (:) < xcm (:) + 0.5 * boxlength (:)) & . and . all ( temp (:) > xcm (:) - 0.5 * boxlength (:))) then !keep this molecule nwat_keep = nwat_keep + 1 keep ( i ) = . true . !shift to periodic box centre do j = 1 , lib ( irc_solvent )% nat xw (:, j , i ) = xw (:, j , i ) + wshift (:) end do else !do not keep this molecule keep ( i ) = . false . end if end do !Add solvent to topology call add_solvent_to_topology ( waters_in_sphere = nwat_keep , max_waters = nw , & make_hydrogens = . false ., pack = solvent_pack ) close ( 13 ) deallocate ( xw , keep ) end subroutine solvate_box_file subroutine solvate_sphere character ( len = 80 ) :: solvate_mode if (. not . set_solvent_sphere ()) then call parse_reset !clear command line return end if !chose solvation mode call get_string_arg ( solvate_mode , & '-----> Select solvation mode: grid(1), file(2), restart(3), DWF(4): ' ) call upcase ( solvate_mode ) select case ( solvate_mode ) case ( 'GRID' , '1' ) call solvate_sphere_grid case ( 'FILE' , '2' ) call solvate_sphere_file (. true .) case ( 'RESTART' , '3' ) call solvate_restart case ( 'DWF' , '4' ) call solvate_sphere_file (. false .) case default write ( * , '(a)' ) '>>>>> ERROR: Unknown mode of solvation.' call parse_reset return end select end subroutine solvate_sphere logical function set_solvent_sphere () !locals character ( len = 80 ) :: line integer :: filestat integer :: centre_atom real :: rwat_in , xwat_in set_solvent_sphere = . false . have_solvent_boundary = . false . if ( have_title ) then !Print old centre if available write ( * , '(a,3f8.3)' ) 'Previous solvent centre:' , xwcent ( 1 ), xwcent ( 2 ), xwcent ( 3 ) end if call get_string_arg ( line , '-----> Sphere centre (<x y z> or <residue:atom_name> or <\"mass\"> or <\"boundary\">): ' ) call upcase ( line ) if ( scan ( line , ':' ) > 0 ) then !got res:at centre_atom = get_atom_from_descriptor ( line ) if ( centre_atom == 0 ) then write ( * , 900 ) trim ( line ) 900 format ( '>>>>> ERROR: Could not find centre atom ' , a ) return end if xwcent (:) = xtop ( 3 * centre_atom - 2 : 3 * centre_atom ) elseif ( line == 'MASS' ) then !define center by center of mass if (. not . get_centre_by_mass ( xwcent (:))) then write ( * , * ) ( '>>>>> ERROR: Could not create centre ' ) return end if elseif ( line == 'BOUNDARY' ) then !define center same as boundary center xwcent = xpcent else !got x read ( line , * , iostat = filestat ) xwcent ( 1 ) if ( filestat > 0 ) then !invalid x coordinate return end if xwat_in = get_real_arg ( '-----> Sphere centre y: ' ) xwcent ( 2 ) = xwat_in xwat_in = get_real_arg ( '-----> Sphere centre z: ' ) xwcent ( 3 ) = xwat_in end if if ( have_title ) then !Print old radius if available write ( * , '(a,f8.3)' ) 'Previous effective solvent radius:' , rwat_eff () rwat_in = get_real_arg ( '-----> Solvation sphere radius: ' ) else rwat_in = get_real_arg ( '-----> Solvation sphere radius: ' ) end if rwat = rwat_in if ( rwat == 0. ) then return end if write ( * , * ) write ( * , 100 ) xwcent (:) 100 format ( 'Solvation sphere centre                 =   ' , 3 f8 . 3 ) set_solvent_sphere = . true . have_solvent_boundary = . true . end function set_solvent_sphere subroutine solvate_sphere_grid !solvate sphere using grid !locals real ( 8 ) :: xmin , xmax , ymin , ymax , zmin , zmax real ( 8 ) :: xgrid , ygrid , zgrid integer :: max_wat !max number of molecules integer :: waters_in_sphere real ( 8 ) :: radius2 , solvent_grid character ( len = 200 ) :: solvent !set water residue name call get_string_arg ( solvent , & '-----> Enter library entry name for water molecule: ' ) solvent_name = solvent ( 1 : 4 ) !get residue code for solvent if (. not . set_irc_solvent ()) return !calc cubic grid spacing from density if ( lib ( irc_solvent )% density > 0. ) then solvent_grid = lib ( irc_solvent )% density ** ( - 1 / 3. ) else write ( * , 900 ) lib ( irc_solvent )% nam 900 format ( '>>>>> ERROR: Density not set in library entry ' , a ) return end if max_wat = ( 2 * rwat + solvent_grid ) ** 3 / solvent_grid ** 3 radius2 = rwat ** 2 allocate ( xw ( 3 , lib ( irc_solvent )% nat , max_wat ), keep ( max_wat ), stat = alloc_status ) call check_alloc ( 'water sphere coordinate array' ) xmin = xwcent ( 1 ) - int ( rwat / solvent_grid ) * solvent_grid xmax = xwcent ( 1 ) + int ( rwat / solvent_grid ) * solvent_grid ymin = xwcent ( 2 ) - int ( rwat / solvent_grid ) * solvent_grid ymax = xwcent ( 2 ) + int ( rwat / solvent_grid ) * solvent_grid zmin = xwcent ( 3 ) - int ( rwat / solvent_grid ) * solvent_grid zmax = xwcent ( 3 ) + int ( rwat / solvent_grid ) * solvent_grid write ( * , 100 ) rwat , solvent_grid 100 format ( 'Radius of solvent sphere                = ' , f10 . 2 , ' A' , / & 'Grid spacing                            = ' , f10 . 2 , ' A ' ) !constuct water-only sphere !xmax+0.1 is needed for intel/windows. Otherwise the last loop step is skipped waters_in_sphere = 0 xgrid = xmin do while ( xgrid <= xmax + 0.1 ) ygrid = ymin do while ( ygrid <= ymax + 0.1 ) zgrid = zmin do while ( zgrid <= zmax + 0.1 ) if ( . not . (( xgrid - xwcent ( 1 )) ** 2 + ( ygrid - xwcent ( 2 )) ** 2 & + ( zgrid - xwcent ( 3 )) ** 2 > radius2 ) ) then waters_in_sphere = waters_in_sphere + 1 !if not outside keep these coordinates xw ( 1 , 1 , waters_in_sphere ) = xgrid xw ( 2 , 1 , waters_in_sphere ) = ygrid xw ( 3 , 1 , waters_in_sphere ) = zgrid !all the molecules inside are inside keep ( waters_in_sphere ) = . true . endif zgrid = zgrid + solvent_grid end do ygrid = ygrid + solvent_grid end do xgrid = xgrid + solvent_grid end do call add_solvent_to_topology ( waters_in_sphere = waters_in_sphere , & max_waters = waters_in_sphere , make_hydrogens = . true ., pack = solvent_pack ) deallocate ( xw , keep ) end subroutine solvate_sphere_grid subroutine solvate_sphere_file ( shift ) ! parameters logical , intent ( in ), optional :: shift ! local variables integer :: i , j , nw , nnw integer :: nwat_allocate , nwat_keep real ( 8 ) :: rmax2 , dx2 , boxl , newboxl real ( 8 ), save :: xcm ( 3 ), wshift ( 3 ) integer :: fstat logical :: is_box character ( len = 6 ) :: sphere character ( len = 80 ) :: line real ( 8 ) :: volume real :: r4dum character ( len = 80 ) :: xwat_file real ( 8 ) :: xwshift ( 3 , 7 ) integer :: box character ( len = 3 ) :: atomnames integer :: filestat character ( len = 10 ) :: filepos integer :: resno ( 3 ) character ( len = 4 ) :: resnam ( 3 ) real ( 8 ) :: xwtmp ( 3 , max_atlib ) integer :: at_id ( max_atlib ) call get_string_arg ( xwat_file , '-----> Solvent file name: ' ) open ( unit = 13 , file = xwat_file , status = 'old' , form = 'formatted' , & action = 'read' , iostat = fstat ) if ( fstat /= 0 ) then write ( * , '(a)' ) '>>>>> ERROR: Could not open water coordinate file.' call parse_reset return end if 2 format ( 'Boxlength of solvent file               = ' , f10 . 3 ) 3 format ( 'Radius of sphere in solvent file        = ' , f10 . 3 ) ! --> water coordinate file for initial generation (13) read ( 13 , '(a80)' ) line read ( line , * , iostat = fstat ) boxl if ( fstat /= 0 ) then write ( * , '(a)' ) 'ERROR >>>>>: Size not specified in water file.' close ( 13 ) call parse_reset return end if read ( line , * , iostat = fstat ) boxl , sphere call upcase ( sphere ) if ( sphere == 'SPHERE' ) then volume = boxl ** 3 * 4 * pi / 3. is_box = . false . write ( * , 3 ) boxl else volume = boxl ** 3 is_box = . true . write ( * , 2 ) boxl end if !determine residue name to use for solvent molecules read ( 13 , 1 ) atomnames ( 1 : 1 ), solvent_name backspace ( 13 ) if (. not . set_irc_solvent ()) then goto 999 else if ( lib ( irc_solvent )% nat /= 3 ) then write ( * , 900 ) 900 format ( '>>>>> ERROR: Solvate only works for 3-atom solvents (in this version).' ) goto 999 else if ( lib ( irc_solvent )% density <= 0. ) then write ( * , 910 ) lib ( irc_solvent )% nam 910 format ( '>>>>> ERROR: Density not set in library entry ' , a ) goto 999 end if ! estimate amount of memory to allocate for temporary water coordinates if (( is_box . and . abs ( rwat ) <= boxl / 2. )) then !don't need to replicate !5% safety margin nwat_allocate = int ( lib ( irc_solvent )% density * 1.05 * volume ) elseif ( is_box ) then newboxl = boxl * 2 ** ( int ( log ( abs ( rwat ) * 2 / boxl ) / log ( 2. ) + 0.9999 )) nwat_allocate = int ( lib ( irc_solvent )% density * 1.05 * newboxl ** 3 ) elseif ( abs ( rwat ) > boxl ) then !it's a sphere and it's too small write ( * , '(a)' ) '>>>>> ERROR: Water sphere in the file is too small.' call parse_reset close ( 13 ) return else !its a sufficiently big sphere nwat_allocate = int ( lib ( irc_solvent )% density * 1.05 * volume ) endif allocate ( xw ( 3 , lib ( irc_solvent )% nat , nwat_allocate ), keep ( nwat_allocate ), & stat = alloc_status ) call check_alloc ( 'temporary solvent coord. arrays' ) rmax2 = rwat ** 2 nw = 0 1 format ( 13 x , a1 , 3 x , a4 , i5 , 4 x , 3 f8 . 3 ) do i = 1 , nwat_allocate - 1 read ( 13 , 1 , iostat = filestat , end = 10 ) & atomnames ( 1 : 1 ), resnam ( 1 ), resno ( 1 ), xw (:, 1 , nw + 1 ), & atomnames ( 2 : 2 ), resnam ( 2 ), resno ( 2 ), xw (:, 2 , nw + 1 ), & atomnames ( 3 : 3 ), resnam ( 3 ), resno ( 3 ), xw (:, 3 , nw + 1 ) if ( filestat > 0 ) then write ( * , 8 ) nw goto 999 elseif ( any ( resnam (:) /= solvent_name )) then write ( * , 9 ) solvent_name , nw goto 999 elseif ( any ( resno (:) /= resno ( 1 ))) then write ( * , 7 ) nw goto 999 else nw = nw + 1 end if end do 7 format ( '>>>>> ERROR: Inconsistent residue numbering at molecule' , i6 ) 8 format ( '>>>>> ERROR: Read failure at molecule' , i6 ) 9 format ( '>>>>> ERROR: Residue name other than ' , a4 ,& ' found at molecule ' , i6 ) 10 write ( * , 20 ) nw 20 format ( 'No. of molecules in solvent file           = ' , i10 ) ! --- Replicate box if necessary nnw = nw if ( is_box . and . abs ( rwat ) . gt . boxl / 2. ) then do while ( abs ( rwat ) . gt . boxl / 2. ) write ( * , '(a)' ) 'Replicating periodic box...' xwshift (:, 1 ) = ( / boxl , 0. _ 8 , 0. _ 8 / ) xwshift (:, 2 ) = ( / 0. _ 8 , boxl , 0. _ 8 / ) xwshift (:, 3 ) = ( / 0. _ 8 , 0. _ 8 , boxl / ) xwshift (:, 4 ) = ( / boxl , boxl , 0. _ 8 / ) xwshift (:, 5 ) = ( / boxl , 0. _ 8 , boxl / ) xwshift (:, 6 ) = ( / 0. _ 8 , boxl , boxl / ) xwshift (:, 7 ) = ( / boxl , boxl , boxl / ) do i = 1 , nw do box = 1 , 7 nnw = nnw + 1 xw (:, 1 , nnw ) = xw (:, 1 , i ) + xwshift (:, box ) xw (:, 2 , nnw ) = xw (:, 2 , i ) + xwshift (:, box ) xw (:, 3 , nnw ) = xw (:, 3 , i ) + xwshift (:, box ) end do end do boxl = 2. * boxl nw = nnw write ( * , 28 ) nw 28 format ( 'Number of molecules after replication      = ' , i10 ) end do end if !no water coord shift !       shift(:) = 0. !       cm(:) = xwcent(:) ! shift water coords from water center of mass to sphere center ! do not shift for \"dedicated water file\" if ( shift ) then ! shift == TRUE => normal water file equilibrated without solute !xcm = center of mass for solvent atoms xcm (:) = sum ( sum ( xw , dim = 3 ), dim = 2 ) / ( nw * lib ( irc_solvent )% nat ) wshift (:) = xwcent (:) - xcm (:) + epsilon ( r4dum ) nnw = 0 nwat_keep = 0 do i = 1 , nw dx2 = dot_product ( xw (:, 1 , i ) - xcm (:), xw (:, 1 , i ) - xcm (:)) if ( dx2 <= rmax2 ) then nwat_keep = nwat_keep + 1 !shift to xwcent do j = 1 , lib ( irc_solvent )% nat xw (:, j , i ) = xw (:, j , i ) + wshift (:) end do keep ( i ) = . true . ! water i is in sphere else keep ( i ) = . false . end if end do else ! shift == FALSE => water file equilibrated with solute do i = 1 , nw dx2 = dot_product ( xw (:, 1 , i ) - xwcent (:), xw (:, 1 , i ) - xwcent (:)) if ( dx2 <= rmax2 ) then nwat_keep = nwat_keep + 1 keep ( i ) = . true . ! water i is in sphere else keep ( i ) = . false . end if end do endif call add_solvent_to_topology ( waters_in_sphere = nwat_keep , & max_waters = nw , make_hydrogens = . false ., pack = solvent_pack ) !branch here on error 999 close ( 13 ) deallocate ( xw , keep ) end subroutine solvate_sphere_file subroutine solvate_restart !locals integer ( 4 ) :: natom , nat3 , waters_added character ( len = 80 ) :: xfile integer :: u , fstat real ( 8 ), allocatable :: xtmp (:) character ( len = 200 ) :: solvent u = freefile () call get_string_arg ( xfile , '-----> Restart file name: ' ) open ( unit = u , file = xfile , status = 'old' , form = 'unformatted' , & action = 'read' , iostat = fstat ) if ( fstat /= 0 ) then write ( * , '(a)' ) '>>>>> ERROR: Could not open restart file.' call parse_reset return end if !set water residue name call get_string_arg ( solvent , & '-----> Enter library entry name for water molecule: ' ) solvent_name = solvent ( 1 : 4 ) !get residue code for solvent if (. not . set_irc_solvent ()) return read ( u ) nat3 natom = nat3 / 3 if ( natom == nat_pro ) then write ( * , 10 ) 10 format ( '>>>>> ERROR: No. of atoms in restart file not greater than in topology.' ) close ( u ) return elseif ( mod ( natom - nat_pro , 3 ) /= 0 ) then write ( * , 20 ) natom 20 format ( '>>>>> ERROR:' , i6 , ' new atoms in restart file is not a multiple of 3.' ) close ( u ) return end if waters_added = ( natom - nat_pro ) / 3 call grow_arrays_for_solvent ( waters_added , 3 ) allocate ( xtmp ( nat3 )) backspace ( u ) read ( u ) nat3 , xtmp ( 1 : nat3 ) close ( u ) allocate ( xw ( 3 , 3 , waters_added ), keep ( waters_added )) xw (:,:,:) = reshape ( xtmp ( 3 * nat_pro + 1 : nat3 ),( / 3 , 3 , waters_added / )) keep (:) = . true . !allow very tight packing of waters to solute - this is a restart file! call add_solvent_to_topology ( waters_in_sphere = waters_added , & max_waters = waters_added , make_hydrogens = . false ., pack = 0. ) deallocate ( xtmp , xw , keep ) end subroutine solvate_restart subroutine add_solvent_to_topology ( waters_in_sphere , max_waters , make_hydrogens , pack ) !arguments integer :: waters_in_sphere integer :: max_waters logical :: make_hydrogens real :: pack !locals integer :: waters_added real ( 8 ) :: rpack2 integer :: w_at , w_mol , p_atom logical :: wheavy ( max_atlib ) real ( 8 ) :: dx , dy , dz , r2 integer :: next_wat , next_atom if ( use_PBC ) then write ( * , 111 ) waters_in_sphere else write ( * , 110 ) waters_in_sphere end if 110 format ( 'No. of solvent molecules in the sphere:' , i6 ) 111 format ( 'No. of solvent molecules in the box:' , i6 ) !exclude water molecues close to heavy solute atoms write ( * , 120 ) pack 120 format ( 'Minimum distance to solute heavy atoms:' , f6 . 2 , ' A' ) waters_added = 0 rpack2 = pack ** 2 do w_at = 1 , lib ( irc_solvent )% nat if ( lib ( irc_solvent )% atnam ( w_at )( 1 : 1 ) == 'H' ) then wheavy ( w_at ) = . false . else wheavy ( w_at ) = . true . end if end do !loop over solvent molecules wloop : do w_mol = 1 , max_waters !skip if not in sphere or box if (. not . keep ( w_mol )) cycle wloop !loop over atoms in solvent molecule do w_at = 1 , lib ( irc_solvent )% nat !skip hydrogens if (. not . wheavy ( w_at )) cycle !check clash with all other heavy atoms ploop : do p_atom = 1 , nat_pro !for each water check all other atoms if ( heavy ( p_atom )) then !clash with a heavy atom? !*****PWchanged way of computing packing dx = xtop ( 3 * p_atom - 2 ) - xw ( 1 , w_at , w_mol ) dy = xtop ( 3 * p_atom - 1 ) - xw ( 2 , w_at , w_mol ) dz = xtop ( 3 * p_atom ) - xw ( 3 , w_at , w_mol ) if ( use_PBC ) then dx = dx - boxlength ( 1 ) * nint ( dx * inv_boxl ( 1 ) ) dy = dy - boxlength ( 2 ) * nint ( dy * inv_boxl ( 2 ) ) dz = dz - boxlength ( 3 ) * nint ( dz * inv_boxl ( 3 ) ) end if r2 = dx ** 2 + dy ** 2 + dz ** 2 if ( r2 < rpack2 ) then !if(dot_product(xtop(3*p_atom-2:3*p_atom) & !       -xw(:,w_at,w_mol), & !       xtop(3*p_atom-2:3*p_atom)-xw(:,w_at,w_mol)) & !       < rpack2) then keep ( w_mol ) = . false . cycle wloop end if end if end do ploop !*****PWadded new loop checking water-water distance if ( use_PBC ) then do next_wat = w_mol + 1 , max_waters if (. not . keep ( next_wat ) ) cycle do next_atom = 1 , lib ( irc_solvent )% nat if (. not . wheavy ( next_atom ) ) cycle dx = xw ( 1 , w_at , w_mol ) - xw ( 1 , next_atom , next_wat ) dy = xw ( 2 , w_at , w_mol ) - xw ( 2 , next_atom , next_wat ) dz = xw ( 3 , w_at , w_mol ) - xw ( 3 , next_atom , next_wat ) dx = dx - boxlength ( 1 ) * nint ( dx * inv_boxl ( 1 ) ) dy = dy - boxlength ( 2 ) * nint ( dy * inv_boxl ( 2 ) ) dz = dz - boxlength ( 3 ) * nint ( dz * inv_boxl ( 3 ) ) r2 = dx ** 2 + dy ** 2 + dz ** 2 if ( r2 < rpack2 ) then keep ( w_mol ) = . false . cycle wloop end if end do end do end if end do !w_at if ( keep ( w_mol )) then !this water molecules does not clash with any other heavy atom. waters_added = waters_added + 1 end if end do wloop write ( * , 130 ) waters_added 130 format ( 'No. of solvent molecules to add to the system:' , i6 ) !increase size of xtop, imakeh call grow_arrays_for_solvent ( waters_added , lib ( irc_solvent )% nat ) do w_mol = 1 , max_waters if (. not . keep ( w_mol )) cycle !move this vater to topology nwat = nwat + 1 nmol = nmol + 1 istart_mol ( nmol ) = nat_pro + 1 nres = nres + 1 res ( nres )% start = nat_pro + 1 res ( nres )% irc = irc_solvent res ( nres )% name = lib ( irc_solvent )% nam do w_at = 1 , lib ( irc_solvent )% nat nat_pro = nat_pro + 1 !copy coordinates for each atom xtop ( 3 * nat_pro - 2 : 3 * nat_pro ) = xw (:, w_at , w_mol ) heavy ( nat_pro ) = wheavy ( w_at ) if ( wheavy ( w_at )) then makeH ( nat_pro ) = . false . else makeH ( nat_pro ) = make_hydrogens end if end do end do end subroutine add_solvent_to_topology subroutine grow_arrays_for_solvent ( nmore , atoms_per_molecule ) !make space for nmore more water molecules !arguments integer , intent ( in ) :: nmore , atoms_per_molecule !locals real ( 8 ), allocatable :: r8temp (:) logical , allocatable :: ltemp (:) integer , allocatable :: itemp (:) integer :: new_nat , nat3old type ( residue_type ), allocatable :: restemp (:) if ( nmore == 0 ) return new_nat = nat_pro + nmore * atoms_per_molecule nat3old = nat_pro * 3 if ( allocated ( xtop )) then allocate ( r8temp ( nat3old ), stat = alloc_status ) call check_alloc ( 'reallocating topology atom array' ) r8temp ( 1 : nat3old ) = xtop ( 1 : nat3old ) deallocate ( xtop ) allocate ( xtop ( new_nat * 3 ), stat = alloc_status ) call check_alloc ( 'reallocating topology atom array' ) xtop ( 1 : nat3old ) = r8temp ( 1 : nat3old ) deallocate ( r8temp ) else allocate ( xtop ( new_nat * 3 ), stat = alloc_status ) call check_alloc ( 'reallocating topology atom array' ) end if if ( allocated ( makeH )) then allocate ( ltemp ( nat_pro ), stat = alloc_status ) call check_alloc ( 'reallocating topology atom array' ) ltemp ( 1 : nat_pro ) = makeH ( 1 : nat_pro ) deallocate ( makeH ) allocate ( makeH ( new_nat ), stat = alloc_status ) call check_alloc ( 'reallocating topology atom array' ) makeH ( 1 : nat_pro ) = ltemp ( 1 : nat_pro ) makeH ( nat_pro + 1 : new_nat ) = . false . ltemp ( 1 : nat_pro ) = heavy ( 1 : nat_pro ) deallocate ( heavy ) allocate ( heavy ( new_nat ), stat = alloc_status ) call check_alloc ( 'reallocating topology atom array' ) heavy ( 1 : nat_pro ) = ltemp ( 1 : nat_pro ) heavy ( nat_pro + 1 : new_nat ) = . false . deallocate ( ltemp ) else allocate ( makeH ( new_nat ), heavy ( new_nat ), stat = alloc_status ) call check_alloc ( 'reallocating topology atom array' ) makeH ( 1 : new_nat ) = . false . heavy ( 1 : new_nat ) = . false . end if if ( allocated ( res )) then allocate ( restemp ( nres ), stat = alloc_status ) call check_alloc ( 'reallocating topology atom array' ) restemp ( 1 : nres ) = res ( 1 : nres ) deallocate ( res ) allocate ( res ( nres + nmore ), stat = alloc_status ) call check_alloc ( 'reallocating topology atom array' ) res ( 1 : nres ) = restemp ( 1 : nres ) deallocate ( restemp ) else allocate ( res ( nres + nmore ), stat = alloc_status ) call check_alloc ( 'reallocating topology atom array' ) end if if ( allocated ( istart_mol )) then allocate ( itemp ( nmol ), stat = alloc_status ) call check_alloc ( 'reallocating topology atom array' ) itemp ( 1 : nmol ) = istart_mol ( 1 : nmol ) deallocate ( istart_mol ) allocate ( istart_mol ( nmol + nmore ), stat = alloc_status ) call check_alloc ( 'reallocating topology atom array' ) istart_mol ( 1 : nmol ) = itemp ( 1 : nmol ) deallocate ( itemp ) else allocate ( istart_mol ( nmol + nmore ), stat = alloc_status ) call check_alloc ( 'reallocating topology atom array' ) end if end subroutine grow_arrays_for_solvent real function rwat_eff () ! local variables integer :: i , kr , isort , bins real ( 8 ) :: rc , rnwat integer , allocatable :: npro_of_r (:) real ( 8 ) :: rho_ratio , solvent_volume , rho_solvent rwat_eff = 0 if ( nwat . eq . 0 ) return !make sure to include all waters in topology bins = int ( max ( abs ( rwat ), rexcl_o ) * 100 ) + 1000 allocate ( npro_of_r ( bins ), stat = alloc_status ) call check_alloc ( 'protein radial distribution array' ) npro_of_r (:) = 0 do i = 1 , nat_solute rc = sqrt ( dot_product ( xtop ( 3 * i - 2 : 3 * i ) - xwcent (:),& xtop ( 3 * i - 2 : 3 * i ) - xwcent (:))) isort = int ( 10 0. * rc ) if ( isort . eq . 0 ) isort = 1 if ( isort . le . bins ) then if ( heavy ( i ) . and . (. not . excl ( i ))) & npro_of_r ( isort ) = npro_of_r ( isort ) + 1 end if end do !calc solvent density solvent_volume = 0. do i = nres_solute + 1 , nres if ( lib ( res ( i )% irc )% density > 0 ) then solvent_volume = solvent_volume + 1. / lib ( res ( i )% irc )% density end if end do rho_solvent = nwat / solvent_volume ! --- rho_ratio (0.577) comes from dividing the average volume of !     protein atoms (17.26 A**3) by the volume of a water molecule (29.9 A**3). rho_ratio = rho_solvent / rho_solute rnwat = 0.0 do kr = 1 , bins rc = real ( kr ) * 0.01 rnwat = rnwat + 4. * pi * rc * rc * rho_solvent & * 0.01 - rho_ratio * npro_of_r ( kr ) if ( int ( rnwat ) >= nwat - nexwat ) exit end do rwat_eff = rc deallocate ( npro_of_r ) end function rwat_eff type ( TOR_CODES ) function torcode ( taci , tacj , tack , tacl ) !arguments character ( KEYLENGTH ) :: taci , tacj , tack , tacl ! *** local variables integer i character ( KEYLENGTH ) :: ti , tj , tk , tl ti = wildcard_tac ( taci ) tj = wildcard_tac ( tacj ) tk = wildcard_tac ( tack ) tl = wildcard_tac ( tacl ) torcode % ncod = 0 torcode % cod (:) = 0 !search for exact match first do i = 1 , ntor_types if (( ti == tor_types ( i )% taci . and . tj == tor_types ( i )% tacj & . and . tk == tor_types ( i )% tack . and . tl == tor_types ( i )% tacl ) & . or . & ( ti == tor_types ( i )% tacl . and . tj == tor_types ( i )% tack . and . tk == tor_types ( i )% tacj & . and . tl == tor_types ( i )% taci )) then torcode % ncod = torcode % ncod + 1 torcode % cod ( torcode % ncod ) = tor_types ( i )% cod endif enddo if ( torcode % ncod > 0 ) return !stop looking if something was found !then search with wildcard at i do i = 1 , ntor_types if ( tor_types ( i )% taci == '' ) then if (( tj == tor_types ( i )% tacj . and . tk == tor_types ( i )% tack . and . tl == tor_types ( i )% tacl ) . or . & ( ti == tor_types ( i )% tacl . and . tj == tor_types ( i )% tack . and . tk == tor_types ( i )% tacj )) then torcode % ncod = torcode % ncod + 1 torcode % cod ( torcode % ncod ) = tor_types ( i )% cod endif endif enddo if ( torcode % ncod > 0 ) return !stop looking if something was found !then search with wildcard at l do i = 1 , ntor_types if ( tor_types ( i )% tacl == '' ) then if (( ti == tor_types ( i )% taci . and . tj == tor_types ( i )% tacj . and . tk == tor_types ( i )% tack ) . or . & ( tj == tor_types ( i )% tack . and . tk == tor_types ( i )% tacj . and . tl == tor_types ( i )% taci )) then torcode % ncod = torcode % ncod + 1 torcode % cod ( torcode % ncod ) = tor_types ( i )% cod endif endif enddo if ( torcode % ncod > 0 ) return !stop looking if something was found !then search with wildcards at i & l do i = 1 , ntor_types if ( tor_types ( i )% taci == '' . and . tor_types ( i )% tacl == '' ) then if (( tj == tor_types ( i )% tacj . and . tk == tor_types ( i )% tack ) . or . & ( tj == tor_types ( i )% tack . and . tk == tor_types ( i )% tacj )) then torcode % ncod = torcode % ncod + 1 torcode % cod ( torcode % ncod ) = tor_types ( i )% cod endif endif enddo if ( torcode % ncod > 0 ) return !stop looking if something was found !then search with wildcards at i & j or k & l do i = 1 , ntor_types if ( tor_types ( i )% taci == '' . and . tor_types ( i )% tacj == '' ) then if (( tk == tor_types ( i )% tack . and . tl == tor_types ( i )% tacl ) . or . & ( ti == tor_types ( i )% tacl . and . tj == tor_types ( i )% tack )) then torcode % ncod = torcode % ncod + 1 torcode % cod ( torcode % ncod ) = tor_types ( i )% cod endif ELSEif ( tor_types ( i )% tack == '' . and . tor_types ( i )% tacl == '' ) then if (( ti == tor_types ( i )% taci . and . tj == tor_types ( i )% tacj ) . or . & ( tl == tor_types ( i )% taci . and . tk == tor_types ( i )% tacj )) then torcode % ncod = torcode % ncod + 1 torcode % cod ( torcode % ncod ) = tor_types ( i )% cod endif endif enddo if ( torcode % ncod > 0 ) return !stop looking if something was found write ( * , '(a,4(1x,a8))' ) '>>> Missing torsion type for atom types' , & ti , tj , tk , tl topo_ok = . false . !....................................................................... end function torcode subroutine tors_ene ( emax , nlarge , av_ene ) ! *** local variables integer i , j , k , l , ip , ic , i3 , j3 , k3 , l3 , nlarge real rji ( 3 ), rjk ( 3 ), rkl ( 3 ), rnj ( 3 ), rnk ( 3 ), bj , bk , scp , & phi , sgn , pe , dv , rki ( 3 ), rlj ( 3 ), dp ( 12 ), arg , f1 , di ( 3 ), & dl ( 3 ) real emax , av_ene !....................................................................... nlarge = 0 av_ene = 0 do ip = 1 , ntors i = tor ( ip )% i j = tor ( ip )% j k = tor ( ip )% k l = tor ( ip )% l ic = tor ( ip )% cod if ( ic == 0 ) then !missing parameter write ( * , '(5i5,1x,a)' ) ip , i , j , k , l , 'MISSING PARAMETERS' cycle end if i3 = i * 3 - 3 j3 = j * 3 - 3 k3 = k * 3 - 3 l3 = l * 3 - 3 rji ( 1 ) = xtop ( i3 + 1 ) - xtop ( j3 + 1 ) rji ( 2 ) = xtop ( i3 + 2 ) - xtop ( j3 + 2 ) rji ( 3 ) = xtop ( i3 + 3 ) - xtop ( j3 + 3 ) rjk ( 1 ) = xtop ( k3 + 1 ) - xtop ( j3 + 1 ) rjk ( 2 ) = xtop ( k3 + 2 ) - xtop ( j3 + 2 ) rjk ( 3 ) = xtop ( k3 + 3 ) - xtop ( j3 + 3 ) rkl ( 1 ) = xtop ( l3 + 1 ) - xtop ( k3 + 1 ) rkl ( 2 ) = xtop ( l3 + 2 ) - xtop ( k3 + 2 ) rkl ( 3 ) = xtop ( l3 + 3 ) - xtop ( k3 + 3 ) rnj ( 1 ) = rji ( 2 ) * rjk ( 3 ) - rji ( 3 ) * rjk ( 2 ) rnj ( 2 ) = rji ( 3 ) * rjk ( 1 ) - rji ( 1 ) * rjk ( 3 ) rnj ( 3 ) = rji ( 1 ) * rjk ( 2 ) - rji ( 2 ) * rjk ( 1 ) rnk ( 1 ) = - rjk ( 2 ) * rkl ( 3 ) + rjk ( 3 ) * rkl ( 2 ) rnk ( 2 ) = - rjk ( 3 ) * rkl ( 1 ) + rjk ( 1 ) * rkl ( 3 ) rnk ( 3 ) = - rjk ( 1 ) * rkl ( 2 ) + rjk ( 2 ) * rkl ( 1 ) bj = sqrt ( rnj ( 1 ) ** 2 + rnj ( 2 ) ** 2 + rnj ( 3 ) ** 2 ) bk = sqrt ( rnk ( 1 ) ** 2 + rnk ( 2 ) ** 2 + rnk ( 3 ) ** 2 ) scp = ( rnj ( 1 ) * rnk ( 1 ) + rnj ( 2 ) * rnk ( 2 ) + rnj ( 3 ) * rnk ( 3 ) )& / ( bj * bk ) if ( scp > 1.0 ) scp = 1.0 if ( scp < - 1.0 ) scp = - 1.0 phi = acos ( scp ) sgn = rjk ( 1 ) * ( rnj ( 2 ) * rnk ( 3 ) - rnj ( 3 ) * rnk ( 2 ) ) + rjk ( 2 )& * ( rnj ( 3 ) * rnk ( 1 ) - rnj ( 1 ) * rnk ( 3 ) ) + rjk ( 3 ) * ( rnj ( 1 ) & * rnk ( 2 ) - rnj ( 2 ) * rnk ( 1 ) ) if ( sgn < 0 ) phi = - phi ! ---   energy arg = torlib ( ic )% rmult * phi - torlib ( ic )% deltor * pi / 18 0. pe = torlib ( ic )% fk * ( 1.0 + cos ( arg ) ) / real ( torlib ( ic )% paths ) av_ene = av_ene + pe if ( pe > emax ) then nlarge = nlarge + 1 write ( * , '(6i5,5f8.2)' ) ip , i , j , k , l , ic , torlib ( ic )% fk , & torlib ( ic )% rmult , torlib ( ic )% deltor , phi * 18 0. / pi , pe endif enddo if ( ntors /= 0 ) av_ene = av_ene / real ( ntors ) end subroutine tors_ene logical function check_residues () !locals integer :: i , j !stop immediately if no library if ( nlibres == 0 . and . nat_pro > 0 ) then check_residues = . false . write ( * , '(a)' ) '>>>>>ERROR: No library loaded.' return end if check_residues = . true . !check that all residues are in the library resloop : do i = 1 , nres libloop : do j = 1 , nlibres if ( res ( i )% name == lib ( j )% nam ) then res ( i )% irc = j cycle resloop endif enddo libloop !if we reach here then the library entry was not found write ( * , '(a,i3,a)' ) '>>> Residue ' , i , ' not found in library: ' , & res ( i )% name check_residues = . false . enddo resloop end function check_residues subroutine writepdb ! *** local variables CHARACTER ( len = 80 ) :: filnam character ( len = 1 ) :: reply character ( * ), parameter :: gap = & '                 GAP                                      ' character ( * ), parameter :: ter = 'TER   ' integer :: i , j , k , l , imol integer :: iat integer :: iwrite_g logical :: wrote_atom_in_molecule character ( len = 6 ) :: PDBtype integer :: lig ( 4 ) !atoms connected to atom i if (. not . check_residues ()) then call parse_reset () return end if if ( mask % included == 0 ) then write ( * , 900 ) 900 format ( '>>>>> ERROR: The mask is empty - no atoms to write!' ) return end if write ( * , * ) call get_string_arg ( filnam , '-----> Name of PBD file: ' ) if ( openit ( 3 , filnam , 'unknown' , 'formatted' , 'write' ) /= 0 ) then call parse_reset return end if REWIND ( 3 ) CALL get_string_arg ( reply , '-----> Write out TER cards [y/n] ? ' ) select case ( reply ) case ( 'y' , 'Y' ) iwrite_g = 1 case default iwrite_g = 0 end select !PDB standard minus B-factors 10        format(a6,i5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3f8.3) !See readpdb for specification of the format !Old format  10 format(a6,i5,2x,a4,a4,i5,4x,3f8.3) !TODO: Fix writing of chainID, requires chain info in topology. !(PDBtype,atomNr,atomName,resName,resNr,coords) 10 format ( a6 , i5 , 1 x , a5 , a3 , 2 x , i4 , 4 x , 3 f8 . 3 ) 11 format ( a6 , 11 x , a3 , 2 x , i4 ) !For TER cards iat = 0 imol = 1 wrote_atom_in_molecule = . false . do i = 1 , nres if ( lib ( res ( i )% irc )% HETATM ) then PDBtype = 'HETATM' else PDBtype = 'ATOM  ' end if do j = 1 , lib ( res ( i )% irc )% nat iat = iat + 1 !write only atoms in mask if ( mask % mask ( iat )) then write ( 3 , 10 ) PDBtype , iat , lib ( res ( i )% irc )% atnam ( j ), res ( i )% name ,& i , xtop ( iat * 3 - 2 : iat * 3 ) wrote_atom_in_molecule = . true . end if enddo if ( i < nres_solute . and . imol < nmol ) then if ( istart_mol ( imol + 1 ) == iat + 1 ) then imol = imol + 1 if ( iwrite_g > 0 . and . wrote_atom_in_molecule ) then write ( 3 , 11 ) ter , res ( i )% name , i end if wrote_atom_in_molecule = . false . endif end if enddo !now write connect records for HETATM groups do i = 1 , nres_solute !loop over all solute residues if ( lib ( res ( i )% irc )% HETATM ) then !only for HETATM groups j = 1 !work through all bonds do while ( j <= lib ( res ( i )% irc )% nbnd ) !this is the first atom iat = res ( i )% start - 1 + lib ( res ( i )% irc )% bnd ( j )% i !find a set of up to four bonds from this atom l = 0 do k = 1 , 4 lig ( k ) = res ( i )% start - 1 + lib ( res ( i )% irc )% bnd ( j )% j j = j + 1 !include only ligand atoms which are in the mask if ( mask % mask ( lig ( k ))) l = l + 1 if ( j > lib ( res ( i )% irc )% nbnd ) exit !stop if new bond has different i atom if ( res ( i )% start - 1 + lib ( res ( i )% irc )% bnd ( j )% i /= iat ) exit end do if ( mask % mask ( iat ) . and . l > 0 ) write ( 3 , 20 ) iat , lig ( 1 : l ) end do end if end do 20 format ( 'CONECT' , 5 i5 ) write ( * , '(/,a,/)' ) 'PDB file successfully written.' close ( 3 ) end subroutine writepdb subroutine writemol2 ! *** local variables CHARACTER filnam * 80 , reply * 1 character :: mol_name * 16 , ti * 1 , tj * 1 integer :: i , cnt , j , iat integer :: u integer :: mol , mol_start , mol_end , nat_mol , nbnd_mol integer :: at_start , at_end , res_start , res_end integer :: bnd_start , bnd_end , new_last , new_res logical :: iwrite_h , iwrite_w integer :: nres_mol , res_atoms ( nres ), new_num ( nat_pro ) integer :: new_resnum ( nres ) integer :: dict_type if (. not . check_residues ()) then call parse_reset () return end if if ( mask % included == 0 ) then write ( * , 900 ) 900 format ( '>>>>> ERROR: The mask is empty - no atoms to write!' ) return end if call get_string_arg ( filnam , '-----> Name of Mol2 file (or auto): ' ) 5 format ( '#       Mol2 file written by Qprep version 5' , / ,& '#       Title of topology: ' , a , / ,& '#       Coordinate source: ' , a ) ! atom records 10 format ( i6 , 1 x , a4 , 4 x , 3 f10 . 3 , 2 x , a , t55 , i6 , 2 x , a4 , 2 x , f6 . 3 ) !atom record !              #    nam    xyz     atyp  res# rnam    q !bond record 20 format ( i6 , 1 x , i6 , 1 x , i6 , 4 x , a3 ) !          #     i      j    typ !molecule record : name,atoms, bonds, substr., features, sets, mol_type, charge_type 30 format ( / , '@<TRIPOS>MOLECULE' , / , 'MOLECULE' , / , 5 ( i6 , 1 x ), / , a , / , a , / ) !substructure record 40 format ( i6 , 1 x , a3 , a , t18 , i6 , 1 x , a , t34 , i1 , 1 x , a1 , 1 x , a4 ) !substructure record !           #    name#    start kind  dict chain, restyp !get new atom numbers new_num (:) = 0 !reset j = 0 do i = 1 , nat_pro if ( mask % mask ( i )) then j = j + 1 new_num ( i ) = j end if end do !count atoms in residues do i = 1 , nres - 1 res_atoms ( i ) = count ( mask % mask ( res ( i )% start : res ( i + 1 )% start - 1 )) end do res_atoms ( nres ) = count ( mask % mask ( res ( nres )% start : nat_pro )) !renumber residues nres_mol = 0 do i = 1 , nres if ( res_atoms ( i ) > 0 ) then nres_mol = nres_mol + 1 new_resnum ( i ) = nres_mol end if end do !count bonds nbnd_mol = 0 do i = 1 , nbonds if ( mask % mask ( bnd ( i )% i ) . and . mask % mask ( bnd ( i )% j )) then !both atoms are in mask nbnd_mol = nbnd_mol + 1 end if end do !name & open file if ( filnam == 'auto' . or . filnam == 'AUTO' ) then !generate name write ( filnam , 110 ) trim ( auto_name ), trim ( adjustl ( mol_name )) end if 110 format ( a , a , '.mol2' ) u = freefile () if ( openit ( u , filnam , 'unknown' , 'formatted' , 'write' ) /= 0 ) then call parse_reset () return end if !write header write ( u , 5 ) title , coord_source !write molecule record write ( u , 30 ) mask % included , nbnd_mol , nres_mol , 0 , 0 , 'SMALL' , 'USER_CHARGES' iat = 0 new_res = 0 write ( u , '(a)' ) '@<TRIPOS>ATOM' do i = 1 , nres do j = 1 , lib ( res ( i )% irc )% nat iat = iat + 1 if ( mask % mask ( iat )) then write ( u , 10 ) new_num ( iat ), lib ( res ( i )% irc )% atnam ( j ), & xtop ( iat * 3 - 2 : iat * 3 ), SYBYL_atom_type ( iac ( iat )), & new_resnum ( i ), res ( i )% name , crg ( iat ) end if enddo enddo !Write bond records write ( u , '(a)' ) '@<TRIPOS>BOND' iat = 0 do i = 1 , nbonds if ( mask % mask ( bnd ( i )% i ) . and . mask % mask ( bnd ( i )% j )) then !both atoms are in mask iat = iat + 1 if ( SYBYL_bond_type ( bnd ( i )% cod ) == '' ) then write ( u , 20 ) iat , new_num ( bnd ( i )% i ), new_num ( bnd ( i )% j ), \"1\" else write ( u , 20 ) iat , new_num ( bnd ( i )% i ), new_num ( bnd ( i )% j ), & SYBYL_bond_type ( bnd ( i )% cod ) end if end if end do !write substructure records write ( u , '(a)' ) '@<TRIPOS>SUBSTRUCTURE' new_res = 0 do i = 1 , nres if ( res_atoms ( i ) > 0 ) then new_res = new_res + 1 at_start = res ( i )% start !if no hydrogens then skip forward to first heavy atom do while (. not . mask % mask ( at_start )) at_start = at_start + 1 end do dict_type = 0 if ( lib ( res ( i )% irc )% SYBYLTYPE == 'RESIDUE' ) dict_type = 1 write ( mol_name , '(i6)' ) i write ( u , 40 ) new_resnum ( i ), res ( i )% name , adjustl ( mol_name ), new_num ( at_start ),& lib ( res ( i )% irc )% SYBYLTYPE , dict_type , 'A' , res ( i )% name end if end do close ( u ) write ( * , '(/,a,/)' ) 'Mol2 file successfully written.' end subroutine writemol2 subroutine writetop ! *** local variables CHARACTER filnam * 80 integer i , j , ig CHARACTER answer * 10 ! --- Warn if missing parameters were found by maketop if (. not . topo_ok ) then write ( * , * ) 'WARNING: The topology is incomplete due to missing parameters!' write ( * , * ) 'Do you realLY want to write this erronenous topology?' write ( * , * ) 'Enter yes to proceed, anything else to cancel.' call parse_reset CALL get_string_arg ( answer , '-----> Write _ERRONENOUS_ topology [yes/NO] ? ' ) if ( answer /= 'yes' ) then return endif endif write ( * , * ) CALL get_string_arg ( filnam , '-----> Give name of new topology file: ' ) call topo_save ( filnam ) end subroutine writetop !------------------------------------------------------------------------------! ! subroutine: listprefs ! !------------------------------------------------------------------------------! subroutine listprefs call pref_list ( 'Preferences (use set command to change):' ) end subroutine listprefs !------------------------------------------------------------------------------! ! subroutine: set ! !------------------------------------------------------------------------------! subroutine set !locals character ( len = PREF_LEN ) :: name , value logical :: l call get_string_arg ( name , '-----> Enter name (or number): ' ) call get_string_arg ( value , '-----> Enter value: ' ) l = pref_set ( name , value ) end subroutine set !------------------------------------------------------------------------------! ! subroutine: make_shell2 ! ! Sort out atoms in restrained shell. Use protein center to calculate distance. ! Use coordinates from topology unless 'implicit_rstr_from_file' is specified ! Swiped from md.f90, needed when using atom masks \"not restrained\" !------------------------------------------------------------------------------! subroutine make_shell2 ! *** Local variables integer :: i , ig , i3 , k real ( 8 ) :: rout2 , rin2 , r2 real ( 8 ), allocatable :: cgp_cent (:,:) nshellats = 0 rexcl_i = get_real_arg ( '-----> Inner radius of restrained shell ' ) rin2 = rexcl_i ** 2 shell (:) = . false . allocate ( cgp_cent ( 3 , ncgp + nwat )) cgp_cent (:,:) = 0. do ig = 1 , ncgp_solute if (. not . excl ( cgp ( ig )% iswitch )) then do i = cgp ( ig )% first , cgp ( ig )% last i3 = cgpatom ( i ) * 3 cgp_cent (:, ig ) = cgp_cent (:, ig ) + xtop ( i3 - 2 : i3 ) end do cgp_cent (:, ig ) = cgp_cent (:, ig ) / real ( cgp ( ig )% last - cgp ( ig )% first + 1 ) r2 = dot_product ( cgp_cent (:, ig ) - xpcent (:), cgp_cent (:, ig ) - xpcent (:)) if ( r2 . gt . rin2 ) then do i = cgp ( ig )% first , cgp ( ig )% last nshellats = nshellats + 1 shell ( cgpatom ( i )) = . true . end do end if end if end do deallocate ( cgp_cent ) write ( * , 105 ) nshellats , rexcl_i , rexcl_o 105 format ( 'Found   ' , i6 , ' solute atoms in the restrained shell region (' , f6 . 2 , ' to ' , f6 . 2 , ')' ) end subroutine make_shell2 !------------------------------------------------------------------------------! ! function: get_centre_by_mass ! ! Returns true if centre of mass can be assigned ! and returns centre of mass for a mask of atoms in the vector 'centre' !------------------------------------------------------------------------------! logical function get_centre_by_mass ( centre ) real ( 8 ), intent ( out ) :: centre ( 3 ) type ( mask_type ) :: mask integer :: ats , imaskat , iat real ( 8 ) :: totmass , mass get_centre_by_mass = . false . centre = 0 totmass = 0 call mask_initialize ( mask ) ats = maskmanip_make_pretop ( mask ) if (. not . allocated ( iac )) allocate ( iac ( nat_pro )) call set_iac !Set info about masses do iat = 1 , nat_pro if ( mask % mask ( iat )) then if ( heavy ( iat )) then !skip hydrogens mass = iaclib ( iac ( iat ))% mass totmass = totmass + mass centre = centre + mass * xtop ( iat * 3 - 2 : iat * 3 ) end if end if end do centre = centre / totmass get_centre_by_mass = . true . end function get_centre_by_mass end module prep","tags":"","loc":"sourcefile/prep.f90.html","title":"prep.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  prmfile.f90 !  by John Marelius !  parsing of data files with sections+keywords (input/parameter/library/FEP) !------------------------------------------------------------------------------! module prmfile !This module reads files with the following format ![section_name] !key  value !key                             value  !comment !#comment !!comment !*comment !key value ![another_section] !value value value value !value value value value !value value value value !section_name identifies a section in the file which can be opened with !prm_open_section. The name is not case-sensitive. !Blank lines and lines starting with '!', '*' or '#' are ignored. !White spaces anywhere in key-value lines are ignored. !Values may be followed by comments initated by '!', '*' or '#' !Keys identify the values by a label. A key name may not contain white-space. !The parameter file is opened by the function !prm_open(file) where \"file\" is the file name. prm_open returns .true. on !success or .false. on failure (if the file does not exist or can't be opened) !Data from the file is retrieved by calling the data retrieval functions !which all return .true. on success or .false. on failure !Entire lines within a section are retrieved by prm_get_line(line) where !line is a string of suitable length to hold the expected data !Key-value pairs can be retrieved by the following functions !prm_get_value_by_key(key, value) !       with the input argument \"key\" identifying the key and the !       output argument \"value\" which is an integer, a real or a string !       (different functions with same name for different data types) !prm_get_string_string(key, value) !       key and value are both strings !prm_get_string_int(key, value) !       key is string and value is integer !prm_get_string_real(key, value) !       key is string and value is real !prm_get_int_real(key, value) !       key is integer and value is real !prm_get_int_int(key, value) !       key and value are both integers !prm_get_int(value) !       there is no key, only an integer value use misc implicit none !constants character ( * ), private , parameter :: MODULE_VERSION = '5.7' character ( * ), private , parameter :: MODULE_DATE = '2015-02-22' !types, NOTE: maximum length of 500 chars per line type LINE_TYPE character ( len = 900 ) :: text type ( LINE_TYPE ), pointer :: next end type LINE_TYPE type SECTION_TYPE character ( len = 80 ) :: name type ( SECTION_TYPE ), pointer :: next type ( LINE_TYPE ), pointer :: lp integer :: count , max_enum end type SECTION_TYPE !module variables type ( SECTION_TYPE ), pointer :: first_sec , current_sec type ( LINE_TYPE ), pointer :: current_lp integer :: section_count character ( len = 80 ) :: current_title , next_title integer , private :: PRM_U = 0 character ( 200 ), private :: PRM_FN integer , private :: stat private :: find_section private :: split private :: splitone private :: get_strings private :: load contains subroutine prmfile_startup end subroutine prmfile_startup !--------------------------------------------------------------------- logical function prm_get_integer_by_key ( key , value , default ) !arguments character ( * ) :: key integer , intent ( out ) :: value integer , intent ( in ), optional :: default !locals character ( len = 80 ) :: inkey do while ( prm_get_string_int ( inkey , value )) if ( inkey . eq . key ) then prm_get_integer_by_key = . true . return end if end do !go to beginning of section and try again call rewind_section do while ( prm_get_string_int ( inkey , value )) if ( inkey . eq . key ) then prm_get_integer_by_key = . true . return end if end do if ( present ( default )) then value = default prm_get_integer_by_key = . true . else value = 0 prm_get_integer_by_key = . false . end if end function prm_get_integer_by_key !-------------------------------------------------------------- logical function prm_get_real_by_key ( key , value , default ) !arguments character ( * ) :: key real , intent ( out ) :: value real , intent ( in ), optional :: default !locals character ( len = 80 ) :: inkey do while ( prm_get_string_real ( inkey , value )) if ( inkey . eq . key ) then prm_get_real_by_key = . true . return end if end do !go to beginning of section and try again call rewind_section do while ( prm_get_string_real ( inkey , value )) if ( inkey . eq . key ) then prm_get_real_by_key = . true . return end if end do if ( present ( default )) then value = default prm_get_real_by_key = . true . else value = 0. prm_get_real_by_key = . false . end if end function prm_get_real_by_key !----------------------------------------------------------------- logical function prm_get_real8_by_key ( key , value , default ) !arguments character ( * ) :: key real ( 8 ), intent ( out ) :: value real ( 8 ), intent ( in ), optional :: default !locals character ( len = 80 ) :: inkey do while ( prm_get_string_real8 ( inkey , value )) if ( inkey . eq . key ) then prm_get_real8_by_key = . true . return end if end do !go to beginning of section and try again call rewind_section do while ( prm_get_string_real8 ( inkey , value )) if ( inkey . eq . key ) then prm_get_real8_by_key = . true . return end if end do if ( present ( default )) then value = default prm_get_real8_by_key = . true . else value = 0. prm_get_real8_by_key = . false . end if end function prm_get_real8_by_key !---------------------------------------------------------- logical function prm_get_string_by_key ( key , value , default ) !arguments character ( * ) :: key character ( * ), intent ( out ) :: value character ( * ), intent ( in ), optional :: default !locals character ( len = 80 ) :: mykey , inkey , invalue mykey = trim ( key ) call upcase ( mykey ) do while ( prm_get_string_string ( inkey , invalue )) call upcase ( inkey ) if ( trim ( inkey ) . eq . mykey ) then prm_get_string_by_key = . true . value = invalue return end if end do !go to beginning of section and try again call rewind_section do while ( prm_get_string_string ( inkey , invalue )) call upcase ( inkey ) if ( trim ( inkey ) . eq . mykey ) then prm_get_string_by_key = . true . value = invalue return end if end do if ( present ( default )) then value = default prm_get_string_by_key = . true . else !don't change value if not found prm_get_string_by_key = . false . end if end function prm_get_string_by_key !---------------------------------------------------------------- logical function prm_get_line_by_key ( key , value , default ) !arguments character ( * ) :: key character ( * ), intent ( out ) :: value character ( * ), intent ( in ), optional :: default !locals character ( len = 80 ) :: inkey character ( len = 200 ) :: invalue do while ( prm_get_string_line ( inkey , invalue )) if ( inkey . eq . key ) then prm_get_line_by_key = . true . value = invalue return end if end do !go to beginning of section and try again call rewind_section do while ( prm_get_string_line ( inkey , invalue )) if ( inkey . eq . key ) then prm_get_line_by_key = . true . value = invalue return end if end do if ( present ( default )) then value = default prm_get_line_by_key = . true . else !don't change value if not found prm_get_line_by_key = . false . end if end function prm_get_line_by_key !------------------------------------------------------------------ logical function prm_get_logical_by_key ( key , value , default ) !arguments character ( * ) :: key logical , intent ( out ) :: value logical , intent ( in ), optional :: default !locals character ( len = 80 ) :: inkey character ( len = 80 ) :: invalue do while ( prm_get_string_string ( inkey , invalue )) if ( inkey . eq . key ) then goto 100 end if end do !go to beginning of section and try again call rewind_section do while ( prm_get_string_string ( inkey , invalue )) if ( inkey . eq . key ) then goto 100 end if end do if ( present ( default )) then value = default prm_get_logical_by_key = . true . else !don't change value if not found prm_get_logical_by_key = . false . end if return 100 if ( invalue == 'on' . or . invalue == 'ON' . or . invalue == '1' ) then value = . true . prm_get_logical_by_key = . true . elseif ( invalue == 'off' . or . invalue == 'OFF' . or . invalue == '0' ) then value = . false . prm_get_logical_by_key = . true . else prm_get_logical_by_key = . false . end if end function prm_get_logical_by_key !-------------------------------------------------------------------------------- logical function prm_get_line ( line ) !arguments character ( * ), intent ( out ) :: line !if there's a line if ( associated ( current_lp )) then !retrieve it line = current_lp % text !and move one step forward current_lp => current_lp % next prm_get_line = . true . else line = '' prm_get_line = . false . end if end function prm_get_line !-------------------------------------------------------------------------- logical function prm_get_field ( field , skip ) !arguments character ( * ), intent ( out ) :: field logical , optional , intent ( in ) :: skip !locals character ( len = 500 ), save :: line integer , save :: pos , linelen type ( LINE_TYPE ), pointer , save :: my_line character , save :: TAB = char ( 9 ) integer :: start_field , end_field logical :: prm_res prm_get_field = . false . if ( present ( skip )) then if ( skip ) then nullify ( my_line ) pos = 0 linelen = 0 return end if end if !if other lines were read since last call, get a new one if ( associated ( current_lp ) . and . . not . associated ( my_line , current_lp )) then if ( prm_get_line ( line )) then my_line => current_lp pos = 1 linelen = len_trim ( line ) else nullify ( my_line ) pos = 0 linelen = 0 return end if end if do while ( line ( pos : pos ) == ' ' . or . line ( pos : pos ) == TAB ) pos = pos + 1 if ( pos > linelen ) then nullify ( my_line ) !next time new line return end if end do start_field = pos do while ( line ( pos : pos ) /= ' ' . and . line ( pos : pos ) /= TAB ) pos = pos + 1 if ( pos > linelen ) then exit end if end do end_field = pos - 1 pos = pos + 1 !update for next call field = line ( start_field : end_field ) prm_get_field = . true . end function prm_get_field !--------------------------------------------------------------------------------- ! Finds and return the number of input lines in the section 'section' !--------------------------------------------------------------------------------- integer function prm_count ( section ) !argument character ( * ), intent ( in ) :: section if ( find_section ( section )) then prm_count = current_sec % count else prm_count = 0 end if end function prm_count !------------------------------------------------------------------------------- ! Find and return largest number in first column in specified section. ! Optional: Return number of lines in section in 'count_out' !------------------------------------------------------------------------------- integer function prm_max_enum ( section , count_out ) !argument character ( * ), intent ( in ) :: section integer , optional , intent ( out ) :: count_out !locals character ( 200 ) :: line integer :: max_enum , enum , count logical :: dummy max_enum = 0 count = 0 if ( find_section ( section )) then do while ( prm_get_int ( enum )) if ( enum > max_enum ) max_enum = enum end do !go back call rewind_section count = current_sec % count end if prm_max_enum = max_enum if ( present ( count_out )) count_out = count end function prm_max_enum !------------------------------------------------------------------------------- ! Find and return largest number in second column in specified section. ! Optional: Return number of lines in section in 'count_out' !------------------------------------------------------------------------------- integer function prm_max_enum2 ( section , count_out ) !argument character ( * ), intent ( in ) :: section integer , optional , intent ( out ) :: count_out !locals character ( 200 ) :: line , tmp_str integer :: max_enum , enum , count logical :: dummy max_enum = 0 count = 0 if ( find_section ( section )) then do while ( prm_get_string_int ( tmp_str , enum )) if ( enum > max_enum ) max_enum = enum end do !go back call rewind_section count = current_sec % count end if prm_max_enum2 = max_enum if ( present ( count_out )) count_out = count end function prm_max_enum2 !----------------------------------------------------------------------------- logical function prm_get_string_string ( key , value ) !arguments character ( * ), intent ( out ) :: key character ( * ), intent ( out ) :: value prm_get_string_string = get_strings ( key , value ) end function prm_get_string_string !----------------------------------------------------------------------------- logical function prm_get_string_line ( key , value ) !arguments character ( * ), intent ( out ) :: key character ( * ), intent ( out ) :: value !locals character ( 200 ) :: line logical :: stat key = '' value = '' prm_get_string_line = . false . stat = prm_get_line ( line ) if (. not . stat ) return if (. not . splitone ( line , key , value )) return prm_get_string_line = . true . end function prm_get_string_line !----------------------------------------------------------- logical function prm_get_string_int ( key , value ) !arguments character ( * ), intent ( out ) :: key integer , intent ( out ) :: value !locals character ( 200 ) :: str_value prm_get_string_int = get_strings ( key , str_value ) read ( str_value , fmt =* , iostat = stat ) value !read integer from value if ( stat == 0 ) then prm_get_string_int = . true . else prm_get_string_int = . false . endif end function prm_get_string_int !----------------------------------------------------------------------------- logical function prm_get_string_real ( key , value ) !arguments character ( * ), intent ( out ) :: key real , intent ( out ) :: value !locals character ( 200 ) :: str_value prm_get_string_real = get_strings ( key , str_value ) read ( str_value , fmt =* , iostat = stat ) value !read integer from value if ( stat == 0 ) then prm_get_string_real = . true . else prm_get_string_real = . false . end if end function prm_get_string_real !----------------------------------------------------------------------------- logical function prm_get_string_real8 ( key , value ) !arguments character ( * ), intent ( out ) :: key real ( 8 ), intent ( out ) :: value !locals character ( 200 ) :: str_value prm_get_string_real8 = get_strings ( key , str_value ) read ( str_value , fmt =* , iostat = stat ) value !read real from str_value if ( stat == 0 ) then prm_get_string_real8 = . true . else prm_get_string_real8 = . false . endif end function prm_get_string_real8 !--------------------------------------------------------------------------------- logical function prm_get_int_real ( key , value ) !arguments integer , intent ( out ) :: key real , intent ( out ) :: value !locals character ( 200 ) :: line prm_get_int_real = prm_get_line ( line ) read ( line , fmt =* , iostat = stat ) key , value !read integer from value if ( stat == 0 ) then prm_get_int_real = . true . else prm_get_int_real = . false . end if end function prm_get_int_real !--------------------------------------------------------------------------------- logical function prm_get_int_real8 ( key , value ) !arguments integer , intent ( out ) :: key real ( 8 ), intent ( out ) :: value !locals character ( 200 ) :: line prm_get_int_real8 = prm_get_line ( line ) read ( line , fmt =* , iostat = stat ) key , value !read integer from value if ( stat == 0 ) then prm_get_int_real8 = . true . else prm_get_int_real8 = . false . end if end function prm_get_int_real8 !---------------------------------------------------------------------------------- logical function prm_get_int_int ( key , value ) !arguments integer , intent ( out ) :: key integer , intent ( out ) :: value !locals character ( 200 ) :: line prm_get_int_int = prm_get_line ( line ) read ( line , fmt =* , iostat = stat ) key , value !read integer from value if ( stat == 0 ) then prm_get_int_int = . true . else prm_get_int_int = . false . end if end function prm_get_int_int !-------------------------------------------------------------------------- logical function prm_get_int ( value ) !arguments integer , intent ( out ) :: value !locals character ( 200 ) :: line prm_get_int = . false . if ( prm_get_line ( line )) then read ( line , fmt =* , iostat = stat ) value !read integer from value if ( stat == 0 ) then prm_get_int = . true . end if end if end function prm_get_int !---------------------------------------------------------------------------- logical function get_strings ( key , value ) !arguments character ( * ), intent ( out ) :: key character ( * ), intent ( out ) :: value !locals character ( 200 ) :: line logical :: stat key = '' value = '' get_strings = . false . stat = prm_get_line ( line ) if (. not . stat ) return if (. not . split ( line , key , value )) return get_strings = . true . end function get_strings !--------------------------------------------------------------------------------- logical function prm_open_section ( section , filename ) !arguments character ( * ), intent ( in ) :: section character ( * ), intent ( in ), optional :: filename !locals logical :: used if ( present ( filename )) then if ( filename == PRM_FN ) then !if the unit has been closed it needs re-opening inquire ( unit = PRM_U , opened = used ) if (. not . used ) then if (. not . prm_open ( filename )) then prm_open_section = . false . return end if end if else call prm_close if (. not . prm_open ( filename )) then prm_open_section = . false . return end if end if end if prm_open_section = find_section ( section ) end function prm_open_section !--------------------------------------------------------------------------------- subroutine rewind_section if ( associated ( current_sec )) then !point to first current_lp => current_sec % lp else call rewind_title end if end subroutine rewind_section !------------------------------------------------------------------------------ logical function find_section ( section ) !arguments character ( * ), intent ( in ) :: section !locals character ( 200 ) :: line logical :: rewound character ( 80 ) :: ucase_section integer :: sec_len integer :: filestat type ( SECTION_TYPE ), pointer :: new_sec ucase_section = section sec_len = len_trim ( section ) call upcase ( ucase_section ) !loop from current position to end new_sec => current_sec do while ( associated ( new_sec )) if ( new_sec % name == ucase_section ) goto 100 new_sec => new_sec % next end do !loop from start to current position new_sec => first_sec do while ( associated ( new_sec ) . and . . not . associated ( new_sec , current_sec )) if ( new_sec % name == ucase_section ) goto 100 new_sec => new_sec % next end do find_section = . false . return 100 current_sec => new_sec current_lp => current_sec % lp find_section = . true . end function find_section !--------------------------------------------------------------------------------------- logical function prm_get_next_title ( title ) !arguments character ( * ), intent ( out ) :: title title = '' prm_get_next_title = . false . if ( next_title > '' ) then current_title = next_title if ( load ()) then title = current_title prm_get_next_title = . true . end if end if end function prm_get_next_title !---------------------------------------------------------------------------- subroutine rewind_title current_sec => first_sec if ( associated ( current_sec )) then current_lp => current_sec % lp else nullify ( current_lp ) end if end subroutine rewind_title !------------------------------------------------------------------------------- logical function prm_open ( filename ) !arguments character ( * ), intent ( in ) :: filename call prm_close PRM_U = freefile () open ( unit = PRM_U , file = filename , status = 'old' , form = 'formatted' , & action = 'read' , iostat = stat , access = 'sequential' ) if ( stat /= 0 ) then prm_open = . false . PRM_U = 0 else PRM_FN = filename if ( load ()) then prm_open = . true . else prm_open = . false . call prm_close end if end if end function prm_open !--------------------------------------------------------------------------------- subroutine clear !locals type ( SECTION_TYPE ), pointer :: sp_next type ( LINE_TYPE ), pointer :: lp_next , lp_current !start with first section current_sec => first_sec !repeat until no more sections do while ( associated ( current_sec )) sp_next => current_sec % next !clear all line entries within the section lp_current => current_sec % lp do while ( associated ( lp_current )) lp_next => lp_current % next deallocate ( lp_current ) lp_current => lp_next end do deallocate ( current_sec ) current_sec => sp_next end do nullify ( first_sec ) end subroutine clear !-------------------------------------------------------------------------------------- subroutine prm_dump !locals type ( SECTION_TYPE ), pointer :: sp_next type ( LINE_TYPE ), pointer :: lp_next , lp_current !start with first section call rewind_title !repeat until no more sections do while ( associated ( current_sec )) write ( * , 100 ) trim ( current_sec % name ), current_sec % count lp_current => current_sec % lp do while ( associated ( lp_current )) write ( * , 200 ) trim ( lp_current % text ) lp_current => lp_current % next end do current_sec => current_sec % next end do call rewind_title 100 format ( '[' , a , '] !' , i4 , ' entries' ) 200 format ( a ) end subroutine prm_dump !----------------------------------------------------------------------------------- logical function load () !locals character ( len = 400 ) :: line integer :: stat integer :: end_of_text , comment_start , start , scan_start , comment_pos character :: WS * 2 , TAB TAB = char ( 9 ) WS ( 1 : 1 ) = ' ' WS ( 2 : 2 ) = TAB call clear next_title = '' !reset section_count = 0 load = . true . do line = '' read ( unit = PRM_U , fmt = '(a)' , iostat = stat ) line !check EOF or I/O error if ( stat > 0 ) then !read error load = . false . exit elseif ( stat < 0 ) then !EOF if ( line == '' ) exit !don't exit if something was on the last line end if start = verify ( line , WS ) if ( start == 0 ) cycle !it was all WS !skip blank and comment lines if ( line ( start : start ) == '!' . or . & line ( start : start ) == '#' . or . line ( start : start ) == '*' ) cycle !store next title if ( line ( start : start ) == '{' ) then end_of_text = index ( line , '}' ) if ( end_of_text > start + 1 ) then next_title = line ( start + 1 : end_of_text - 1 ) else !invalid title heading write ( * , '(a)' ) '>>>>> ERROR: Invalid title heading:' write ( * , '(a)' ) line load = . false . end if line = '' exit elseif ( line ( start : start ) == '[' ) then !is it a new section? end_of_text = index ( line , ']' ) if ( end_of_text > start + 1 ) then !create new section if ( section_count == 0 ) then allocate ( first_sec ) current_sec => first_sec else allocate ( current_sec % next ) current_sec => current_sec % next end if section_count = section_count + 1 current_sec % name = line ( start + 1 : end_of_text - 1 ) call upcase ( current_sec % name ) current_sec % count = 0 nullify ( current_sec % next ) !dissociate pointer nullify ( current_sec % lp ) !initialise line pointer to null else !invalid section heading write ( * , '(a)' ) '>>>>> ERROR: Invalid section heading:' write ( * , '(a)' ) line load = . false . exit end if else !if none of the above, then store the line !check if in a section, otherwise fail if ( section_count == 0 ) then load = . false . exit end if if ( current_sec % count == 0 ) then !allocate first allocate ( current_sec % lp ) current_lp => current_sec % lp else allocate ( current_lp % next ) !allocate subsequent current_lp => current_lp % next end if nullify ( current_lp % next ) !dissociate pointer current_sec % count = current_sec % count + 1 !find end-of-data in line !first avoid finding ! or # within quotes !comment_start = scan(line, '!#*') scan_start = 1 comment_start = 0 do comment_pos = scan ( line ( scan_start : len_trim ( line )), '!#*' ) + scan_start - 1 if ( comment_pos > scan_start ) then if ( line ( comment_pos : comment_pos ) == '!' . or . & scan ( line ( comment_pos - 1 : comment_pos - 1 ), WS ) > 0 ) then !it's a real comment comment_start = comment_pos exit else !this is # or * after a non-WS character, which in not a comment scan_start = comment_pos + 1 endif else exit endif end do if ( comment_start > 0 ) then !find last non-whitespace end_of_text = scan ( line ( 1 : comment_start - 1 ), WS , BACK = . TRUE .) - 1 if ( end_of_text <= 0 ) end_of_text = comment_start - 1 else end_of_text = len_trim ( line ) + 1 end if if ( comment_start > 0 ) then !find last non-whitespace end_of_text = scan ( line ( 1 : comment_start - 1 ), WS , BACK = . TRUE .) - 1 if ( end_of_text <= 0 ) end_of_text = comment_start - 1 else end_of_text = len_trim ( line ) + 1 end if !store the line without comment/trailing ws current_lp % text = line ( start : end_of_text ) end if end do call rewind_title !reset pointers end function load !------------------------------------------------------------------------------------ subroutine prm_close if ( PRM_U /= 0 ) then close ( PRM_U ) PRM_U = 0 end if call clear end subroutine prm_close !------------------------------------------------------------------------------------ logical function split ( line , key , value ) !arguments character ( * ), intent ( in ) :: line character ( * ), intent ( out ) :: key character ( * ), intent ( out ) :: value character , save :: TAB = char ( 9 ) !locals integer :: i integer :: key_start , key_end , value_start , value_end split = . false . key = '' value = '' !first skip leading ws do i = 1 , len ( line ) if ( line ( i : i ) /= ' ' . and . line ( i : i ) /= TAB ) exit end do if ( i >= len ( line )) return key_start = i !find end of key do i = key_start , len ( line ) if ( line ( i : i ) == ' ' . or . line ( i : i ) == TAB ) exit end do if ( i >= len ( line )) return key_end = i - 1 key = line ( key_start : key_end ) !skip ws to start of value do i = key_end + 2 , len ( line ) !start looking after the first ws character if ( line ( i : i ) /= ' ' . and . line ( i : i ) /= TAB ) exit end do if ( i >= len ( line )) return value_start = i !find end of value do i = value_start , len ( line ) if ( line ( i : i ) == ' ' . or . line ( i : i ) == TAB . or . line ( i : i ) == '!' ) exit end do value_end = i - 1 value = line ( value_start : value_end ) split = . true . end function split !------------------------------------------------------------------------------------ logical function splitone ( line , key , value ) !arguments character ( * ), intent ( in ) :: line character ( * ), intent ( out ) :: key character ( * ), intent ( out ) :: value character , save :: TAB = char ( 9 ) !locals integer :: i integer :: key_start , key_end , value_start , value_end splitone = . false . key = '' value = '' !first skip leading ws do i = 1 , len ( line ) if ( line ( i : i ) /= ' ' . and . line ( i : i ) /= TAB ) exit end do if ( i >= len ( line )) return key_start = i !find end of key do i = key_start , len ( line ) if ( line ( i : i ) == ' ' . or . line ( i : i ) == TAB ) exit end do if ( i >= len ( line )) return key_end = i - 1 key = line ( key_start : key_end ) !skip ws to start of value do i = key_end + 2 , len ( line ) !start looking after the first ws character if ( line ( i : i ) /= ' ' . and . line ( i : i ) /= TAB ) exit end do if ( i >= len ( line )) return value_start = i !find end of data do i = value_start , len ( line ) if ( line ( i : i ) == '!' . or . line ( i : i ) == '#' & . or . line ( i : i ) == '*' ) exit end do value_end = i - 1 value = line ( value_start : value_end ) splitone = . true . end function splitone !------------------------------------------------------------------------------------ end module prmfile","tags":"","loc":"sourcefile/prmfile.f90.html","title":"prmfile.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  qatom.f90 !  by John Marelius, Johan Aqvist & Martin Almlof !  Q-atom force field data and FEP file reading !------------------------------------------------------------------------------! module qatom use sizes use nrgy use misc use prmfile use indexer !use MPIGLOB use topo implicit none !constants character ( * ), private , parameter :: MODULE_NAME = 'Q-atom' character ( * ), private , parameter :: MODULE_VERSION = '5.7' character ( * ), private , parameter :: MODULE_DATE = '2015-02-22' !       Constants real ( 8 ), private :: pi , deg2rad !set in sub startup !----------------------------------------------------------------------- !       fep/evb information !----------------------------------------------------------------------- integer , parameter :: max_states = 10 integer , parameter :: max_qat = 1000 integer , parameter :: max_link = 10 integer :: nstates , nqat !******PWadded this variable !Topology atom number of the switching atom of the Q-atoms !Needed if periodic boundaries are used integer :: qswitch integer :: offset !offset number for topology atom numbers logical :: qvdw_flag logical :: qq_use_library_charges integer ( AI ), allocatable :: iqseq (:) integer , allocatable :: qiac (:,:) character ( len = KEYLENGTH ), allocatable :: qtac (:) integer :: nqexpnb integer ( AI ), allocatable :: iqexpnb (:), jqexpnb (:) integer :: nqlib real ( 4 ), allocatable :: qcrg (:,:) real ( 8 ), allocatable :: qmass (:) real ( 8 ), allocatable :: qavdw (:,:), qbvdw (:,:) integer :: nqbond type QBOND_TYPE integer ( AI ) :: i , j integer ( TINY ) :: cod ( max_states ) end type QBOND_TYPE type QBONDLIB_TYPE !Morse diss. en, Morse Alpha, Morse/Harm. r0 real ( 8 ) :: Dmz , amz , r0 !Harm. force const real ( 8 ) :: fk end type QBONDLIB_TYPE type ( QBOND_TYPE ), allocatable :: qbnd (:) type ( QBONDLIB_TYPE ), allocatable :: qbondlib (:) type QANGLE_TYPE integer ( AI ) :: i , j , k integer ( TINY ) :: cod ( max_states ) end type QANGLE_TYPE integer :: nqangle type ( QANGLE_TYPE ), allocatable :: qang (:) type ( ANGLIB_TYPE ), allocatable :: qanglib (:) integer :: nqtor integer ( AI ), allocatable :: iqtor (:), jqtor (:), kqtor (:), lqtor (:) integer ( TINY ), allocatable :: qtorcod (:,:) real ( 8 ), allocatable :: qfktor (:), qrmult (:), qdeltor (:) integer :: nqimp integer ( AI ), allocatable :: iqimp (:), jqimp (:), kqimp (:), lqimp (:) integer ( TINY ), allocatable :: qimpcod (:,:) real ( 8 ), allocatable :: qfkimp (:), qimp0 (:) integer :: nang_coupl , ntor_coupl , nimp_coupl integer ( AI ) :: iang_coupl ( 3 , max_qat ) integer ( AI ) :: itor_coupl ( 3 , max_qat ) integer ( AI ) :: iimp_coupl ( 3 , max_qat ) integer :: nqshake integer ( AI ) :: iqshake ( max_qat ), jqshake ( max_qat ) real ( 8 ) :: qshake_dist ( max_qat , max_states ) integer :: noffd type ( OFFDIAG_SAVE ), allocatable :: offd (:) type ( OFFDIAG_AUX ), allocatable :: offd2 (:) integer :: nexspec type SPECEX_TYPE integer ( AI ) :: i , j logical :: flag ( max_states ) end type SPECEX_TYPE type ( SPECEX_TYPE ), allocatable :: exspec (:) ! Monitoring of nonbonded interactions between selected groups of atoms type monitor_group_pair_TYPE integer :: i , j real ( 8 ) :: Vel ( max_states ), Vlj ( max_states ) real ( 8 ) :: Vwel , Vwlj , Vwsum end type monitor_group_pair_TYPE type ( monitor_group_pair_TYPE ), allocatable :: monitor_group_pair (:) type monitor_atom_group_TYPE integer , pointer :: atom (:) ! the atoms integer :: n ! #atoms end type monitor_atom_group_TYPE type ( monitor_atom_group_TYPE ), allocatable :: monitor_atom_group (:) !the maximum number of atoms in a group to be monitored !this is limited by the line length used in the prmfile module! integer , parameter :: MAX_ATOMS_IN_SPECIAL_GROUP = 30 integer :: monitor_group_pairs , monitor_groups !type holding all scaling factors for electrostatic interactions in qq-pairs type qq_el_scale_type integer ( AI ) :: iqat , jqat real ( 8 ) :: el_scale ( max_states ) ! holds the el_scale for different states \"masoud Oct_2013\" end type qq_el_scale_type type ( qq_el_scale_type ), allocatable :: qq_el_scale (:) integer :: nel_scale !number of defined scale factors integer :: tmpindex , numsoftlines , i2 real ( 8 ), allocatable :: sc_lookup (:,:,:), alpha_max (:,:) real ( 8 ) :: sc_aq , sc_bq , sc_aj , sc_bj , alpha_max_tmp logical :: softcore_use_max_potential !----------------------------------------------------------------------- !       fep/evb energies !----------------------------------------------------------------------- type ( Q_ENERGIES ), allocatable :: EQ (:) real ( 8 ) :: Hij ( max_states , max_states ) real ( 8 ) :: EMorseD ( max_qat ) real ( 8 ) :: dMorse_i ( 3 , max_qat ) real ( 8 ) :: dMorse_j ( 3 , max_qat ) !miscellany logical :: use_new_fep_format contains !------------------------------------------------------------------------- subroutine qatom_startup ! initialize used modules call prmfile_startup call nrgy_startup ! initialize constants pi = 4.0 * atan ( 1.0 ) deg2rad = pi / 18 0.0 100 format ( a , ' module' , t30 , 'version ' , a , t50 , '(modified on ' , a , ')' ) end subroutine qatom_startup !------------------------------------------------------------------------- subroutine qatom_shutdown integer :: alloc_status deallocate ( EQ , stat = alloc_status ) deallocate ( iqseq , qiac , iqexpnb , jqexpnb , qcrg , stat = alloc_status ) deallocate ( qmass , stat = alloc_status ) deallocate ( qavdw , qbvdw , stat = alloc_status ) deallocate ( qbnd , qbondlib , stat = alloc_status ) deallocate ( qang , stat = alloc_status ) deallocate ( qanglib , stat = alloc_status ) deallocate ( iqtor , jqtor , kqtor , lqtor , qtorcod , stat = alloc_status ) deallocate ( qfktor , qrmult , qdeltor , stat = alloc_status ) deallocate ( iqimp , jqimp , kqimp , lqimp , qimpcod , stat = alloc_status ) deallocate ( qfkimp , qimp0 , stat = alloc_status ) deallocate ( exspec , stat = alloc_status ) deallocate ( offd , offd2 , stat = alloc_status ) if ( allocated ( qq_el_scale )) deallocate ( qq_el_scale ) end subroutine qatom_shutdown !------------------------------------------------------------------------- logical function qatom_old_load_atoms ( fep_file ) !arguments character ( * ), intent ( in ) :: fep_file ! *** local variables integer :: i , j , k , iat !....................................................................... qatom_old_load_atoms = . false . call centered_heading ( 'Reading Q atom list' , '-' ) ! --> fep file (4) open ( unit = 4 , file = fep_file , status = 'old' , form = 'formatted' , & action = 'read' ) ! --- # states, # q-atoms read ( 4 , * ) nstates , nqat write ( * , 20 ) nstates , nqat 20 format ( 'No. of fep/evb states    = ' , i5 , 5 x , & 'No. of fep/evb atoms     = ' , i5 ) !allocate memory for qatom list allocate ( iqseq ( nqat )) read ( 4 , * ) ( iqseq ( i ), i = 1 , nqat ) write ( * , 40 ) ( iqseq ( i ), i = 1 , nqat ) 40 format ( 'Atom nos.:' , 10 i6 ) qatom_old_load_atoms = . true . end function qatom_old_load_atoms !------------------------------------------------------------------------- logical function qatom_load_atoms ( fep_file ) !arguments character ( * ), intent ( in ) :: fep_file ! *** local variables integer :: i , j , k , iat , ires , iatq integer :: s , topno , icase , stat , last , add_res integer :: qflag ( max_states ) integer :: type_count !counts number of parameters logical :: yes character ( len = 4 ) :: offset_name character ( len = 4 ) :: res_name character ( len = 7 ) :: res_str character ( len = 50 ) :: line character ( len = 50 ) :: word character ( len = 4 ), allocatable :: names (:) integer :: offset_residue , max_res , resno integer , allocatable :: residues (:) !....................................................................... use_new_fep_format = . true . qatom_load_atoms = . true . !assume this for a start softcore_use_max_potential = . false . !default call centered_heading ( 'Reading Q atom list' , '-' ) if (. not . prm_open_section ( 'atoms' , fep_file )) then !it's not a new file write ( * , '(a)' ) & '>>> WARNING: No [atoms] section in fep file. Trying old format.' call prm_close use_new_fep_format = . false . qatom_load_atoms = qatom_old_load_atoms ( fep_file ) return end if if (. not . prm_open_section ( 'FEP' )) then nstates = 1 write ( * , 21 , advance = 'no' ) nstates else if (. not . prm_get_integer_by_key ( 'states' , nstates )) then nstates = 1 write ( * , 21 ) nstates else write ( * , 20 ) nstates end if yes = prm_get_logical_by_key ( 'qq_use_library_charges' , qq_use_library_charges , . false .) yes = prm_get_logical_by_key ( 'softcore_use_max_potential' , softcore_use_max_potential , . false .) offset = - 1 !should an offset be applied to topology atom numbers? if ( prm_get_integer_by_key ( 'offset' , offset )) then !got an atom number offset if ( offset < 1 . or . offset > nat_solute ) then !it's invalid write ( * , '(a,i5)' ) '>>>>> ERROR: Invalid topology atom number offset value:' , offset qatom_load_atoms = . false . return end if ligand_offset = offset elseif ( prm_get_string_by_key ( 'offset_name' , offset_name )) then do i = 1 , nres_solute if ( offset_name == res ( i )% name ) then offset = res ( i )% start - 1 exit end if end do if ( offset == - 1 ) then !not found write ( * , '(a,a4,a)' ) '>>>>> ERROR: Residue name ' , offset_name , & 'not found.' qatom_load_atoms = . false . return end if ligand_offset = offset elseif ( prm_get_integer_by_key ( 'offset_residue' , offset_residue )) then if ( offset_residue < 1 . or . offset_residue > nres_solute ) then write ( * , '(a,i5)' ) '>>>>> ERROR: Invalid residue number for offset:' , offset_residue qatom_load_atoms = . false . return end if offset = res ( offset_residue )% start - 1 else offset = 0 end if end if if ( nstates == 0 ) then write ( * , '(/,a)' ) & '>>>>> ERROR: Number of states must be at least 1. Aborting.' qatom_load_atoms = . false . return end if yes = prm_open_section ( 'atoms' ) !by now we know it's there type_count = prm_count ( 'atoms' ) !count number of q-atom lines if ( type_count == 0 ) then write ( * , '(a)' ) & '>>> WARNING: Number of Q-atoms is zero. Fep file will not be loaded.' call prm_close !qatom_load_atoms = .false. !this condition IS OK. return end if if (. not . prm_get_line ( line )) then write ( * , '(a)' ) \">>>>> ERROR: reading line in 'atoms' section\" qatom_load_atoms = . false . return end if icase = 0 read ( line , fmt =* , iostat = stat ) word , i !read integer from value if ( stat == 0 ) then read ( word , fmt =* , iostat = stat ) i !read integer from value if ( stat == 0 ) then icase = 1 !int_int else icase = 2 !string_int end if else icase = 3 !string_string end if select case ( icase ) case ( 1 ) nqat = prm_max_enum ( 'atoms' , type_count ) !count number of q-atoms & get highest q-atom number !allocate memory for qatom list allocate ( iqseq ( nqat )) yes = prm_open_section ( 'atoms' ) !rewind section do i = 1 , type_count if ( prm_get_int_int ( s , topno )) then if ( topno + offset < 1 . or . topno + offset > nat_solute ) then write ( * , '(a,i5,a, i2)' ) '>>>>> ERROR: invalid topology atom number' , & topno + offset , ' for Q-atom' , i qatom_load_atoms = . false . end if iqseq ( s ) = topno + offset else write ( * , '(a,i2)' ) & '>>> WARNING: Failed to read Q-atom ' , i qatom_load_atoms = . false . end if end do !Input is of type 'res xx' case ( 2 ) yes = prm_open_section ( 'atoms' ) !rewind section if ( offset > 0 ) then write ( * , '(a)' ) & '>>> WARNING: Offset can only be used when defining q-atoms with atom nubers. \\n Offset will be set to zero.' offset = 0 end if max_res = prm_max_enum2 ( 'atoms' , type_count ) !count number of residues & get highest residue number if ( max_res > nres_solute ) then write ( * , '(a,i5)' ) '>>>>> ERROR: invalid topology solute residue number' , max_res qatom_load_atoms = . false . return end if allocate ( residues ( type_count )) nqat = 0 !Count number of q-atoms do i = 1 , type_count if ( prm_get_string_int ( res_str , resno )) then call upcase ( res_str ) if ( res_str == 'RES' . or . res_str == 'RESIDUE' ) then residues ( i ) = resno if ( resno < nres_solute ) then nqat = nqat + ( res ( resno + 1 )% start - res ( resno )% start ) else nqat = nqat + (( nat_solute + 1 ) - res ( resno )% start ) end if else write ( * , '(a)' ) \">>>>> ERROR: invalid selection syntax in fep file, section 'atoms'\" qatom_load_atoms = . false . return end if else write ( * , '(a,i2)' ) & '>>> WARNING: Failed to read Q-residue ' , i qatom_load_atoms = . false . end if end do allocate ( iqseq ( nqat )) iatq = 1 !Now assign iqseq with proper topology atom numbers do i = 1 , type_count ires = residues ( i ) if ( ires < nres_solute ) then last = res ( ires + 1 )% start - 1 do iat = res ( ires )% start , last iqseq ( iatq ) = iat iatq = iatq + 1 end do else do iat = res ( ires )% start , nat_solute iqseq ( iatq ) = iat iatq = iatq + 1 end do end if end do offset = 0 ; !offset, offset not compatible with this definition write ( * , 31 ) ( residues ( i ), i = 1 , type_count ) !it is string_string, 'all TYPE' case ( 3 ) yes = prm_open_section ( 'atoms' ) !rewind if ( offset > 0 ) then write ( * , '(a)' ) & '>>> WARNING: Offset can only be used when defining q-atoms with atom nubers. \\n Offset will be set to zero.' offset = 0 end if allocate ( names ( type_count )) do i = 1 , type_count if (. not . prm_get_string_string ( res_str , res_name )) then write ( * , '(a)' ) \">>>>> ERROR: invalid syntax in fep file, section 'atoms'\" qatom_load_atoms = . false . return end if call upcase ( res_str ) if (. not . ( res_str == 'ALL' )) then write ( * , '(a)' , advance = 'no' ) \">>>>> ERROR: invalid syntax in fep file, & &section 'atoms': \" , res_str qatom_load_atoms = . false . return end if call upcase ( res_name ) names ( i ) = res_name end do add_res = 0 allocate ( residues ( nres_solute )) !allocate for worst case do ires = 1 , nres_solute do j = 1 , type_count if ( names ( j ) == res ( ires )% name ) then add_res = add_res + 1 residues ( add_res ) = ires exit end if end do end do if ( add_res == 0 ) then write ( * , '(a)' ) \">>>>> ERROR: No matching residues found in topology. Could not assign qatoms.\" qatom_load_atoms = . false . return end if !Count number of q-atoms do i = 1 , add_res ires = residues ( i ) if ( ires < nres_solute ) then nqat = nqat + ( res ( ires + 1 )% start - res ( ires )% start ) else nqat = nqat + ( nat_solute + 1 - res ( ires )% start ) end if end do allocate ( iqseq ( nqat )) iatq = 1 !Now assign iqseq with proper topology atom numbers do i = 1 , add_res ires = residues ( i ) if ( ires < nres_solute ) then last = res ( ires + 1 )% start - 1 do iat = res ( ires )% start , last iqseq ( iatq ) = iat iatq = iatq + 1 end do else do iat = res ( ires )% start , nat_solute iqseq ( iatq ) = iat iatq = iatq + 1 end do end if end do offset = 0 ; !offset, offset not compatible with this definition write ( * , 31 ) ( residues ( i ), i = 1 , add_res ) case default write ( * , '(a,i2)' ) & \">>> ERROR: Failed to read fep file. Syntax error in 'atoms' section.\" qatom_load_atoms = . false . return end select if ( allocated ( residues )) deallocate ( residues ) if ( allocated ( names )) deallocate ( names ) write ( * , 30 ) nqat write ( * , 40 ) ( iqseq ( i ), i = 1 , nqat ) 20 format ( 'No. of fep/evb states    = ' , i5 ) 21 format ( 'Default fep/evb states   = ' , i5 ) 25 format ( 'Offset for topology atom numbers = ' , i5 ) 30 format ( 'No. of fep/evb atoms     = ' , i5 ) 31 format ( 'Assigning q-atoms from residues: ' , 5 i6 ) 40 format ( 'Atom nos.:' , 10 i6 ) end function qatom_load_atoms !------------------------------------------------------------------------- logical function qatom_old_load_fep () ! *** local variables character :: libtext * 80 , qaname * 2 integer :: i , j , k , iat integer :: nqcrg , nqcod integer :: qflag ( max_states ) !temp. array to read integer flags before switching to logicals integer :: exspectemp ( max_states ) qatom_old_load_fep = . false . call centered_heading ( 'Reading fep/evb strategy' , '-' ) !allocate memory for qatom arrays allocate ( qiac ( nqat , nstates )) allocate ( iqexpnb ( nqat )) allocate ( jqexpnb ( nqat )) !qcrg may be allocated in MD to copy topology charges if (. not . allocated ( qcrg )) allocate ( qcrg ( nqat , nstates )) ! --- Set new charges read ( 4 , * ) nqcrg if ( nqcrg > 0 ) then write ( * , 60 ) nqcrg 60 format ( / , 'No. of changing charges  = ' , i5 ) 80 format ( 'q-atom state_1 state_2 ...' ) do i = 1 , nqcrg read ( 4 , * ) iat ,( qcrg ( iat , j ), j = 1 , nstates ) write ( * , '(i6,8f8.4)' ) iat ,( qcrg ( iat , j ), j = 1 , nstates ) end do end if ! --- Set new vdw params / only if qvdw_flag is true read ( 4 , * ) iat if ( iat > 0 ) qvdw_flag = . true . if ( qvdw_flag ) then write ( * , 100 ) 100 format ( / , 'Q-atom vdW parameters are to be redefined:' ) write ( * , 80 ) do i = 1 , nqat read ( 4 , * ) iat ,( qiac ( iat , j ), j = 1 , nstates ) write ( * , '(i6,8i8)' ) iat ,( qiac ( iat , j ), j = 1 , nstates ) end do ! Read Qatom type library read ( 4 , * ) nqlib write ( * , 120 ) nqlib 120 format ( / , 'No. fep/evb lib entries  = ' , i5 ) read ( 4 , '(a80)' ) libtext write ( * , '(a80)' ) libtext allocate ( qmass ( nqlib ), qavdw ( nqlib , nljtyp ), qbvdw ( nqlib , nljtyp )) do i = 1 , nqlib read ( 4 , * ) j , qaname ,( qavdw ( j , k ), qbvdw ( j , k ), k = 1 , 3 ), qmass ( j ) write ( * , 140 ) j , qaname ,( qavdw ( j , k ), qbvdw ( j , k ), k = 1 , 3 ), qmass ( j ) end do 140 format ( i5 , 3 x , a2 , 1 x , f9 . 2 , 2 f8 . 2 , f6 . 2 , f9 . 2 , 2 f8 . 2 ) ! read ( 4 , * ) nqexpnb write ( * , 144 ) nqexpnb 144 format ( / , 'No. C*exp(-ar) nb pairs  = ' , i5 ) do i = 1 , nqexpnb read ( 4 , * ) iqexpnb ( i ), jqexpnb ( i ) write ( * , 146 ) iqexpnb ( i ), jqexpnb ( i ) end do 146 format ( 'atom_i, atom_j             : ' , 2 i5 ) end if ! --- Set new bonds read ( 4 , * ) nqbond if ( nqbond > 0 ) write ( * , 160 ) nqbond 160 format ( / , 'No. of changing bonds    = ' , i5 ) allocate ( qbnd ( nqbond )) do i = 1 , nqbond read ( 4 , * ) qbnd ( i )% i , qbnd ( i )% j read ( 4 , * ) ( qflag ( j ), j = 1 , nstates ) read ( 4 , * ) ( qbnd ( i )% cod ( j ), j = 1 , nstates ) write ( * , 180 ) qbnd ( i )% i , qbnd ( i )% j write ( * , 200 ) ( qflag ( j ), j = 1 , nstates ) write ( * , 220 ) ( qbnd ( i )% cod ( j ), j = 1 , nstates ) !set bond type = 0 where bond presence flag = 0 do j = 1 , nstates if ( qflag ( j ) == 0 ) qbnd ( i )% cod ( j ) = 0 end do end do 180 format ( / , 'atom_i -- atom_j              : ' , 2 i5 ) 200 format ( 'exists in state_1 state_2 ... : ' , 10 i5 ) 220 format ( 'codes  in state_1 state_2 ... : ' , 10 i5 ) read ( 4 , * ) nqcod allocate ( qbondlib ( nqcod )) qbondlib (:)% fk = 0. !clear Harmonic f.c, not available with old FEP file if ( nqcod . gt . 0 ) then write ( * , * ) write ( * , '(a)' ) 'Morse  E_diss   alpha      b0' do i = 1 , nqcod read ( 4 , * ) qbondlib ( i )% Dmz , qbondlib ( i )% amz , qbondlib ( i )% r0 write ( * , 225 ) i , qbondlib ( i )% Dmz , qbondlib ( i )% amz , qbondlib ( i )% r0 end do 225 format ( i5 , 3 f8 . 2 ) write ( * , * ) end if ! --- Set new angles read ( 4 , * ) nqangle if ( nqangle > 0 ) write ( * , 260 ) nqangle 260 format ( / , 'No. of changing angles   = ' , i5 ) allocate ( qang ( nqangle )) do i = 1 , nqangle read ( 4 , * ) qang ( i )% i , qang ( i )% j , qang ( i )% k read ( 4 , * ) qflag ( 1 : nstates ) read ( 4 , * ) qang ( i )% cod ( 1 : nstates ) write ( * , 280 ) qang ( i )% i , qang ( i )% j , qang ( i )% k write ( * , 200 ) qflag ( 1 : nstates ) write ( * , 220 ) qang ( i )% cod ( 1 : nstates ) !set code to 0 where presence flag = 0 do j = 1 , nstates if ( qflag ( j ) == 0 ) qang ( i )% cod ( j ) = 0 end do end do 280 format ( / , 1 x , 'atom_i -- atom_j -- atom_k    : ' , 3 i5 ) read ( 4 , * ) nqcod allocate ( qanglib ( nqcod )) !set new features to 0. qanglib (:)% ureyfk = 0. qanglib (:)% ureyr0 = 0. if ( nqcod . gt . 0 ) then write ( * , * ) write ( * , '(a)' ) 'Angle force-k  theta0' do i = 1 , nqcod read ( 4 , * ) qanglib ( i )% fk , qanglib ( i )% ang0 write ( * , 225 ) i , qanglib ( i )% fk , qanglib ( i )% ang0 qanglib ( i )% ang0 = deg2rad * qanglib ( i )% ang0 end do write ( * , * ) end if ! --- Set new torsions read ( 4 , * ) nqtor if ( nqtor > 0 ) write ( * , 360 ) nqtor 360 format ( / , 'No. of changing torsions = ' , i5 ) allocate ( iqtor ( nqtor ), & jqtor ( nqtor ), & kqtor ( nqtor ), & lqtor ( nqtor ), & qtorcod ( nqtor , nstates )) do i = 1 , nqtor read ( 4 , * ) iqtor ( i ), jqtor ( i ), kqtor ( i ), lqtor ( i ) read ( 4 , * ) ( qflag ( j ), j = 1 , nstates ) read ( 4 , * ) ( qtorcod ( i , j ), j = 1 , nstates ) write ( * , 380 ) iqtor ( i ), jqtor ( i ), kqtor ( i ), lqtor ( i ) write ( * , 200 ) ( qflag ( j ), j = 1 , nstates ) write ( * , 220 ) ( qtorcod ( i , j ), j = 1 , nstates ) do j = 1 , nstates if ( qflag ( j ) == 0 ) qtorcod ( i , j ) = 0 end do end do 380 format ( / , 'at_i -- at_j -- at_k -- at_l  : ' , 4 i5 ) read ( 4 , * ) nqcod allocate ( qfktor ( nqcod ), & qrmult ( nqcod ), & qdeltor ( nqcod )) if ( nqcod . gt . 0 ) then write ( * , * ) write ( * , '(a)' ) ' Tors force-k    mult   delta' do i = 1 , nqcod read ( 4 , * ) qfktor ( i ), qrmult ( i ), qdeltor ( i ) write ( * , 225 ) i , qfktor ( i ), qrmult ( i ), qdeltor ( i ) qdeltor ( i ) = deg2rad * qdeltor ( i ) end do write ( * , * ) end if ! --- Set new impropers read ( 4 , * ) nqimp if ( nqimp > 0 ) write ( * , 460 ) nqimp 460 format ( / , 'No. of changing impropers= ' , i5 ) allocate ( iqimp ( nqimp ), & jqimp ( nqimp ), & kqimp ( nqimp ), & lqimp ( nqimp ), & qimpcod ( nqimp , nstates )) do i = 1 , nqimp read ( 4 , * ) iqimp ( i ), jqimp ( i ), kqimp ( i ), lqimp ( i ) read ( 4 , * ) ( qflag ( j ), j = 1 , nstates ) read ( 4 , * ) ( qimpcod ( i , j ), j = 1 , nstates ) write ( * , 380 ) iqimp ( i ), jqimp ( i ), kqimp ( i ), lqimp ( i ) write ( * , 200 ) ( qflag ( j ), j = 1 , nstates ) write ( * , 220 ) ( qimpcod ( i , j ), j = 1 , nstates ) !set type = 0 if presence flag = 0 do j = 1 , nstates if ( qflag ( j ) == 0 ) qimpcod ( i , j ) = 0 end do end do read ( 4 , * ) nqcod allocate ( qfkimp ( nqcod ), qimp0 ( nqcod )) if ( nqcod . gt . 0 ) then write ( * , * ) write ( * , '(a)' ) ' Impr force-k    imp0' do i = 1 , nqcod read ( 4 , * ) qfkimp ( i ), qimp0 ( i ) write ( * , 225 ) i , qfkimp ( i ), qimp0 ( i ) qimp0 ( i ) = deg2rad * qimp0 ( i ) end do write ( * , * ) end if ! --- Read angle,torsion and improper couplings to Morse bonds read ( 4 , * ) nang_coupl if ( nang_coupl > 0 ) write ( * , 544 ) nang_coupl 544 format ( / , 'No. of angle-Morse couplings = ' , i5 ) do i = 1 , nang_coupl read ( 4 , * ) ( iang_coupl ( j , i ), j = 1 , 2 ) write ( * , 545 ) ( iang_coupl ( j , i ), j = 1 , 2 ) end do 545 format ( 'angle_i, bond_j              : ' , 2 i5 ) read ( 4 , * ) ntor_coupl if ( ntor_coupl > 0 ) write ( * , 548 ) ntor_coupl 548 format ( 'No. of tors.-Morse couplings = ' , i5 ) do i = 1 , ntor_coupl read ( 4 , * ) ( itor_coupl ( j , i ), j = 1 , 2 ) write ( * , 549 ) ( itor_coupl ( j , i ), j = 1 , 2 ) end do 549 format ( 'torsion_i, bond_j            : ' , 2 i5 ) read ( 4 , * ) nimp_coupl if ( nimp_coupl > 0 ) write ( * , 552 ) nimp_coupl 552 format ( 'No. of impr.-Morse couplings = ' , i5 ) do i = 1 , nimp_coupl read ( 4 , * ) ( iimp_coupl ( j , i ), j = 1 , 2 ) write ( * , 553 ) ( iimp_coupl ( j , i ), j = 1 , 2 ) end do 553 format ( 'improper_i, bond_j           : ' , 2 i5 ) ! --- Read Q-atom shake constraints read ( 4 , * ) nqshake if ( nqshake > 0 ) write ( * , 560 ) nqshake 560 format ( 'No. fep/evb shake contraints = ' , i5 ) do i = 1 , nqshake read ( 4 , * ) iqshake ( i ), jqshake ( i ),( qshake_dist ( i , j ), j = 1 , nstates ) write ( * , 580 ) iqshake ( i ), jqshake ( i ),( qshake_dist ( i , j ), j = 1 , nstates ) end do 580 format ( 'i -- j, dist in state_1, state_2, ... : ' , 2 i5 , 10 f6 . 2 ) ! --- Read off-diagonal hamiltonial matrix functions read ( 4 , * ) noffd if ( noffd > 0 ) write ( * , 600 ) noffd 600 format ( 'No. offdiagonal (Hij) funcs. = ' , i5 ) if ( noffd > max_states ) then write ( * , '(a,i2,a)' ) & '>>> Error: Too many off-diagonal functions, (max_states is ' , & max_states , ' Aborting.' return end if allocate ( offd ( noffd ), offd2 ( noffd )) if ( noffd . gt . 0 ) then write ( * , '(a)' ) 'state_i state_j atom_k atom_l     Aij mu_ij' end if do i = 1 , noffd read ( 4 , * ) offd ( i )% i , offd ( i )% j , offd2 ( i )% k , offd2 ( i )% l , offd2 ( i )% A , & offd2 ( i )% mu write ( * , 620 ) offd ( i )% i , offd ( i )% j , offd2 ( i )% k , offd2 ( i )% l , offd2 ( i )% A , & offd2 ( i )% mu end do 620 format ( i7 , 1 x , 3 i7 , f8 . 2 , f6 . 2 ) ! --- Read special exclusions among quantum atoms read ( unit = 4 , fmt =* , end = 999 , err = 999 ) nexspec if ( nexspec > 0 ) write ( * , 585 ) nexspec allocate ( exspec ( nexspec )) 585 format ( / , 'No. special exclusions       = ' , i5 ) do i = 1 , nexspec read ( 4 , * ) exspec ( i )% i , exspec ( i )% j read ( 4 , * ) exspectemp ( 1 : nstates ) write ( * , 590 ) exspec ( i )% i , exspec ( i )% j write ( * , 200 ) exspectemp ( 1 : nstates ) do j = 1 , nstates if ( exspectemp ( j ) == 0 ) then exspec ( i )% flag ( j ) = . false . else if ( exspectemp ( j ) == 1 ) then exspec ( i )% flag ( j ) = . true . else write ( * , 592 ) return end if end do end do 590 format ( 'i -- j  special exclusion pair  , ... : ' , 2 i5 ) 592 format ( '>>>>> ERROR: Special exclusion state flags are invalid.' ) 999 close ( 4 ) qatom_old_load_fep = . true . !....................................................................... end function qatom_old_load_fep !----------------------------------------------------------------------- logical function qatom_load_fep ( fep_file ) !arguments character ( * ), intent ( in ) :: fep_file ! *** local variables character ( len = 200 ) :: line integer :: i , j , k , l , iat , st , h integer :: nqcrg , nqcod character ( len = 40 ) :: section logical , allocatable , dimension (:) :: type_read integer :: type_count , filestat real ( 8 ) :: el_scale ( max_states ) ! local variable for scaling of different states \"masoud Oct_2013\" integer :: stat !temp. array to read integer flags before switching to logicals integer :: exspectemp ( max_states ) character ( len = keylength ) :: qtac_tmp ( max_states ) !temp array for reading special atom group members integer :: temp_atom ( MAX_ATOMS_IN_SPECIAL_GROUP ) if (. not . use_new_fep_format ) then qatom_load_fep = qatom_old_load_fep () return end if qatom_load_fep = . true . if (. not . prm_open ( fep_file )) then write ( * , '(a,a)' ) '>>>>> ERROR: Could not open fep file ' , trim ( fep_file ) qatom_load_fep = . false . return end if call centered_heading ( 'Reading fep/evb strategy' , '-' ) !When PBC is used, a switching atom for the Q-atoms has to be defined. if ( use_PBC ) then if ( . not . prm_open_section ( 'PBC' ) ) then write ( * , 51 ) qatom_load_fep = . false . return else if ( . not . prm_get_integer_by_key ( 'switching_atom' , qswitch ) ) then write ( * , 50 ) qatom_load_fep = . false . else qswitch = qswitch + offset write ( * , '(a,i6,a)' ) 'Using topology atom number ' , qswitch , ' when creating q-atom based nonbond lists.' end if end if end if 51 format ( '>>>>> ERROR: Section PBC is required when using periodic boundary.' ) 50 format ( '>>>>> ERROR: Switching atom could not be read.' ) !allocate memory for qatom arrays allocate ( qiac ( nqat , nstates )) allocate ( iqexpnb ( nqat )) allocate ( jqexpnb ( nqat )) !qcrg may be allocated in MD to copy topology charges if (. not . allocated ( qcrg )) allocate ( qcrg ( nqat , nstates )) !read flag for use of library charges in qq-nonbond !assume section FEP is open ! --- Set new charges section = 'change_charges' nqcrg = prm_count ( section ) if ( nqcrg > 0 ) then write ( * , 60 ) nqcrg if ( qq_use_library_charges ) then write ( * , '(a)' ) 'Intra-Q-atom electrostatic interactions will not be changed.' end if 60 format ( / , 'No. of changing charges  = ' , i5 ) do i = 1 , nqcrg if (. not . prm_get_line ( line )) goto 1000 !read atom to check read ( line , * , err = 1000 ) iat if ( iat < 1 . or . iat > nqat ) then write ( * , 82 ) iat qatom_load_fep = . false . cycle !dont even try to read charges else if ( iqseq ( iat ) == 0 ) then write ( * , 82 ) iat qatom_load_fep = . false . cycle !dont even try to read charges end if !read atom and all charges read ( line , * , err = 1000 ) iat , qcrg ( iat ,:) end do !list Q-atom charges write ( * , 29 ) write ( * , 30 ) ( 'state' , i , i = 1 , nstates ) do i = 1 , nqat write ( * , 31 ) i , qcrg ( i ,:) end do write ( * , 32 ) sum ( qcrg (:,:), dim = 1 ) end if 29 format ( 'Effective Q-atom charges for all Q-atoms' ) 30 format ( 'Q atom    charge in' , 7 ( 1 x , a5 , i2 )) 31 format ( i6 , t20 , 10 f8 . 3 ) 32 format ( / , '   SUM' , t20 , 10 f8 . 3 ) 82 format ( '>>>>> ERROR: ' , i2 , ' is not a valid q-atom number' ) ! Read Qatom type library only if iqvdw_flag is true section = 'atom_types' nqlib = prm_count ( section ) if ( nqlib > 0 ) then write ( * , 120 ) nqlib if ( ivdw_rule == VDW_GEOMETRIC ) then write ( * , 130 ) else write ( * , 131 ) end if allocate ( qtac ( nqlib )) call index_create ( nqlib ) !set up atom type name lookup table !clear read flag for all parameters 120 format ( / , 'No. of Q-atom types  = ' , i5 ) 130 format ( 'Name            Ai      Bi      Ci     ai Ai(1-4) Bi(1-4)    Mass' ) 131 format ( 'Name            R*i     ei      Ci     ai R*i(1-4)ei(1-4)    Mass' ) allocate ( qmass ( nqlib ), qavdw ( nqlib , nljtyp ), qbvdw ( nqlib , nljtyp )) do i = 1 , nqlib if (. not . prm_get_line ( line )) goto 1000 read ( line , * , err = 1000 ) qtac ( i ),( qavdw ( i , k ), qbvdw ( i , k ), k = 1 , nljtyp ), qmass ( i ) write ( * , 140 ) qtac ( i ),( qavdw ( i , k ), qbvdw ( i , k ), k = 1 , nljtyp ), qmass ( i ) if (. not . index_add ( qtac ( i ), i )) then write ( * , 83 ) qtac ( i ) qatom_load_fep = . false . end if end do 140 format ( a8 , 1 x , f9 . 2 , 2 f8 . 2 , f6 . 2 , f9 . 2 , 2 f8 . 2 ) 83 format ( '>>>>> ERROR: Could not enumerate q-atom type ' , a , ' Duplicate name?' ) end if ! --- Set new vdw params section = 'change_atoms' iat = prm_max_enum ( section , type_count ) if ( iat == 0 ) then qvdw_flag = . false . else if ( iat /= nqat . or . type_count /= nqat ) then write ( * , '(a)' ) '>>>>> ERROR: Atom types of Q-atoms must be given for every Q-atom!' qatom_load_fep = . false . return else qvdw_flag = . true . write ( * , 100 ) 100 format ( / , 'Assigning Q-atom types to all Q atoms:' ) 80 format ( 'Q atom    atom type in' , 6 ( 2 x , a5 , i2 )) write ( * , 80 ) ( 'state' , i , i = 1 , nstates ) do i = 1 , nqat !we know nqat = number of type_count !reading should not fail at this stage - get_line was called by prm_count! if (. not . prm_get_line ( line )) goto 1000 read ( line , * , err = 1000 ) iat , qtac_tmp ( 1 : nstates ) write ( * , '(i6,t25,6(a8,1x))' ) iat , qtac_tmp ( 1 : nstates ) do j = 1 , nstates !check that atom type is defined and assign qiac(iat,j) if (. not . index_get ( qtac_tmp ( j ), qiac ( iat , j ))) then write ( * , 113 ) qtac_tmp ( j ) qatom_load_fep = . false . end if end do !checking end do end if !if redefine atom types 112 format ( '>>>>> ERROR: ' , a , ' type ' , i2 , ' has not been defined.' ) 113 format ( '>>>>> ERROR: Q-atom type ' , a , ' has not been defined.' ) ! --- Soft repulsion pairs section = 'soft_pairs' nqexpnb = prm_count ( section ) if ( nqexpnb > 0 ) then write ( * , 144 ) nqexpnb write ( * , 145 ) do i = 1 , nqexpnb if (. not . prm_get_line ( line )) goto 1000 read ( line , * , err = 1000 ) j , k if ( j < 1 . or . j > nqat . or . k < 1 . or . k > nqat ) then write ( * , 148 ) j , k qatom_load_fep = . false . cycle !dont even try to read charges else if ( iqseq ( j ) == 0 . or . iqseq ( k ) == 0 ) then write ( * , 148 ) j , k qatom_load_fep = . false . cycle !dont even try to read end if iqexpnb ( i ) = j jqexpnb ( i ) = k write ( * , 146 ) iqexpnb ( i ), jqexpnb ( i ) end do end if 144 format ( / , 'No. of soft repulsion non-bonded pairs = ' , i5 ) 145 format ( 'q-atom_i q-atom_j' ) 146 format ( i8 , 1 x , i8 ) 148 format ( '>>>>> ERROR: Invalid q-atom number in this group: ' , 4 i5 ) ! --- Read scaling factors for electrostatic interactions between qq-atoms section = 'el_scale' nel_scale = prm_count ( section ) if ( nel_scale > 0 ) then allocate ( qq_el_scale ( nel_scale )) write ( * , 154 ) nel_scale write ( * , 155 ) ( 'state' , i , i = 1 , nstates ) !header fir qq_el_scale at different states \"masoud Oct_2013\" do i = 1 , nel_scale if (. not . prm_get_line ( line )) goto 1000 read ( line , * , err = 1000 ) j , k , el_scale ( 1 : nstates ) if ( j < 1 . or . j > nqat . or . k < 1 . or . k > nqat ) then !Check if qatoms... write ( * , 148 ) j , k qatom_load_fep = . false . cycle else if ( iqseq ( j ) == 0 . or . iqseq ( k ) == 0 ) then write ( * , 148 ) j , k qatom_load_fep = . false . cycle end if qq_el_scale ( i )% iqat = j qq_el_scale ( i )% jqat = k qq_el_scale ( i )% el_scale ( 1 : nstates ) = el_scale ( 1 : nstates ) ! assign scale factor to qq_el_scale variable \"masoud Oct_2013\" write ( * , 156 ) qq_el_scale ( i )% iqat , qq_el_scale ( i )% jqat , qq_el_scale ( i )% el_scale ( 1 : nstates ) end do end if 154 format ( / , 'No. of el. scaling factors between q-q-atoms = ' , i5 ) 155 format ( 'q-atom_i q-atom_j el_scale' , 7 ( 1 x , a5 , i2 )) 156 format ( i8 , 1 x , i8 , 7 x , 7 ( f8 . 2 )) ! print out up to 7 states \"masoud Oct_2013\" ! --- Read special exclusions among quantum atoms section = 'excluded_pairs' nexspec = prm_count ( section ) if ( nexspec > 0 ) then write ( * , 585 ) nexspec write ( * , 586 ) ( 'state' , i , i = 1 , nstates ) allocate ( exspec ( nexspec )) 585 format ( / , 'No. of excluded non-bonded pairs = ' , i5 ) do i = 1 , nexspec if (. not . prm_get_line ( line )) goto 1000 read ( line , * , err = 1000 ) exspec ( i )% i , exspec ( i )% j , exspectemp ( 1 : nstates ) exspec ( i )% i = exspec ( i )% i + offset exspec ( i )% j = exspec ( i )% j + offset write ( * , 587 ) exspec ( i )% i , exspec ( i )% j , exspectemp ( 1 : nstates ) do j = 1 , nstates if ( exspectemp ( j ) == 0 ) then exspec ( i )% flag ( j ) = . false . elseif ( exspectemp ( j ) == 1 ) then exspec ( i )% flag ( j ) = . true . else write ( * , 592 ) qatom_load_fep = . false . end if end do end do 586 format ( 'atom_i atom_j    excluded in' , 7 ( 1 x , a5 , i2 )) 587 format ( i6 , 1 x , i6 , t29 , 7 i8 ) 592 format ( '>>>>> ERROR: Special exclusion state flags are invalid.' ) end if ! --- Set new bonds section = 'bond_types' nqcod = prm_max_enum ( section , type_count ) if ( nqcod > 0 ) then allocate ( type_read ( nqcod )) type_read (:) = . false . allocate ( qbondlib ( nqcod )) write ( * , 150 ) write ( * , '(a)' ) 'type #  Morse E_diss    alpha       b0  Harmonic force_k ' do i = 1 , type_count if (. not . prm_get_line ( line )) goto 1000 read ( line , * , iostat = filestat ) j , qbondlib ( j )% Dmz , qbondlib ( j )% amz , & qbondlib ( j )% r0 if ( filestat /= 0 ) then !could not read Morse - try harmonic read ( line , * , iostat = filestat ) j , qbondlib ( j )% fk , qbondlib ( j )% r0 if ( filestat /= 0 ) then goto 1000 else !Harmonic OK - clear Morse qbondlib ( j )% Dmz = 0 qbondlib ( j )% amz = 0 type_read ( j ) = . true . write ( * , 226 ) j , qbondlib ( j )% r0 , qbondlib ( j )% fk end if else !Morse OK - clear harmonic qbondlib ( j )% fk = 0 type_read ( j ) = . true . write ( * , 225 ) j , qbondlib ( j )% Dmz , qbondlib ( j )% amz , qbondlib ( j )% r0 end if end do 150 format ( / , 'Q-bond types:' ) 225 format ( i6 , 6 x , f8 . 2 , 1 x , f8 . 2 , 1 x , f8 . 2 ) 226 format ( i6 , 24 x , f8 . 2 , 10 x , f8 . 2 ) write ( * , * ) end if section = 'change_bonds' nqbond = prm_count ( section ) if ( nqbond > 0 ) then write ( * , 160 ) nqbond write ( * , 161 ) ( 'state' , i , i = 1 , nstates ) allocate ( qbnd ( nqbond )) do i = 1 , nqbond if (. not . prm_get_line ( line )) goto 1000 read ( line , * , err = 1000 ) qbnd ( i )% i , qbnd ( i )% j , qbnd ( i )% cod ( 1 : nstates ) qbnd ( i )% i = qbnd ( i )% i + offset qbnd ( i )% j = qbnd ( i )% j + offset write ( * , 162 ) qbnd ( i )% i , qbnd ( i )% j , qbnd ( i )% cod ( 1 : nstates ) !check types do j = 1 , nstates if ( qbnd ( i )% cod ( j ) > 0 ) then if ( allocated ( type_read )) then if (. not . type_read ( qbnd ( i )% cod ( j ))) then write ( * , 112 ) 'Q-bond' , qbnd ( i )% cod ( j ) qatom_load_fep = . false . end if else write ( * , 112 ) 'Q-bond' , qbnd ( i )% cod ( j ) qatom_load_fep = . false . end if end if end do end do 160 format ( / , 'No. of changing bonds    = ' , i5 ) 161 format ( 'atom_i atom_j   bond type in' , 6 ( 1 x , a5 , i2 )) 162 format ( i6 , 1 x , i6 , t29 , 6 i8 ) end if if ( allocated ( type_read )) then deallocate ( type_read ) end if ! --- Set new angles section = 'angle_types' nqcod = prm_max_enum ( section , type_count ) if ( nqcod . gt . 0 ) then allocate ( type_read ( nqcod )) type_read (:) = . false . allocate ( qanglib ( nqcod )) !set optional params to 0 qanglib (:)% ureyfk = 0. qanglib (:)% ureyr0 = 0. write ( * , '(/,a)' ) 'Q-angle types:' write ( * , '(a)' , advance = 'no' ) 'type #       force-k   theta0' do i = 1 , type_count if (. not . prm_get_line ( line )) goto 1000 read ( line , * , iostat = filestat ) j , qanglib ( j ) if ( filestat == 0 ) then if ( i == 1 ) write ( * , '(a)' ) '  Urey-Bradley force-k      r0' type_read ( j ) = . true . write ( * , 230 ) j , qanglib ( j ) elseif ( filestat < 0 ) then if ( i == 1 ) write ( * , * ) type_read ( j ) = . true . write ( * , 225 ) j , qanglib ( j )% fk , qanglib ( j )% ang0 else goto 1000 end if qanglib ( j )% ang0 = deg2rad * qanglib ( j )% ang0 end do write ( * , * ) end if 230 format ( i6 , 2 f8 . 2 , 14 x , 2 f8 . 2 ) section = 'change_angles' nqangle = prm_count ( section ) if ( nqangle > 0 ) then write ( * , 260 ) nqangle 260 format ( / , 'No. of changing angles   = ' , i5 ) write ( * , 261 ) ( 'state' , i , i = 1 , nstates ) allocate ( qang ( nqangle )) do i = 1 , nqangle if (. not . prm_get_line ( line )) goto 1000 read ( line , * , err = 1000 ) qang ( i )% i , qang ( i )% j , qang ( i )% k , qang ( i )% cod ( 1 : nstates ) qang ( i )% i = qang ( i )% i + offset qang ( i )% j = qang ( i )% j + offset qang ( i )% k = qang ( i )% k + offset write ( * , 262 ) qang ( i )% i , qang ( i )% j , qang ( i )% k , qang ( i )% cod ( 1 : nstates ) !check types do j = 1 , nstates if ( qang ( i )% cod ( j ) > 0 ) then if ( allocated ( type_read )) then if (. not . type_read ( qang ( i )% cod ( j ))) then write ( * , 112 ) 'Q-angle' , qang ( i )% cod ( j ) qatom_load_fep = . false . end if else write ( * , 112 ) 'Q-angle' , qang ( i )% cod ( j ) qatom_load_fep = . false . end if end if end do !j end do !i 261 format ( 'atom_i atom_j atom_k    angle type in' , 5 ( 1 x , a5 , i2 )) 262 format ( i6 , 1 x , i6 , 1 x , i6 , t38 , 5 i8 ) end if if ( allocated ( type_read )) then deallocate ( type_read ) end if ! --- Set new torsions section = 'torsion_types' nqcod = prm_max_enum ( section , type_count ) allocate ( qfktor ( nqcod ), qrmult ( nqcod ), qdeltor ( nqcod )) if ( nqcod . gt . 0 ) then allocate ( type_read ( nqcod )) type_read (:) = . false . write ( * , 350 ) do i = 1 , type_count if (. not . prm_get_line ( line )) goto 1000 read ( line , * , err = 1000 ) j , qfktor ( j ), qrmult ( j ), qdeltor ( j ) type_read ( j ) = . true . write ( * , 225 ) j , qfktor ( j ), qrmult ( j ), qdeltor ( j ) qdeltor ( j ) = deg2rad * qdeltor ( j ) end do write ( * , * ) end if 350 format ( / , 'Q-torsion types:' , / , 'type #       force-k     mult    delta' ) section = 'change_torsions' nqtor = prm_count ( section ) if ( nqtor > 0 ) then write ( * , 360 ) nqtor write ( * , 361 ) ( 'state' , i , i = 1 , nstates ) 360 format ( / , 'No. of changing torsions = ' , i5 ) allocate ( iqtor ( nqtor ), & jqtor ( nqtor ), & kqtor ( nqtor ), & lqtor ( nqtor ), & qtorcod ( nqtor , nstates )) do i = 1 , nqtor if (. not . prm_get_line ( line )) goto 1000 read ( line , * , err = 1000 ) iqtor ( i ), jqtor ( i ), kqtor ( i ), lqtor ( i ), qtorcod ( i ,:) iqtor ( i ) = iqtor ( i ) + offset jqtor ( i ) = jqtor ( i ) + offset kqtor ( i ) = kqtor ( i ) + offset lqtor ( i ) = lqtor ( i ) + offset write ( * , 362 ) iqtor ( i ), jqtor ( i ), kqtor ( i ), lqtor ( i ), qtorcod ( i ,:) !check types do j = 1 , nstates if ( qtorcod ( i , j ) > 0 ) then if ( allocated ( type_read )) then if (. not . type_read ( qtorcod ( i , j ))) then write ( * , 112 ) 'Q-torsion' , qtorcod ( i , j ) qatom_load_fep = . false . end if else write ( * , 112 ) 'Q-torsion' , qtorcod ( i , j ) qatom_load_fep = . false . end if end if end do !j end do !i 361 format ( 'atom_i atom_j atom_k atom_l    torsion type in' , 4 ( 1 x , a5 , i2 )) 362 format ( 4 ( i6 , 1 x ), t47 , 4 i8 ) end if if ( allocated ( type_read )) then deallocate ( type_read ) end if ! --- Set new impropers section = 'improper_types' nqcod = prm_max_enum ( section , type_count ) if ( nqcod > 0 ) then allocate ( type_read ( nqcod )) type_read (:) = . false . allocate ( qfkimp ( nqcod ), qimp0 ( nqcod )) write ( * , 450 ) 450 format ( / , 'Q-improper types:' , / , 'type #       force-k     imp0' ) do i = 1 , type_count if (. not . prm_get_line ( line )) goto 1000 read ( line , * , err = 1000 ) j , qfkimp ( j ), qimp0 ( j ) type_read ( j ) = . true . write ( * , 225 ) j , qfkimp ( j ), qimp0 ( j ) qimp0 ( j ) = deg2rad * qimp0 ( j ) end do write ( * , * ) end if section = 'change_impropers' nqimp = prm_count ( section ) if ( nqimp > 0 ) then write ( * , 460 ) nqimp 460 format ( / , 'No. of changing impropers= ' , i5 ) write ( * , 461 ) ( 'state' , i , i = 1 , nstates ) allocate ( iqimp ( nqimp ), & jqimp ( nqimp ), & kqimp ( nqimp ), & lqimp ( nqimp ), & qimpcod ( nqimp , nstates )) do i = 1 , nqimp if (. not . prm_get_line ( line )) goto 1000 read ( line , * , err = 1000 ) iqimp ( i ), jqimp ( i ), kqimp ( i ), lqimp ( i ), qimpcod ( i ,:) iqimp ( i ) = iqimp ( i ) + offset jqimp ( i ) = jqimp ( i ) + offset kqimp ( i ) = kqimp ( i ) + offset lqimp ( i ) = lqimp ( i ) + offset write ( * , 462 ) iqimp ( i ), jqimp ( i ), kqimp ( i ), lqimp ( i ), qimpcod ( i , 1 : nstates ) !check types do j = 1 , nstates if ( qimpcod ( i , j ) > 0 ) then if ( allocated ( type_read )) then if (. not . type_read ( qimpcod ( i , j ))) then write ( * , 112 ) 'Q-impsion' , qimpcod ( i , j ) qatom_load_fep = . false . end if else write ( * , 112 ) 'Q-impsion' , qimpcod ( i , j ) qatom_load_fep = . false . end if end if end do !j end do !i end if 461 format ( 'atom_i atom_j atom_k atom_l    improper type in' , 4 ( 1 x , a5 , i2 )) 462 format ( 4 ( i6 , 1 x ), t48 , 4 i8 ) if ( allocated ( type_read )) then deallocate ( type_read ) end if ! --- Read angle,torsion and improper couplings to Morse bonds section = 'angle_couplings' nang_coupl = prm_count ( section ) if ( nang_coupl > 0 ) then write ( * , 544 ) nang_coupl 544 format ( / , 'No. of angle-Morse couplings = ' , i5 ) write ( * , 543 ) do i = 1 , nang_coupl if (. not . prm_get_int_int ( j , k )) goto 1000 iang_coupl ( 1 , i ) = j iang_coupl ( 2 , i ) = k write ( * , 545 ) iang_coupl (:, i ) if ( j < 1 . or . j > nqangle ) then write ( * , 546 ) 'q-angle' , j qatom_load_fep = . false . end if if ( k < 1 . or . k > nqbond ) then write ( * , 546 ) 'q-bond' , j qatom_load_fep = . false . end if if ( bond_harmonic_in_any_state ( k )) then qatom_load_fep = . false . end if end do end if 543 format ( 'angle_i bond_j' ) 545 format ( i7 , 1 x , i6 ) 546 format ( '>>>>> ERROR: ' , a , ' number ' , i2 , ' does not exist.' ) section = 'torsion_couplings' ntor_coupl = prm_count ( section ) if ( ntor_coupl > 0 ) then write ( * , 548 ) ntor_coupl 548 format ( / , 'No. of torsion-Morse couplings = ' , i5 ) write ( * , 547 ) do i = 1 , ntor_coupl if (. not . prm_get_int_int ( j , k )) goto 1000 itor_coupl ( 1 , i ) = j itor_coupl ( 2 , i ) = k write ( * , 549 ) itor_coupl (:, i ) if ( itor_coupl ( 1 , i ) < 1 . or . itor_coupl ( 1 , i ) > nqtor ) then write ( * , 546 ) 'q-torsion' , itor_coupl ( 1 , i ) qatom_load_fep = . false . end if if ( itor_coupl ( 2 , i ) < 1 . or . itor_coupl ( 2 , i ) > nqbond ) then write ( * , 546 ) 'q-bond' , itor_coupl ( 2 , i ) qatom_load_fep = . false . end if if ( bond_harmonic_in_any_state ( k )) then qatom_load_fep = . false . end if end do 547 format ( 'torsion_i bond_j' ) 549 format ( i9 , 1 x , i6 ) end if section = 'improper_couplings' nimp_coupl = prm_count ( section ) if ( nimp_coupl > 0 ) then write ( * , 552 ) nimp_coupl 552 format ( / , 'No. of improper-Morse couplings = ' , i5 ) write ( * , 554 ) do i = 1 , nimp_coupl if (. not . prm_get_line ( line )) goto 1000 read ( line , * , iostat = stat ) j , k , l if ( stat . eq . 0 ) then iimp_coupl ( 1 , i ) = j iimp_coupl ( 2 , i ) = k iimp_coupl ( 3 , i ) = l else read ( line , * , err = 1000 ) j , k iimp_coupl ( 1 , i ) = j iimp_coupl ( 2 , i ) = k iimp_coupl ( 3 , i ) = 0 end if write ( * , 553 ) iimp_coupl (:, i ) if ( j < 1 . or . j > nqimp ) then write ( * , 546 ) 'q-improper' , j qatom_load_fep = . false . end if if ( k < 1 . or . k > nqbond ) then write ( * , 546 ) 'q-bond' , j qatom_load_fep = . false . end if if ( bond_harmonic_in_any_state ( k )) then qatom_load_fep = . false . end if end do end if 554 format ( 'improper_i bond_j making/breaking' ) 553 format ( i10 , 1 x , i6 , 1 x , i15 ) ! --- Read extra shake constraints section = 'shake_constraints' nqshake = prm_count ( section ) if ( nqshake > 0 ) then write ( * , 560 ) nqshake , ( 'state' , i , i = 1 , nstates ) 560 format ( / , 'No. of fep/evb shake contraints = ' , i5 , / & 'atom_i atom_j    distance in' , 5 ( 1 x , a5 , i2 )) do i = 1 , nqshake if (. not . prm_get_line ( line )) goto 1000 read ( line , * , err = 1000 ) iqshake ( i ), jqshake ( i ), qshake_dist ( i , 1 : nstates ) iqshake ( i ) = iqshake ( i ) + offset jqshake ( i ) = jqshake ( i ) + offset write ( * , 580 ) iqshake ( i ), jqshake ( i ), qshake_dist ( i , 1 : nstates ) end do 580 format ( i6 , 1 x , i6 , t29 , 5 f8 . 2 ) end if ! --- Read off-diagonal hamiltonial matrix functions section = 'off_diagonals' noffd = prm_count ( section ) !always allocate (needed for energy file writing) allocate ( offd ( noffd ), offd2 ( noffd )) if ( noffd > 0 ) then write ( * , 600 ) noffd 600 format ( / , 'No. of offdiagonal (Hij) functions = ' , i5 ) if ( noffd > max_states ) then write ( * , '(a,i2,a)' ) & '>>> Error: Too many off-diagonal functions, (max_states is ' , & max_states , ' Aborting.' qatom_load_fep = . false . call prm_close return end if write ( * , '(a)' ) 'state_i state_j atom_k atom_l     Aij mu_ij' do i = 1 , noffd if (. not . prm_get_line ( line )) goto 1000 read ( line , * , err = 1000 ) offd ( i )% i , offd ( i )% j , offd2 ( i )% k , & offd2 ( i )% l , offd2 ( i )% A , offd2 ( i )% mu write ( * , 620 ) offd ( i )% i , offd ( i )% j , offd2 ( i )% k ,& offd2 ( i )% l , offd2 ( i )% A , offd2 ( i )% mu !check states if ( offd ( i )% i < 1 . or . offd ( i )% i > nstates . or . & offd ( i )% j < 1 . or . offd ( i )% j > nstates . or . & offd ( i )% i == offd ( i )% j ) then write ( * , 622 ) qatom_load_fep = . false . end if !check q-atom numbers if ( offd2 ( i )% k < 1 . or . offd2 ( i )% k > nqat . or . & offd2 ( i )% l < 1 . or . offd2 ( i )% l > nqat ) then write ( * , 148 ) offd2 ( i )% k , offd2 ( i )% l qatom_load_fep = . false . else if ( iqseq ( offd2 ( i )% k ) == 0 . or . iqseq ( offd2 ( i )% l ) == 0 ) then write ( * , 148 ) offd2 ( i )% k , offd2 ( i )% l qatom_load_fep = . false . end if end do end if 620 format ( i7 , 1 x , 3 i7 , f8 . 2 , f6 . 2 ) 622 format ( '>>>>> ERROR: Invalid combination of states: ' , 2 i5 ) !************Softcore section************  MPA if ( allocated ( sc_lookup )) deallocate ( sc_lookup ) allocate ( alpha_max ( nqat , nstates ), sc_lookup ( nqat , natyps + nqat , nstates )) !default is no softcore, i.e. alpha=zero (sc_lookup = 0) sc_lookup (:,:,:) = 0.0 section = 'softcore' if (. not . prm_open_section ( section )) then write ( * , 1630 ) else write ( * , '(a)' ) 'Reading softcore section' if (. not . qvdw_flag ) then write ( * , '(a)' ) '>>>>> ERROR: Q-atom types must be redefined in \"change_atoms\" section' qatom_load_fep = . false . return end if numsoftlines = prm_count ( section ) if ( numsoftlines /= nqat ) then write ( * , '(a)' ) '>>>>> ERROR: Alpha must be given for every Q-atom!' qatom_load_fep = . false . return else write ( * , 1625 ) 1625 format ( / , 'Assigning softcore to all Q atoms:' ) 1626 format ( 'Q atom    softcore alpha in' , 6 ( 2 x , a5 , i2 )) 1627 format ( 'Q atom      max potenial in' , 6 ( 2 x , a5 , i2 )) if ( softcore_use_max_potential ) then write ( * , '(a)' ) ( 'Using values in FEP file as desired maximum vdW potentials at r=0' ) write ( * , 1627 ) ( 'state' , i , i = 1 , nstates ) else write ( * , '(a)' ) ( 'Using values in FEP file as explicit alphas' ) write ( * , 1626 ) ( 'state' , i , i = 1 , nstates ) end if do i = 1 , nqat !read all the softcore max_alphas !reading should not fail at this stage - get_line was called by prm_count! if (. not . prm_get_line ( line )) goto 1000 read ( line , * , err = 1000 ) tmpindex , alpha_max ( tmpindex , 1 : nstates ) write ( * , '(i6,t25,6(f8.2,1x))' ) tmpindex , alpha_max ( tmpindex , 1 : nstates ) end do do i = 1 , nqat !make the sc_lookup table do i2 = 1 , nstates do j = 1 , natyps !do q-surroundings first if ( softcore_use_max_potential ) then sc_aq = qavdw ( qiac ( i , i2 ), 1 ) sc_bq = qbvdw ( qiac ( i , i2 ), 1 ) sc_aj = iaclib ( j )% avdw ( 1 ) sc_bj = iaclib ( j )% bvdw ( 1 ) if ( alpha_max ( i , i2 ) /= 0 ) then if ( ivdw_rule == 1 ) then !geometric vdw rule sc_lookup ( i , j , i2 ) = ( - sc_bq * sc_bj + sqrt ( sc_bq * sc_bq * sc_bj * & sc_bj + 4 * alpha_max ( i , i2 ) * sc_aq * sc_aj )) / ( 2 * alpha_max ( i , i2 )) else !arithmetic vdw rule. OBS some epsilons (q atom epsilons, sc_bq) !       have not been square rooted yet. We'll take this into account !   when calculating the sc_lookup sc_lookup ( i , j , i2 ) = ( - 2 * sqrt ( sc_bq ) * sc_bj + 2 * sqrt ( sc_bq * sc_bj ** 2 + & alpha_max ( i , i2 ) * sqrt ( sc_bq ) * sc_bj )) * ( sc_aq + sc_aj ) ** 6 / ( 2 * alpha_max ( i , i2 )) end if end if else !user has not requested alpha calculation, each q-atom has the same alpha for every atom type sc_lookup ( i , j , i2 ) = alpha_max ( i , i2 ) end if end do do j = 1 , nqat !now do q-q if (( alpha_max ( i , i2 ) . gt . 1 E - 6 ) . or . ( alpha_max ( j , i2 ) . gt . 1 E - 6 )) then !if both alphas are 0 then no need to calculate alphas sc_aq = qavdw ( qiac ( i , i2 ), 1 ) sc_bq = qbvdw ( qiac ( i , i2 ), 1 ) sc_aj = qavdw ( qiac ( j , i2 ), 1 ) sc_bj = qbvdw ( qiac ( j , i2 ), 1 ) if ( softcore_use_max_potential ) then !use the smallest alpha_max of the two q atoms alpha_max_tmp = min ( alpha_max ( i , i2 ), alpha_max ( j , i2 ) ) if (( alpha_max ( i , i2 ) == 0 ) . or . ( alpha_max ( j , i2 ) == 0 )) then !unless one of them is zero alpha_max_tmp = max ( alpha_max ( i , i2 ), alpha_max ( j , i2 ) ) end if else !use the largest alpha_max if we're using plain alphas alpha_max_tmp = max ( alpha_max ( i , i2 ), alpha_max ( j , i2 ) ) end if if ( softcore_use_max_potential ) then if ( ivdw_rule == 1 ) then !geometric vdw rule sc_lookup ( i , j + natyps , i2 ) = ( - sc_bq * sc_bj + & sqrt ( sc_bq * sc_bq * sc_bj * sc_bj + & 4 * alpha_max_tmp * sc_aq * sc_aj )) / ( 2 * alpha_max_tmp ) else !arithmetic vdw rule   OBS some epsilons (q atom epsilons, sc_bq and sc_bj) !       have not been square-rooted yet. We'll take this into account !   when calculating the sc_lookup sc_lookup ( i , j + natyps , i2 ) = ( - 2 * sqrt ( sc_bq * sc_bj ) + & 2 * sqrt ( sc_bq * sc_bj + alpha_max_tmp * sqrt ( sc_bq * sc_bj ))) * & ( sc_aq + sc_aj ) ** 6 / ( 2 * alpha_max_tmp ) end if else !user has not requested alpha calculation, each q-atom has the same alpha for every atom type sc_lookup ( i , j + natyps , i2 ) = alpha_max_tmp end if !softcore_use_max_potential end if end do end do ! states end do !softcore lookup table end if end if !prm_open_section(section)   softcore 1630 format ( 'No softcore section found. Using normal LJ potentials.' ) 1631 format ( '>>>>> Erroneous softcore section.' ) !********END*****Softcore section****END********  MPA !load atom groups whose non-bonded interactions are to be monitored section = 'monitor_groups' monitor_groups = prm_count ( section ) allocate ( monitor_atom_group ( monitor_groups )) if ( monitor_groups > 0 ) then write ( * , 650 ) monitor_groups do i = 1 , monitor_groups k = 0 do while ( prm_get_field ( line )) !get one topology atom number at a time k = k + 1 read ( line , * ) temp_atom ( k ) !read line med fritt format end do allocate ( monitor_atom_group ( i )% atom ( k )) !k �r antal element i array nr i monitor_atom_group ( i )% atom (:) = temp_atom ( 1 : k ) + offset ! kopiera temp_atom arrayens element med index 1-k till monitor_atom_group ( i )% n = k write ( * , 660 , advance = 'no' ) i write ( * , 670 ) monitor_atom_group ( i )% atom (:) end do end if 650 format ( / , 'No. atom groups to monitor   = ' , i5 ) 660 format ( 'group' , i2 , ':' ) 670 format ( 7 i8 ) section = 'monitor_group_pairs' monitor_group_pairs = prm_count ( section ) !antal rader i avd. allocate ( monitor_group_pair ( monitor_group_pairs )) if ( monitor_group_pairs > 0 ) then write ( * , * ) write ( * , 630 ) monitor_group_pairs write ( * , '(a)' ) 'group_i group_j' do i = 1 , monitor_group_pairs if (. not . prm_get_int_int ( monitor_group_pair ( i )% i , monitor_group_pair ( i )% j )) goto 1000 !l�ser in i arrayen monitor_group_pair write ( * , 640 ) monitor_group_pair ( i )% i , monitor_group_pair ( i )% j end do end if 630 format ( / , 'No. of group pairs to monitor= ' , i5 ) 640 format ( i7 , 1 x , i7 ) call prm_close return !error handling code 1000 write ( * , 1900 ) i , section call prm_close qatom_load_fep = . false . 1900 format ( '>>>>> ERROR: Read error at line ' , i2 , ' of section [' , a , ']' ) !....................................................................... end function qatom_load_fep !------------------------------------------------------------------------- logical function bond_harmonic_in_any_state ( k ) integer , intent ( in ) :: k integer :: st bond_harmonic_in_any_state = . false . do st = 1 , nstates if ( qbnd ( k )% cod ( st ) /= 0 ) then if ( qbondlib ( qbnd ( k )% cod ( st ))% fk /= 0. ) then !the bond types is harmonic write ( * , 547 ) k , st bond_harmonic_in_any_state = . true . end if end if end do 547 format ( '>>>>> ERROR: Bond' , i3 , ' is harmonic in state' , i2 ) end function bond_harmonic_in_any_state end module qatom","tags":"","loc":"sourcefile/qatom.f90.html","title":"qatom.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  qcalc.f90 !  by John Marelius !  qcalc trajectory analysis main program !------------------------------------------------------------------------------! program qcalc use version use trj use calc_base use calc_rms use calc_fit use calc_geom use calc_entropy use calc_nb use calc_chemscore use calc_xscore use calc_pmf use calc_rdf use calc_rmsf use calc_com_ke use calc_com !add more calculation kind modules here... implicit none ! version data character ( * ), parameter :: PROGRAM_VERSION = '5.7' character ( * ), parameter :: PROGRAM_DATE = '2015-02-22' !constants integer , parameter :: MAX_CALCS = 99 integer , parameter :: MAX_CALC_KINDS = 99 !data types type calc_type character ( len = 60 ) :: desc integer :: i integer :: typ end type calc_type type calc_kind_type character ( len = 40 ) :: desc character ( len = 14 ) :: key logical :: output end type calc_kind_type integer :: nkinds = 0 , ncalcs = 0 type ( calc_kind_type ) :: cdef ( max_calc_kinds ) type ( calc_type ) :: calcs ( max_calcs ) !register the calculation kinds call add_kind ( desc = 'RMS coord. deviation' , key = 'rmsd' , output = . true .) call add_kind ( desc = 'Least squares fit' , key = 'fit' , output = . false .) call add_kind ( desc = 'Distance, bond energy' , key = 'dist' , output = . true .) call add_kind ( desc = 'Angle, angle energy' , key = 'angle' , output = . true .) call add_kind ( desc = 'Torsion, torsion energy' , key = 'torsion' , output = . true .) call add_kind ( desc = 'Entropy [Schlitters formula]' , key = 'entropy' , output = . true .) call add_kind ( desc = 'Nonbonded monitor' , key = 'nonbond' , output = . true .) call add_kind ( desc = 'Residue nonbond monitor' , key = 'nb_prot_qatom' , output = . true .) call add_kind ( desc = 'ChemScore' , key = 'chemscore' , output = . true .) call add_kind ( desc = 'X-Score' , key = 'xscore' , output = . true .) call add_kind ( desc = 'PMF-Score' , key = 'pmfscore' , output = . true .) call add_kind ( desc = 'RDF' , key = 'rdf' , output = . true .) call add_kind ( desc = 'RMSF' , key = 'rmsf' , output = . true .) call add_kind ( desc = 'Center of mass Kinetic Energy' , key = 'com_ke' , output = . true .) call add_kind ( desc = 'Center of mass position' , key = 'com' , output = . true .) !add more calc. kind registrations here... ! startup prints welcome msg and calls calc_help to print ! helper info. mask_startup and topo_startup are dummy routines call startup if ( get_topology ()) then ! attempt to load topology (req. user input) ! reads bnd(:) among other things call initialize ! initialize modules, mostly allocating arrays and def.ing constants call add_calcs ! display calc menu and add calcs call do_pre_calcs call process_help call print_headings call process_data ! processes data frame by frame call finalize_topology call finalize else write ( * , 900 ) 900 format ( '>>>>> ERROR: Failed to load topology. Exiting' ) end if call shutdown contains subroutine startup integer :: i write ( * , '(79a)' )( '#' , i = 1 , 79 ) write ( * , '(a,a)' ) 'Welcome to qcalc version ' , PROGRAM_VERSION call mask_startup ! mask_startup calls topo_startup, which is empty write ( * , * ) call calc_help ! outputs help to screen end subroutine startup subroutine shutdown end subroutine shutdown logical function get_topology () !locals character ( len = 200 ) :: topfile call getlin ( topfile , '--> Topology file: ' ) write ( * , 100 ) trim ( topfile ) 100 format ( 'Loading topology ' , a ) get_topology = topo_load ( topfile , require_version = 4. ) end function get_topology subroutine initialize allocate ( xin ( 3 * nat_pro )) ! contains all coordinates, 3*no_atoms call rms_initialize call rmsf_initialize call fit_initialize call geom_initialize call entropy_initialize call nb_initialize call score_initialize call xscore_initialize call pmf_initialize call rdf_initialize call com_ke_initialize call com_initialize !add more calls to module initialization routines here end subroutine initialize subroutine do_pre_calcs integer :: c , i do c = 1 , Ncalcs i = calcs ( c )% i select case ( cdef ( calcs ( c )% typ )% key ) case ( 'chemscore' ) call score_precalc case ( 'xscore' ) call xscore_precalc case ( 'pmfscore' ) call pmf_precalc !add more call to calculation pre-routines here... end select end do end subroutine subroutine finalize integer :: c , i deallocate ( xin ) do c = 1 , Ncalcs if ( cdef ( calcs ( c )% typ )% output ) then i = calcs ( c )% i select case ( cdef ( calcs ( c )% typ )% key ) case ( 'rmsd' ) call RMS_finalize ( i ) case ( 'fit' ) call fit_finalize ( i ) case ( 'entropy' ) call entropy_finalize ( i ) case ( 'nonbond' ) call nb_finalize ( i ) case ( 'nb_prot_qatom' ) call nb_qp_finalize () case ( 'dist' , 'angle' , 'torsion' , 'improper' ) !nothing needed case ( 'chemscore' ) call chemscore_finalize case ( 'xscore' ) call xscore_finalize case ( 'pmfscore' ) call pmf_finalize case ( 'rdf' ) call rdf_finalize ( i ) case ( 'rmsf' ) call RMSF_finalize ( i ) case ( 'com_ke' ) call COM_KE_finalize ( i ) case ( 'com' ) call COM_finalize ( i ) !add more call to finalize routines here... end select end if end do call mask_shutdown end subroutine finalize subroutine calc_help WRITE ( * , '(a)' ) & 'qcalc works in three stages:' , & '1. Load topology.' , & '2. Set up a list of calculations to make.' , & '3. Read coordinates from trajectory and/or restart files and calculate.' end subroutine calc_help subroutine process_help call centered_heading ( 'Help for reading coordinate files' , '-' ) WRITE ( * , '(a)' ) & 'Enter names of coordinate files (restart or trajectory) on separate lines' , & 'Terminate with EOF or period (.).' end subroutine process_help subroutine finishtrj_all ! this sub invokes corresponding end-of-trajectory functions in calc. modules ! when end of trj file is reached ! used by score to calculate mean !       call score_calc_mean ! add more calls here end subroutine finishtrj_all subroutine process_data !locals character ( len = 256 ) :: cf !coord file name integer :: fn !LUN for cf real ( 8 ) :: rms integer :: frame , p1 , p2 , frame_start , frame_end , every_n character ( len = 80 ) :: frames do while ( get_coordfile ( cf , fn , frames )) every_n = 0 if ( frames . ne . '' ) then p1 = index ( frames , '=' ) p2 = index ( frames , '-' ) if ( p2 . ne . 0 ) then read ( frames ( p1 + 1 : p2 - 1 ), * ) frame_start read ( frames ( p2 + 1 : len_trim ( frames )), * ) frame_end else frames = frames ( p1 + 1 : 80 ) if ( frames ( 1 : 5 ). eq . 'every' ) then read ( frames ( 6 : 80 ), * ) every_n end if end if end if frame = 0 if ( fn /= 0 ) then ! restart file if ( load_restart ( fn )) then call process_frame ( cf , 0 ) ! was process_frame(cf,1) end if else ! trajectory file do while ( trj_read ( xin )) ! coordinates for frame \"frame\" are now in xin(:) frame = frame + 1 !                               write(*,*) 'frame= ', frame if ( frames . ne . '' ) then if ( every_n . eq . 0 ) then if ( frame >= frame_start . and . frame <= frame_end ) call process_frame ( cf , frame ) else if ( modulo ( frame , every_n ). eq . 0 ) call process_frame ( cf , frame ) end if else call process_frame ( cf , frame ) end if end do call trj_close end if end do end subroutine process_data subroutine process_frame ( cf , frame ) !arguments character ( * ) :: cf integer :: frame character ( len = 32 ) :: filename if ( len_trim ( cf ) . gt . 20 ) then filename ( 1 : 5 ) = cf ( 1 : 5 ) filename ( 6 : 8 ) = '...' filename ( 9 : 20 ) = cf ( len_trim ( cf ) - 11 : len_trim ( cf )) else filename (:) = ' ' filename ( 1 : len_trim ( cf )) = cf ( 1 : len_trim ( cf )) end if write ( * , 100 , advance = 'no' ) filename , frame 100 format ( a21 , i4 ) call calc_all ( frame ) write ( * , * ) !new line end subroutine process_frame subroutine make_mean_all ! calls mean routines in other modules integer :: c do c = 1 , Ncalcs select case ( cdef ( calcs ( c )% typ )% key ) case ( 'chemscore' ) call score_mean case ( 'xscore' ) call xscore_mean case ( 'pmfscore' ) call pmfscore_mean !add more call to mean routines here... end select end do end subroutine make_mean_all logical function get_coordfile ( cf , fn , frames ) !arguments character ( len = 256 ), intent ( out ) :: cf integer , intent ( out ) :: fn character ( len = 80 ), optional :: frames !locals integer :: filestat , p character ( len = 4 ) :: trj_type get_coordfile = . false . do read ( * , '(a)' , iostat = filestat ) cf if ( filestat /= 0 ) exit !EOF on input if ( cf == 'end' . or . cf == 'END' . or . cf == '.' ) exit if ( cf == 'mean' . or . cf == 'MEAN' ) then call make_mean_all cycle end if if ( cf == 'ref' . or . cf == 'REF' ) then call make_ref_all ( xin ) write ( * , '(a)' ) 'Updated reference coordinate set.' cycle end if ! see if user specified frame interval p = index ( cf , ',' ) if ( p . ne . 0. and . present ( frames )) then frames = adjustl ( trim ( cf ( p + 1 : 256 ))) cf = adjustl ( trim ( cf ( 1 : p - 1 ))) elseif ( present ( frames )) then frames = '' end if !open file if filename was specified fn = freefile () open ( unit = fn , file = cf , status = 'old' , action = 'read' , form = 'unformatted' , & iostat = filestat ) if ( filestat /= 0 ) then write ( * , 900 ) trim ( cf ) 900 format ( '>>>>> ERROR: failed to open ' , a ) cycle else !determine type read ( fn ) trj_type if ( trj_type == 'CORD' ) then !it's a trajectory !it is read by the trajectory module close ( fn ) fn = 0 get_coordfile = trj_open ( cf ) if ( get_coordfile ) then !write the reference coordinates into xin !so that atoms not in the trajectory !get their reference coordinates xin (:) = xtop (:) end if else !is's a restrart file backspace ( fn ) get_coordfile = . true . end if exit end if end do end function get_coordfile logical function load_restart ( fn ) !arguments integer , intent ( in ) :: fn !locals integer ( 4 ) :: nat3 integer :: filestat load_restart = . false . rewind ( fn ) read ( fn , iostat = filestat ) nat3 if ( filestat > 0 ) then write ( * , 900 ) 900 format ( '>>>>> ERROR: Coordinate file read failure.' ) elseif ( filestat < 0 ) then ! EOF - do nothing elseif ( nat3 == 3 ) then !We found a polarization restraint data record in a restart file !do nothing elseif ( nat3 /= 3 * nat_pro ) then write ( * , 910 ) nat3 / 3 910 format ( '>>>>> ERROR: Wrong number of atoms in coordinate file:' , i5 ) else backspace ( fn ) read ( fn ) nat3 , xin (:) load_restart = . true . end if close ( fn ) end function load_restart subroutine finalize_topology call topo_deallocate end subroutine finalize_topology subroutine add_kind ( desc , key , output ) character ( * ) :: desc character ( * ) :: key logical :: output If ( Nkinds == MAX_CALC_KINDS ) then stop 'Too many kinds of calculations.' end if Nkinds = Nkinds + 1 cdef ( Nkinds )% desc = desc cdef ( Nkinds )% key = key cdef ( Nkinds )% output = output end subroutine add_kind subroutine calc_menu integer :: i call centered_heading ( 'List of calculation types' , '=' ) write ( * , 90 ) ' ' , 'description' , 'command' 90 format ( a2 , 1 x , a , t44 , a , t20 ) 100 format ( i2 , 1 x , a , t44 , a , t20 ) do i = 1 , Nkinds write ( * , 100 ) i , cdef ( i )% desc , cdef ( i )% key end do write ( * , 90 ) ' ' , 'Show list of calculations+menu' , 'list' write ( * , 90 ) ' ' , 'Proceed to next phase' , 'go' end subroutine calc_menu subroutine add_calcs character ( len = 200 ) :: input integer :: kind , readstat call calc_menu ! calc_menu outputs menu and calc. descriptions do write ( * , '(a)' , advance = 'no' ) 'Qcalc> ' read ( * , * ) input read ( input , '(i5)' , iostat = readstat ) kind if ( readstat == 0 ) then !got numeric input if ( kind < 1 . or . kind > Nkinds ) then write ( * , 900 ) kind 900 format ( '>>>>> ERROR: Command number ' , i2 , ' is not available.' ) cycle end if else input = adjustl ( input ) call locase ( input ) if ( input == 'go' ) exit if ( input == 'list' ) then call list_calcs ! outputs list of calcs call calc_menu cycle end if do kind = 1 , Nkinds if ( cdef ( kind )% key == input ) exit end do if ( kind > Nkinds ) then write ( * , 910 ) trim ( input ) 910 format ( '>>>>> ERROR: The command ' , a , ' is not available.' ) cycle end if end if !at this stage we do have a proper input call add_a_calc ( kind ) end do end subroutine add_calcs subroutine make_ref_all ( x ) real ( 8 ) :: x (:) integer :: i !copy current coordinates to xtop xtop (:) = xin (:) do i = 1 , Ncalcs select case ( cdef ( calcs ( i )% typ )% key ) case ( 'rmsd' ) call RMS_make_ref ( calcs ( i )% i ) case ( 'rmsf' ) call RMSF_make_ref ( calcs ( i )% i ) case ( 'fit' ) call fit_make_ref ( calcs ( i )% i ) end select end do end subroutine make_ref_all subroutine list_calcs integer :: c call centered_heading ( 'List of defined calculations' , '=' ) do c = 1 , Ncalcs write ( * , 100 ) c , calcs ( c )% desc 100 format ( i2 , 1 x , a ) end do end subroutine list_calcs subroutine add_a_calc ( kind ) integer :: kind if ( Ncalcs == MAX_CALCS ) then write ( * , '(a)' ) '>>>>> ERROR: Too many calculations.' return end if Ncalcs = NCalcs + 1 calcs ( Ncalcs )% typ = kind select case ( cdef ( kind )% key ) case ( 'rmsd' ) calcs ( Ncalcs )% i = RMS_add ( calcs ( Ncalcs )% desc ) case ( 'rmsf' ) calcs ( Ncalcs )% i = RMSF_add ( calcs ( Ncalcs )% desc ) case ( 'fit' ) calcs ( Ncalcs )% i = fit_add ( calcs ( Ncalcs )% desc ) case ( 'dist' ) calcs ( Ncalcs )% i = dist_add ( calcs ( Ncalcs )% desc ) case ( 'angle' ) calcs ( Ncalcs )% i = angle_add ( calcs ( Ncalcs )% desc ) case ( 'torsion' ) calcs ( Ncalcs )% i = torsion_add ( calcs ( Ncalcs )% desc ) case ( 'entropy' ) calcs ( Ncalcs )% i = entropy_add ( calcs ( Ncalcs )% desc ) case ( 'nonbond' ) calcs ( Ncalcs )% i = nb_add ( calcs ( Ncalcs )% desc ) case ( 'nb_prot_qatom' ) calcs ( Ncalcs )% i = nb_qp_add ( calcs ( Ncalcs )% desc ) case ( 'chemscore' ) calcs ( Ncalcs )% i = score_add ( calcs ( Ncalcs )% desc ) case ( 'xscore' ) calcs ( Ncalcs )% i = xscore_add ( calcs ( Ncalcs )% desc ) case ( 'pmfscore' ) calcs ( Ncalcs )% i = pmf_add ( calcs ( Ncalcs )% desc ) case ( 'rdf' ) calcs ( Ncalcs )% i = rdf_add ( calcs ( Ncalcs )% desc ) case ( 'com_ke' ) calcs ( Ncalcs )% i = com_ke_add ( calcs ( Ncalcs )% desc ) case ( 'com' ) calcs ( Ncalcs )% i = com_add ( calcs ( Ncalcs )% desc ) !add more calls to add routines here... end select if ( calcs ( Ncalcs )% i == 0 ) then !add failed !remove the empty entry Ncalcs = Ncalcs - 1 else !successful write ( * , 100 ) Ncalcs , calcs ( Ncalcs )% desc 100 format ( 'Added calc. #' , i2 , ': ' , a ) end if end subroutine add_a_calc subroutine print_headings integer :: c , i call list_calcs call centered_heading ( 'Calculation results' , '-' ) write ( * , 90 , advance = 'no' ) 'file' , 'frame' 90 format ( a , t22 , a ) do c = 1 , Ncalcs if ( cdef ( calcs ( c )% typ )% output ) then i = calcs ( c )% i write ( * , 100 , advance = 'no' ) c 100 format ( 1 x , i2 , ':' ) select case ( cdef ( calcs ( c )% typ )% key ) case ( 'rmsd' ) call RMS_heading ( i ) case ( 'rmsf' ) call RMSF_heading ( i ) case ( 'fit' ) !no output - no heading case ( 'dist' ) call dist_heading ( i ) case ( 'angle' ) call angle_heading ( i ) case ( 'torsion' ) call torsion_heading ( i ) case ( 'nonbond' ) call nb_heading ( i ) case ( 'nb_prot_qatom' ) !                               call nb_heading(i) case ( 'chemscore' ) call score_heading ( i ) case ( 'xscore' ) call xscore_heading ( i ) case ( 'pmfscore' ) call pmf_heading ( i ) case ( 'rdf' ) call rdf_heading ( i ) case ( 'com_ke' ) call com_ke_heading ( i ) case ( 'com' ) call com_heading ( i ) !add more call to heading routines here... end select end if end do write ( * , * ) !new line end subroutine print_headings subroutine calc_all ( frame ) integer :: frame integer :: c , i do c = 1 , Ncalcs i = calcs ( c )% i if ( cdef ( calcs ( c )% typ )% output ) then write ( * , 100 , advance = 'no' ) 100 format ( 1 x ) end if select case ( cdef ( calcs ( c )% typ )% key ) case ( 'rmsd' ) call RMS_calc ( i ) case ( 'rmsf' ) call RMSF_calc ( i ) case ( 'fit' ) call fit_calc ( i ) case ( 'dist' ) call dist_calc ( i ) case ( 'angle' ) call angle_calc ( i ) case ( 'torsion' ) call torsion_calc ( i ) case ( 'entropy' ) call entropy_calc ( i ) case ( 'nonbond' ) call nb_calc ( i ) case ( 'nb_prot_qatom' ) call nb_qp_calc () case ( 'chemscore' ) call score_calc ( i , frame ) case ( 'xscore' ) call xscore_calc ( i , frame ) case ( 'pmfscore' ) call pmf_calc ( i , frame ) case ( 'rdf' ) call rdf_calc ( i ) case ( 'com_ke' ) call com_ke_calc ( i ) case ( 'com' ) call com_calc ( i ) !add more call to calculation routines here... end select end do end subroutine calc_all end program qcalc","tags":"","loc":"sourcefile/qcalc.f90.html","title":"qcalc.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  qdyn.f90 !  by Johan Aqvist, John Marelius, Anders Kaplan & Martin Nervall !  Qdyn molecular dynamics main program !------------------------------------------------------------------------------! program qdyn use md use mpiglob use version #if defined (_DF_VERSION_) use dfport ! portability lib for signals. Used in windows. #endif implicit none ! version data character ( * ), parameter :: PROGRAM_NAME = 'qdyn' character ( * ), parameter :: PROGRAM_VERSION = '5.7' character ( * ), parameter :: PROGRAM_DATE = '2015-02-22' #if defined (USE_MPI) character ( 10 ) :: PROGRAM_SUFFIX = '_parallel' #else character ( 10 ) :: PROGRAM_SUFFIX = '' #endif #if defined (USE_MPI) ! MPI error code integer :: qdyn_ierr #endif ! signal handler data and declarations integer ( 4 ) :: sigret #if defined (_DF_VERSION_) ! nothing #else integer ( 4 ), parameter :: SIGINT = 2 ! CTRL-C signal integer ( 4 ), parameter :: SIGKILL = 9 ! kill/CTRL-BREAK signal integer ( 4 ), parameter :: SIGABRT = 6 ! kill/CTRL-BREAK signal #endif external sigint_handler external sigkill_handler external sigabrt_handler #if defined (USE_MPI) ! initialize MPI call MPI_Init ( qdyn_ierr ) if ( qdyn_ierr . ne . MPI_SUCCESS ) call die ( 'failure at MPI init' ) call MPI_Comm_rank ( MPI_COMM_WORLD , nodeid , qdyn_ierr ) call MPI_Comm_size ( MPI_COMM_WORLD , numnodes , qdyn_ierr ) #else nodeid = 0 numnodes = 1 #endif ! init signal handlers sigret = SIGNAL ( SIGINT , sigint_handler , - 1 _ 4 ) sigret = SIGNAL ( SIGKILL , sigkill_handler , - 1 _ 4 ) sigret = SIGNAL ( SIGABRT , sigabrt_handler , - 1 _ 4 ) ! initialize static data, display banner etc call startup if ( nodeid . eq . 0 ) then ! master node: read input and initialize if (. not . initialize ()) call die ( 'Invalid data in input file' ) ! read input data call open_files ! open necessary files call topology ! read topology call prep_coord ! read coords, solvates etc if ( nstates > 0 ) call get_fep ! read fep/evb strategy !remove things with code 0 and maybe excluded bonded interactions call prep_sim ! prepare for simulation (calc. inv. mass, total charge,...) call close_input_files ! close input files call init_shake call make_nbqqlist call shrink_topology call nbmonitorlist call init_trj ! generate Maxwellian velocities and shake initial x and v if necessary if ( iseed > 0 ) then call maxwell call initial_shaking call stop_cm_translation end if end if #if defined (USE_MPI) ! initialize slave nodes if ( numnodes . gt . 1 ) call init_nodes #endif ! count non-bonded pairs to get the maximum number, then distribute them ! among the nodes call distribute_nonbonds ! do the work! call md_run if ( nodeid . eq . 0 ) then ! master node: close output files call close_output_files end if ! deallocate memory etc. call shutdown #if defined (USE_MPI) ! shut down MPI call MPI_Finalize ( qdyn_ierr ) #endif contains !----------------------------------------------------------------------------- ! startup subroutine !----------------------------------------------------------------------------- subroutine startup integer :: i integer :: datum ( 8 ) if ( nodeid . eq . 0 ) then ! start-of-header write ( * , '(79a)' ) ( '#' , i = 1 , 79 ) #if defined (DUM) write ( * , '(a,a,a)' ) 'qdum input checker version ' , trim ( PROGRAM_VERSION ), ' initializing' #elif defined(EVAL) write ( * , '(a,a,a)' ) 'qdyn evaluation version ' , trim ( PROGRAM_VERSION ), ' initializing' write ( * , '(a)' ) 'This version is for evaluation purposes only.' write ( * , '(a)' ) 'Optimizations are disabled - runs at <20% of maximum speed.' #else write ( * , '(a,a,a,a)' ) 'qdyn version ' , trim ( PROGRAM_VERSION ), trim ( PROGRAM_SUFFIX ), ' initializing' #endif call date_and_time ( values = datum ) write ( * , 130 ) datum ( 1 ), datum ( 2 ), datum ( 3 ), datum ( 5 ), datum ( 6 ), datum ( 7 ) 130 format ( 'Current date ' , i4 , '-' , i2 , '-' , i2 , ' and time ' , i2 , ':' , i2 , ':' , i2 ) end if ! initialize used modules call md_startup end subroutine startup !----------------------------------------------------------------------------- ! shutdown subroutine !----------------------------------------------------------------------------- subroutine shutdown integer :: i if ( nodeid . eq . 0 ) then #if defined (DUM) write ( * , * ) 'QDum input checker version ' , PROGRAM_VERSION , ' terminated normally.' #else write ( * , * ) 'QDyn version ' , trim ( PROGRAM_VERSION ), trim ( PROGRAM_SUFFIX ), ' terminated normally.' #endif write ( * , '(79a)' ) ( '#' , i = 1 , 79 ) end if ! call md's shutdown call md_shutdown end subroutine shutdown #if ! defined(__PATHCC__) integer ( 4 ) function signal ( signum , proc , flag ) implicit none integer ( 4 ) :: signum , flag external proc signal = 1 end function signal #endif end program qdyn !------------------------------------------------------------------------------- ! signal handlers !------------------------------------------------------------------------------- INTEGER ( 4 ) FUNCTION sigint_handler ( sig_num ) use md implicit none INTEGER ( 4 ) :: sig_num call die ( 'user request (control-C)' ) sigint_handler = 1 END FUNCTION sigint_handler INTEGER ( 4 ) FUNCTION sigkill_handler ( sig_num ) use md implicit none INTEGER ( 4 ) :: sig_num call die ( 'kill signal' ) sigkill_handler = 1 END FUNCTION sigkill_handler INTEGER ( 4 ) FUNCTION sigabrt_handler ( sig_num ) use md implicit none INTEGER ( 4 ) :: sig_num call die ( 'kill signal' ) sigabrt_handler = 1 END FUNCTION sigabrt_handler","tags":"","loc":"sourcefile/qdyn.f90.html","title":"qdyn.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------- !  (C) 2015 Molekylmekanikerna HB, Uppsala, Sweden !  program: qfep.f90 !  by Johan Aqvist, Karin Kolmodin, John Marelius, Johan Sund !  qfep free energy analysis program for FEP, EVB & Umbrella Sampling !------------------------------------------------------------------------------- program qfep use nrgy use parse implicit none character ( * ), parameter :: PROGRAM_VERSION = '5.7' character ( * ), parameter :: PROGRAM_DATE = '2015-04-01' integer , parameter :: mxpts = 20000000 integer , parameter :: mxbin = 100 integer , parameter :: mxstates = 4 character ( 80 ) :: filnam , line integer :: i , j , ifile , ipt , istate , ibin , nfiles , nstates , ERR , & nskip , nbins , nmin , idum , noffd , nnoffd , offel , ngroups , & iexclg , igrp , mpts , iexclgn , astate , bstate type ( OFFDIAG_SAVE ), dimension ( mxstates ) :: offd real ( 8 ) :: rt , gapmin , gapmax , sum , dv , gaprange , xint , dvg , veff1 , veff2 , & dGa , dGb , dGg , alpha_B , scale_Hij , veff , min , dlam , sumf , sumb , & konst , fel , nfnr , nrnf real ( 8 ), dimension ( mxbin ) :: sumg , sumg2 , avdvg , avc1 , avc2 , avc11 , avc12 , avc13 , & avc21 , avc22 , avc23 , avc31 , avc32 , avc33 , avr real ( 8 ), dimension ( mxbin , 4 ) :: binsum integer , dimension ( mxbin ) :: nbinpts , ptsum type ( Q_ENERGIES ), dimension ( mxstates ) :: EQ type ( Q_ENERGIES ), dimension ( mxstates ) :: avEQ real ( 8 ), dimension ( mxstates ) :: dvv , dGv , alfa , coeff , Vel , Vvdw real ( 8 ), dimension ( 3 ) :: u , y real ( 8 ), allocatable :: dgf (:), dgr (:), dgfsum (:), dgrsum (:), dG (:), dgti (:), & dgtisum (:), dglu (:), dglusum (:), dgbar (:), dgbarsum (:) real ( 8 ), dimension ( mxstates , mxstates ) :: A , mu , eta , rxy0 real ( 8 ), allocatable :: Hij (:,:), d (:), e (:) type FEP_DATA_TYPE integer :: npts real ( 8 ) :: lambda ( mxstates ) real ( 8 ), pointer :: v (:,:), r (:,:) !indices are state, point real ( 8 ), pointer :: vg (:), gap (:), c1 (:), c2 (:) !index is point end type FEP_DATA_TYPE type ( FEP_DATA_TYPE ), allocatable :: FEP (:) !index is file type ( FEP_DATA_TYPE ) :: FEPtmp !temporary storage for one file real ( 8 ), dimension ( mxstates , mxbin ) :: avdvv , sumv , sumv2 integer :: f , gas = 0 , error , dummyno ! masoud real :: dummy !masoud character ( 100 ) :: iline !masoud !header write ( * , 100 ) PROGRAM_VERSION , PROGRAM_DATE write ( * , * ) 100 format ( '# qfep' , t30 , 'version ' , a , t50 , '(modified on ' , a , ')' ) !------------------------------------------ ! INPUT OF PARAMETERS !------------------------------------------ call prompt ( '--> Number of energy files: ' ) read ( * , * ) nfiles write ( * , 1 ) nfiles 1 format ( '# Number of files                 =' , i6 ) call prompt ( '--> No. of states, no. of predefined off-diag elements: ' ) read ( * , * ) nstates , noffd write ( * , 2 ) nstates , noffd 2 format ( '# Number of states                 =' , i6 , / , & '# Number of off-diagonal elements =' , i6 ) !allocate size of secular determinant allocate ( Hij ( nstates , nstates ), d ( nstates ), e ( nstates ), STAT = ERR ) if ( ERR /= 0 ) then write ( * , * ) 'ERROR: Out of memory when allocating Hij array.' stop 'qfep terminated abnormally: Out of memory.' end if ! Continue to read input call prompt ( '--> Give kT & num. of pts to skip & calculation mode: ' ) read ( * , '(a)' ) iline ! masoud reading an extra option for just calculating QQ energies !print*, iline do i = 1 , 4 read ( iline , * , iostat = error )( dummy , j = 1 , i ) !   print*, error,\"***\",i,dummy if ( error . ne . 0 ) then dummyno = i - 1 exit endif enddo if ( dummyno . eq . 2 ) then read ( iline , * ) rt , nskip elseif ( dummyno . eq . 3 ) then read ( iline , * ) rt , nskip , gas else print * , \"num. correct arguments for KT, data points to skip or calculation mode\" stop end if ! masoud ! read (*,*) rt,nskip write ( * , 3 ) rt , nskip , gas 3 format ( '# kT                              =' , f6 . 3 , / , & '# Number of data points to skip   =' , i6 , / , '# Only QQ interactions will be considered   = ' , i3 ) call prompt ( '--> Give number of gap-bins: ' ) read ( * , * ) nbins write ( * , 4 ) nbins 4 format ( '# Number of gap-bins              =' , i6 ) call prompt ( '--> Give minimum # pts/bin: ' ) read ( * , * ) nmin write ( * , 5 ) nmin 5 format ( '# Minimum number of points per bin=' , i6 ) do istate = 2 , nstates write ( line , 7 ) istate call prompt ( line ) read ( * , * ) alfa ( istate ) write ( * , 6 ) istate , alfa ( istate ) end do 6 format ( '# Alpha for state ' , i2 , '              =' , f6 . 2 ) 7 format ( '--> Give alpha for state ' , i2 , ':' ) scale_Hij = 0.0 if ( noffd /= 0 ) then call prompt ( '--> Hij scaling:' ) read ( * , * ) scale_Hij write ( * , 8 ) scale_Hij 8 format ( '# Scale factor for Hij            =' , f6 . 2 ) else call prompt ( '--> Number of off-diagonal elements:' ) read ( * , * ) nnoffd write ( * , 9 ) nnoffd if ( nnoffd > 0 ) write ( * , 11 ) do offel = 1 , nnoffd call prompt ( '--> i, j, A_ij, mu_ij, eta_ij, r_xy0: ' ) read ( * , * ) i , j , A ( i , j ), mu ( i , j ), eta ( i , j ), rxy0 ( i , j ) write ( * , 12 ) i , j , A ( i , j ), mu ( i , j ), eta ( i , j ), rxy0 ( i , j ) end do 9 format ( '# Number of off-diagonal elements =' , i6 ) 11 format ( '#   i   j   A(i,j)  mu(i,j) eta(i,j) rxy0(i,j)' ) 12 format ( '#' , 2 i4 , 4 f9 . 2 ) end if call prompt ( '--> linear combination of states defining reaction coord: ' ) read ( * , * ) ( coeff ( i ), i = 1 , nstates ) write ( * , 13 ) coeff ( 1 : nstates ) 13 format ( '# Linear combination coefficients=' , 8 f6 . 2 ) !allocate large arrays allocate ( FEP ( nfiles ), FEPtmp % v ( nstates , mxpts ), FEPtmp % r ( nstates , mxpts ), & FEPtmp % vg ( mxpts ), FEPtmp % gap ( mxpts ), & FEPtmp % c1 ( mxpts ), FEPtmp % c2 ( mxpts ), & dgf ( 0 : nfiles + 1 ), dgr ( 0 : nfiles + 1 ), dgti ( 0 : nfiles + 1 ), & dglu ( 0 : nfiles + 1 ), dgbar ( 0 : nfiles + 1 ), & dgfsum ( 0 : nfiles + 1 ), dgrsum ( 0 : nfiles + 1 ), dG ( 0 : nfiles + 1 ), dgtisum ( 0 : nfiles + 1 ), & dglusum ( 0 : nfiles + 1 ), dgbarsum ( 0 : nfiles + 1 ), & STAT = ERR ) if ( ERR /= 0 ) then stop 'qfep terminated abnormally: Out of memory when allocating arrays.' end if !--------------------------------- ! Energy files are opened and read !--------------------------------- binsum (:,:) = 0. EQ (:)% total = 0. gapmin = 99 9. gapmax =- 99 9. f = freefile () FEPtmp % c1 (:) = 0. FEPtmp % c2 (:) = 0. write ( * , * ) write ( * , * ) write ( * , 15 ) write ( * , 16 ) 15 format ( '# Part 0: Average energies for all states in all files' ) 16 format ( '# file             state   pts   lambda    EQtot   EQbond' ,& '  EQang   EQtor   EQimp    EQel   EQvdW  Eel_qq  EvdW_qq Eel_qp  EvdW_qp Eel_qw EvdW_qw Eqrstr' ) do ifile = 1 , nfiles write ( line , 14 ) ifile 14 format ( '--> Name of file number' , i4 , ':' ) call prompt ( line ) read ( * , * ) filnam write ( * , * ) '' if ( openit ( f , filnam , 'old' , 'unformatted' , 'read' ) /= 0 ) then stop 'qfep terminated abnormally: Failed to open energy file.' end if !read 1st record to get lambdas idum = get_ene ( f , EQ (:), offd , nstates , nnoffd ) if ( idum /= 0 ) then !we have a problem write ( * , '(a,a)' ) 'ERROR: Unexpected end-of-file in first record of ' , & trim ( filnam ) if ( idum > 0 ) then !the problem is in energies write ( * , '(a,i1)' ) 'while reading energies of state ' , idum write ( * , '(a,i1,a)' ) 'Maybe there are only ' , idum - 1 , ' states?' stop 'qfep terminated abnormally: Failed to read energies.' else !idum < 0 indicates problems with offdiags write ( * , '(a)' ) 'while reading off-diagonal elements.' write ( * , '(a,i1,a)' ) 'Maybe there are less than ' , nnoffd , & ' off-diagonal elements?' stop 'qfep terminated abnormally: Failed to read off-diagonals.' end if end if FEP ( ifile )% lambda (:) = EQ (:)% lambda rewind ( f ) ipt = 0 avEQ (:) = avEQ (:) * 0. !set all fields to zero using multiplication operator FEPtmp % gap (:) = 0. do while ( get_ene ( f , EQ (:), offd , nstates , nnoffd ) == 0 ) !keep reading till EOF ipt = ipt + 1 !   masoud !if the gas flag is > 0 then total energy will be just q (bonded), qq(nonbonded) and restraint if ( gas . gt . 0 ) then do i = 1 , nstates EQ ( i )% total = EQ ( i )% q % bond + EQ ( i )% q % angle + EQ ( i )% q % torsion + EQ ( i )% q % improper + EQ ( i )% qq % el + EQ ( i )% qq % vdw + EQ ( i )% restraint !         print*, EQ(i)%total, EQ(i)%q,EQ(i)%qq,EQ(i)%restraint !         print*, \"''''''''''\" !         if (ipt > 10 ) stop end do end if !   masoud if ( ipt > nskip ) then avEQ (:) = avEQ (:) + EQ (:) !use Qenergies + operator end if !------------------------------------------- ! Correct H_ii with alfa, and modify H_ij... !------------------------------------------- alfa ( 1 ) = 0. EQ (:)% total = EQ (:)% total + alfa (:) FEPtmp % v ( 1 : nstates , ipt ) = EQ ( 1 : nstates )% total if ( nnoffd . ne . 0 ) then FEPtmp % r (:, ipt ) = offd (:)% rkl end if do i = 1 , noffd Hij ( offd ( i )% i , offd ( i )% j ) = offd ( i )% Hij end do if ( scale_Hij . gt . 0.0 ) then Hij ( 1 , 2 ) = scale_Hij * Hij ( 1 , 2 ) else do i = 1 , nstates do j = 1 , nstates if ( i == j ) then Hij ( i , j ) = EQ ( i )% total else if ( A ( i , j ) == 0.0 ) then Hij ( i , j ) = A ( j , i ) * exp ( - mu ( j , i ) * ( offd ( 1 )% rkl - rxy0 ( j , i ))) * & exp ( - eta ( j , i ) * ( offd ( 1 )% rkl - rxy0 ( j , i )) ** 2 ) else Hij ( i , j ) = A ( i , j ) * exp ( - mu ( i , j ) * ( offd ( 1 )% rkl - rxy0 ( i , j ))) * & exp ( - eta ( i , j ) * ( offd ( 1 )% rkl - rxy0 ( i , j )) ** 2 ) end if end if end do end do end if !----------------------------------------------------------- ! Ground state energy is calculated from secular determinant !----------------------------------------------------------- if ( nstates == 2 ) then FEPtmp % vg ( ipt ) = 0.5 * ( EQ ( 1 )% total + EQ ( 2 )% total ) - & 0.5 * sqrt ( ( EQ ( 1 )% total - EQ ( 2 )% total ) ** 2 + 4. * Hij ( 1 , 2 ) ** 2 ) if ( nnoffd > 0 ) then FEPtmp % c1 ( ipt ) = 1. / ( 1. + (( FEPtmp % vg ( ipt ) - EQ ( 1 )% total ) / Hij ( 1 , 2 )) ** 2 ) FEPtmp % c2 ( ipt ) = 1 - FEPtmp % c1 ( ipt ) end if else call tred2 ( Hij , nstates , nstates , d , e ) call tqli ( d , e , nstates , nstates , Hij ) FEPtmp % vg ( ipt ) = MINVAL ( d ) end if do istate = 1 , nstates FEPtmp % gap ( ipt ) = FEPtmp % gap ( ipt ) + FEPtmp % v ( istate , ipt ) * coeff ( istate ) end do if ( ipt . gt . nskip ) then if ( FEPtmp % gap ( ipt ) . lt . gapmin ) gapmin = FEPtmp % gap ( ipt ) if ( FEPtmp % gap ( ipt ) . gt . gapmax ) gapmax = FEPtmp % gap ( ipt ) end if end do !(ipt) close ( f ) FEP ( ifile )% npts = ipt !copy FEPtmp to D allocate ( FEP ( ifile )% v ( nstates , FEP ( ifile )% npts ), & FEP ( ifile )% vg ( FEP ( ifile )% npts ), & FEP ( ifile )% gap ( FEP ( ifile )% npts ), & FEP ( ifile )% c1 ( FEP ( ifile )% npts ), & FEP ( ifile )% c2 ( FEP ( ifile )% npts ), & STAT = ERR ) if ( ERR /= 0 ) then stop 'qfep terminated abnormally: Out of memory when allocating arrays.' end if FEP ( ifile )% v (:,:) = FEPtmp % v ( 1 : nstates , 1 : FEP ( ifile )% npts ) FEP ( ifile )% vg (:) = FEPtmp % vg ( 1 : FEP ( ifile )% npts ) FEP ( ifile )% gap (:) = FEPtmp % gap ( 1 : FEP ( ifile )% npts ) FEP ( ifile )% c1 (:) = FEPtmp % c1 ( 1 : FEP ( ifile )% npts ) FEP ( ifile )% c2 (:) = FEPtmp % c2 ( 1 : FEP ( ifile )% npts ) if ( nnoffd > 0 ) then allocate ( FEP ( ifile )% r ( nstates , FEP ( ifile )% npts ), STAT = ERR ) if ( ERR /= 0 ) then stop 'qfep terminated abnormally: Out of memory when allocating arrays.' end if FEP ( ifile )% r (:,:) = FEPtmp % r ( 1 : nstates , 1 : FEP ( ifile )% npts ) end if ! Average energies for each file are calculated if ( ipt <= nskip ) then !skipped all points in the file write ( * , 900 ) trim ( filnam ) 900 format ( '>>>>> ERROR: number of data sets in ' , a ,& ' is less than number of points to skip!' ) stop 'qfep terminated abnormally: Too few data points in file.' else avEQ (:) = avEQ (:) * ( 1. / ( FEP ( ifile )% npts - nskip )) !use new * operator end if do istate = 1 , nstates write ( * , 17 ) trim ( filnam ), istate , FEP ( ifile )% npts - nskip , FEP ( ifile )% lambda ( istate ), & avEQ ( istate )% total , avEQ ( istate )% q % bond , avEQ ( istate )% q % angle ,& avEQ ( istate )% q % torsion , & avEQ ( istate )% q % improper , avEQ ( istate )% qx % el , avEQ ( istate )% qx % vdw , & avEQ ( istate )% qq % el , avEQ ( istate )% qq % vdw , avEQ ( istate )% qp % el ,& avEQ ( istate )% qp % vdw , & avEQ ( istate )% qw % el , avEQ ( istate )% qw % vdw , avEQ ( istate )% restraint end do 17 format ( a , t23 , i2 , 1 x , i6 , 1 x , f8 . 6 , 14 f8 . 2 ) end do !ifile if ( nfiles > 1 ) then !the following is meaningless for a single file dgf = 0. dgfsum = 0. sum = 0. veff1 = 0. veff2 = 0. dv = 0. do ifile = 1 , nfiles - 1 !check that number of points > number to skip if ( nskip >= FEP ( ifile )% npts ) then write ( * , 999 ) ifile , nskip , FEP ( ifile )% npts 999 format ( 'File' , i5 , ' contains only' , i5 , ' points. Can''t skip' , i5 ) end if do ipt = nskip + 1 , FEP ( ifile )% npts do istate = 1 , nstates veff1 = veff1 + FEP ( ifile )% lambda ( istate ) * FEP ( ifile )% v ( istate , ipt ) veff2 = veff2 + FEP ( ifile + 1 )% lambda ( istate ) * FEP ( ifile )% v ( istate , ipt ) end do dv = veff2 - veff1 veff1 = 0. veff2 = 0. sum = sum + exp ( - dv / rt ) end do sum = sum / real ( FEP ( ifile )% npts - nskip ) dgf ( ifile ) =- rt * dlog ( sum ) dgfsum ( ifile + 1 ) = dgfsum ( ifile ) + dgf ( ifile ) sum = 0. end do dgrsum = 0. dgr = 0. sum = 0. veff1 = 0. veff2 = 0. dv = 0. do ifile = nfiles , 2 , - 1 do ipt = nskip + 1 , FEP ( ifile )% npts do istate = 1 , nstates veff1 = veff1 + FEP ( ifile )% lambda ( istate ) * FEP ( ifile )% v ( istate , ipt ) veff2 = veff2 + FEP ( ifile - 1 )% lambda ( istate ) * FEP ( ifile )% v ( istate , ipt ) end do dv = veff2 - veff1 veff1 = 0. veff2 = 0. sum = sum + exp ( - dv / rt ) end do sum = sum / real ( FEP ( ifile )% npts - nskip ) dgr ( ifile ) =- rt * dlog ( sum ) dgrsum ( ifile - 1 ) = dgrsum ( ifile ) + dgr ( ifile ) sum = 0. end do dgtisum = 0. dgti = 0. sum = 0. veff1 = 0. veff2 = 0. dv = 0. astate = 1 bstate = 2 istate = 1 do ifile = 1 , nfiles do ipt = nskip + 1 , FEP ( ifile )% npts veff1 = FEP ( ifile )% v ( astate , ipt ) veff2 = FEP ( ifile )% v ( bstate , ipt ) dv = veff2 - veff1 veff1 = 0. veff2 = 0. sum = sum + dv end do dgti ( ifile ) = sum / real ( FEP ( ifile )% npts - nskip ) sum = 0. end do do ifile = 2 , nfiles dlam = FEP ( ifile - 1 )% lambda ( istate ) - FEP ( ifile )% lambda ( istate ) dgtisum ( ifile ) = dgtisum ( ifile - 1 ) + ( 0.5 * ( dgti ( ifile - 1 ) + dgti ( ifile )) * dlam ) end do dglu = 0. dglusum = 0. sum = 0. veff1 = 0. veff2 = 0. dv = 0. do ifile = 1 , nfiles - 1 do ipt = nskip + 1 , FEP ( ifile )% npts do istate = 1 , nstates veff1 = veff1 + FEP ( ifile )% lambda ( istate ) * FEP ( ifile )% v ( istate , ipt ) veff2 = veff2 + FEP ( ifile + 1 )% lambda ( istate ) * FEP ( ifile )% v ( istate , ipt ) end do dv = ( veff2 - veff1 ) / 2 veff1 = 0. veff2 = 0. sum = sum + exp ( - dv / rt ) end do sumf = sum / real ( FEP ( ifile )% npts - nskip ) sum = 0. do ipt = nskip + 1 , FEP ( ifile + 1 )% npts do istate = 1 , nstates veff1 = veff1 + FEP ( ifile )% lambda ( istate ) * FEP ( ifile + 1 )% v ( istate , ipt ) veff2 = veff2 + FEP ( ifile + 1 )% lambda ( istate ) * FEP ( ifile + 1 )% v ( istate , ipt ) end do dv = ( veff2 - veff1 ) / 2 veff1 = 0. veff2 = 0. sum = sum + exp ( dv / rt ) end do sumb = sum / real ( FEP ( ifile + 1 )% npts - nskip ) dglu ( ifile ) =- rt * dlog ( sumf / sumb ) dglusum ( ifile + 1 ) = dglusum ( ifile ) + dglu ( ifile ) sum = 0. end do dgbar = 0. dgbarsum = 0. sum = 0. veff1 = 0. veff2 = 0. dv = 0. konst = 0 fel = 1 do ifile = 1 , nfiles - 1 konst = dglu ( ifile ) do while ( fel > 0.001 ) nfnr = real ( FEP ( ifile )% npts - nskip ) / real ( FEP ( ifile + 1 )% npts - nskip ) nrnf = real ( FEP ( ifile + 1 )% npts - nskip ) / real ( FEP ( ifile )% npts - nskip ) do ipt = nskip + 1 , FEP ( ifile )% npts do istate = 1 , nstates veff1 = veff1 + FEP ( ifile )% lambda ( istate ) * FEP ( ifile )% v ( istate , ipt ) veff2 = veff2 + FEP ( ifile + 1 )% lambda ( istate ) * FEP ( ifile )% v ( istate , ipt ) end do dv = ( veff2 - veff1 ) veff1 = 0. veff2 = 0. sum = sum + 1 / (( 1 + ( nfnr * exp (( dv - konst ) / rt )))) end do sumf = sum / real ( FEP ( ifile )% npts - nskip ) sum = 0. do ipt = nskip + 1 , FEP ( ifile + 1 )% npts do istate = 1 , nstates veff1 = veff1 + FEP ( ifile )% lambda ( istate ) * FEP ( ifile + 1 )% v ( istate , ipt ) veff2 = veff2 + FEP ( ifile + 1 )% lambda ( istate ) * FEP ( ifile + 1 )% v ( istate , ipt ) end do dv = ( veff2 - veff1 ) veff1 = 0. veff2 = 0. sum = sum + 1 / (( 1 + ( nrnf * exp (( - dv + konst ) / rt )))) end do sumb = sum / real ( FEP ( ifile + 1 )% npts - nskip ) dgbar ( ifile ) =- rt * dlog (( sumf / sumb ) * exp ( - konst / rt ) * nfnr ) sum = 0. fel = ABS ( konst - dgbar ( ifile )) konst = dgbar ( ifile ) end do dgbarsum ( ifile + 1 ) = dgbarsum ( ifile ) + dgbar ( ifile ) fel = 1 end do write ( * , * ) write ( * , * ) write ( * , 21 ) write ( * , 22 ) 21 format ( '# Part 1: Free energy perturbation summary:' ) 22 format ( '# lambda(1)      dGf sum(dGf)      dGr sum(dGr)     <dG>' ) dG ( 1 ) = 0.0 do ifile = 2 , nfiles dG ( ifile ) = dG ( ifile - 1 ) + 0.5 * ( dgf ( ifile - 1 ) - dgr ( ifile )) end do do ifile = 1 , nfiles write ( * , 23 ) & FEP ( ifile )% lambda ( 1 ), dgf ( ifile - 1 ), dgfsum ( ifile ), & dgr ( ifile + 1 ), dgrsum ( ifile ), dG ( ifile ) end do 23 format ( 3 x , f8 . 6 , 5 f9 . 3 ) write ( * , * ) write ( * , '(a,f9.2)' ) '# Min energy-gap is: ' , gapmin write ( * , '(a,f9.2)' ) '# Max energy-gap is: ' , gapmax !----------------------------------- ! Reaction free energy is calculated !----------------------------------- write ( * , * ) write ( * , * ) write ( * , 24 ) write ( * , 25 ) 24 format ( '# Part 2: Reaction free energy summary:' ) 25 format ( '# Lambda(1)  bin Energy gap      dGa     dGb     dGg    # pts    c1**2    c2**2' ) 26 format ( 3 x , f8 . 6 , i5 , 2 x , 4 f9 . 2 , 2 x , i5 , 2 f9 . 3 ) gaprange = gapmax - gapmin !Range of reaction coordinate xint = gaprange / real ( nbins ) !Divide R.C. into bins do ifile = 1 , nfiles avdvv = 0. avdvg = 0. sumv = 0. sumg = 0. avc1 = 0. avc2 = 0. avr = 0. dvv = 0. dvg = 0. nbinpts = 0 do ipt = nskip + 1 , FEP ( ifile )% npts ibin = int (( FEP ( ifile )% gap ( ipt ) - gapmin ) / xint ) + 1 veff = 0. do istate = 1 , nstates veff = veff + FEP ( ifile )% lambda ( istate ) * FEP ( ifile )% v ( istate , ipt ) end do !states dvv ( 1 : nstates ) = FEP ( ifile )% v ( 1 : nstates , ipt ) - veff dvg = FEP ( ifile )% vg ( ipt ) - veff avdvv (:, ibin ) = avdvv (:, ibin ) + dvv (:) avdvg ( ibin ) = avdvg ( ibin ) + dvg avc1 ( ibin ) = avc1 ( ibin ) + FEP ( ifile )% c1 ( ipt ) avc2 ( ibin ) = avc2 ( ibin ) + FEP ( ifile )% c2 ( ipt ) !Only gives first r_xy distance if ( nnoffd > 0 ) avr ( ibin ) = avr ( ibin ) + FEP ( ifile )% r ( 1 , ipt ) nbinpts ( ibin ) = nbinpts ( ibin ) + 1 end do !ipt do ibin = 1 , nbins if ( nbinpts ( ibin ) . ne . 0 ) then avc1 ( ibin ) = avc1 ( ibin ) / real ( nbinpts ( ibin )) avc2 ( ibin ) = avc2 ( ibin ) / real ( nbinpts ( ibin )) avr ( ibin ) = avr ( ibin ) / real ( nbinpts ( ibin )) avdvv (:, ibin ) = avdvv (:, ibin ) / nbinpts ( ibin ) avdvg ( ibin ) = avdvg ( ibin ) / nbinpts ( ibin ) end if end do !ibin do ipt = nskip + 1 , FEP ( ifile )% npts ibin = int (( FEP ( ifile )% gap ( ipt ) - gapmin ) / xint ) + 1 veff = 0. do istate = 1 , nstates veff = veff + FEP ( ifile )% lambda ( istate ) * FEP ( ifile )% v ( istate , ipt ) end do !istate do istate = 1 , nstates dvv ( istate ) = FEP ( ifile )% v ( istate , ipt ) - veff - avdvv ( istate , ibin ) end do dvg = FEP ( ifile )% vg ( ipt ) - veff - avdvg ( ibin ) sumv (:, ibin ) = sumv (:, ibin ) + exp ( - dvv (:) / rt ) sumg ( ibin ) = sumg ( ibin ) + exp ( - dvg / rt ) end do !ipt do ibin = 1 , nbins if ( nbinpts ( ibin ). ge . nmin ) then binsum ( ibin , 2 ) = binsum ( ibin , 2 ) + avc1 ( ibin ) * nbinpts ( ibin ) binsum ( ibin , 3 ) = binsum ( ibin , 3 ) + avc2 ( ibin ) * nbinpts ( ibin ) binsum ( ibin , 4 ) = binsum ( ibin , 4 ) + avr ( ibin ) * nbinpts ( ibin ) !Bin-averaged r_xy sumv (:, ibin ) = sumv (:, ibin ) / real ( nbinpts ( ibin )) sumg ( ibin ) = sumg ( ibin ) / real ( nbinpts ( ibin )) ptsum ( ibin ) = ptsum ( ibin ) + nbinpts ( ibin ) do istate = 1 , nstates sumv2 ( istate , ibin ) =- rt * dlog ( sumv ( istate , ibin )) + avdvv ( istate , ibin ) end do sumg2 ( ibin ) =- rt * dlog ( sumg ( ibin )) + avdvg ( ibin ) ! These are the diabatic free energy curves dGv (:) = dG ( ifile ) + sumv2 (:, ibin ) ! This is the reaction free energy dGg = dG ( ifile ) + sumg2 ( ibin ) binsum ( ibin , 1 ) = binsum ( ibin , 1 ) + dGg * int ( nbinpts ( ibin )) write ( * , 26 ) FEP ( ifile )% lambda ( 1 ), ibin , & gapmin + real ( ibin ) * xint - xint / 2. , dGv ( 1 ), dGv ( 2 ), dGg , & int ( nbinpts ( ibin )), avc1 ( ibin ), avc2 ( ibin ) end if end do !ibin end do !ifile write ( * , * ) write ( * , * ) write ( * , 27 ) write ( * , 28 ) 27 format ( '# Part 3: Bin-averaged summary:' ) 28 format ( '# bin  energy gap  <dGg> <dGg norm> pts  <c1**2> <c2**2> <r_xy>' ) do ibin = 1 , nbins if ( ptsum ( ibin ). ge . nmin ) then binsum ( ibin , 1 ) = binsum ( ibin , 1 ) / real ( ptsum ( ibin )) ! Bin-averaged reaction free energy binsum ( ibin , 2 ) = binsum ( ibin , 2 ) / real ( ptsum ( ibin )) ! Bin-averaged c1**2 binsum ( ibin , 3 ) = binsum ( ibin , 3 ) / real ( ptsum ( ibin )) ! Bin-averaged c2**2 binsum ( ibin , 4 ) = binsum ( ibin , 4 ) / real ( ptsum ( ibin )) ! Bin-averaged r_xy end if end do min = MINVAL ( binsum (:, 1 )) do ibin = 1 , nbins if ( ptsum ( ibin ). ge . nmin ) then 29 format ( i4 , 1 x , 3 f9 . 2 , 2 x , i5 , 3 f8 . 3 , 4 f8 . 2 ) write ( * , 29 ) ibin , gapmin + real ( ibin ) * xint - xint / 2. , binsum ( ibin , 1 ), & binsum ( ibin , 1 ) - min , int ( ptsum ( ibin )), binsum ( ibin , 2 ), binsum ( ibin , 3 ), binsum ( ibin , 4 ) end if end do !ibin end if !nfiles >1 write ( * , * ) write ( * , * ) write ( * , 30 ) write ( * , 31 ) 30 format ( '# Part 4: Termodynamic integration:' ) 31 format ( '# lambda(1)      dGti    sum(dGti) ' ) do ifile = 1 , nfiles write ( * , 23 ) & FEP ( ifile )% lambda ( 1 ), dgti ( ifile - 1 ), dgtisum ( ifile ) end do write ( * , * ) write ( * , * ) write ( * , 32 ) write ( * , 33 ) 32 format ( '# Part 5: Overlap sampling Lu et al:' ) 33 format ( '# lambda(1)      dG    sum(dG) ' ) do ifile = 1 , nfiles write ( * , 23 ) & FEP ( ifile )% lambda ( 1 ), dglu ( ifile - 1 ), dglusum ( ifile ) end do write ( * , * ) write ( * , * ) write ( * , 33 ) write ( * , 34 ) 34 format ( '# Part 6: BAR Bennet:' ) 35 format ( '# lambda(1)      dG    sum(dG) ' ) do ifile = 1 , nfiles write ( * , 23 ) & FEP ( ifile )% lambda ( 1 ), dgbar ( ifile - 1 ), dgbarsum ( ifile ) end do !clean up do ifile = 1 , nfiles deallocate ( FEP ( ifile )% v , FEP ( ifile )% vg , FEP ( ifile )% gap , & FEP ( ifile )% c1 , FEP ( ifile )% c2 ) if ( nnoffd > 0 ) deallocate ( FEP ( ifile )% r ) end do deallocate ( FEP ) deallocate ( Hij , d , e , STAT = ERR ) !....................................................................... contains !------------------------------ subroutine prompt ( outtxt ) character ( * ) outtxt #if defined (__osf__) !prompt to STDERR using unit 5=STDIN on OSF/1=DEC UNIX integer , parameter :: f = 5 !write (f,'($,a)') outtxt #elseif defined (_WIN32) !open the ERR file on Win32 integer , save :: f if ( f == 0 ) then f = 17 open ( unit = f , file = 'ERR' ) end if !write (f1,'($,a)') outtxt #else !otherwise prompt to STDOUT integer , parameter :: f = 6 !write (f2,'($,a)') outtxt #endif write ( f , '($,a)' ) outtxt end subroutine prompt !------------------------------ subroutine tred2 ( A , N , NP , D , E ) !------------------------------------------------------------ ! This subroutine reduces a symmetric matrix to tridiagonal ! form. The tridiagonal matrix can further be diagonalized by ! the subroutine tqli. ! These subroutines were copied by Karin Kolmodin 20 Nov. 1997 ! from http://rsc.anu.au/HWS/COURSES/MATHMETH/node70.html ! and rewritten in f90. !------------------------------------------------------------ real ( 8 ), dimension (:) :: D , E real ( 8 ), dimension (:,:) :: A integer :: NP , I , J , K , L , N , ERR real ( 8 ) :: SCALE , F , G , H , HH IF ( N . GT . 1 ) THEN DO I = N , 2 , - 1 L = I - 1 H = 0. SCALE = 0. IF ( L . GT . 1 ) THEN DO K = 1 , L SCALE = SCALE + ABS ( A ( I , K )) end do IF ( SCALE . EQ . 0. ) THEN E ( I ) = A ( I , L ) ELSE DO K = 1 , L A ( I , K ) = A ( I , K ) / SCALE H = H + A ( I , K ) ** 2 end do F = A ( I , L ) G =- SIGN ( SQRT ( H ), F ) E ( I ) = SCALE * G H = H - F * G A ( I , L ) = F - G F = 0. DO J = 1 , L A ( J , I ) = A ( I , J ) / H G = 0. DO K = 1 , J G = G + A ( J , K ) * A ( I , K ) end do IF ( L . GT . J ) THEN DO K = J + 1 , L G = G + A ( K , J ) * A ( I , K ) end do END IF E ( J ) = G / H F = F + E ( J ) * A ( I , J ) end do HH = F / ( H + H ) DO J = 1 , L F = A ( I , J ) G = E ( J ) - HH * F E ( J ) = G DO K = 1 , J A ( J , K ) = A ( J , K ) - F * E ( K ) - G * A ( I , K ) end do end do END IF ELSE E ( I ) = A ( I , L ) END IF D ( I ) = H end do END IF D ( 1 ) = 0. E ( 1 ) = 0. DO I = 1 , N L = I - 1 IF ( D ( I ). NE . 0. ) THEN DO J = 1 , L G = 0. DO K = 1 , L G = G + A ( I , K ) * A ( K , J ) end do DO K = 1 , L A ( K , J ) = A ( K , J ) - G * A ( K , I ) end do end do END IF D ( I ) = A ( I , I ) A ( I , I ) = 1. IF ( L . GE . 1 ) THEN DO J = 1 , L A ( I , J ) = 0. A ( J , I ) = 0. end do END IF end do end subroutine tred2 !----------------------------------- subroutine tqli ( D , E , N , NP , Z ) !------------------------------------------------------------ ! This subroutine diagonalizes a tridiagonal matrix which has ! been prepared by the subroutine tred2. ! These subroutines were copied by Karin Kolmodin 20 Nov. 1997 ! from http://rsc.anu.au/HWS/COURSES/MATHMETH/node70.html ! and rewritten in f90 !------------------------------------------------------------ implicit none real ( 8 ), dimension (:) :: D , E real ( 8 ), dimension (:,:) :: Z integer :: I , N , NP , K , L , M , ITER real ( 8 ) :: DD , G , R , S , C , P , F , B IF ( N . GT . 1 ) THEN DO I = 2 , N E ( I - 1 ) = E ( I ) end do E ( N ) = 0. DO L = 1 , N ITER = 0 1 DO M = L , N - 1 DD = ABS ( D ( M )) + ABS ( D ( M + 1 )) IF ( ABS ( E ( M )) + DD . EQ . DD ) GO TO 2 end do M = N 2 IF ( M . NE . L ) THEN IF ( ITER . EQ . 30 ) STOP 'too many iterations' ITER = ITER + 1 G = ( D ( L + 1 ) - D ( L )) / ( 2. * E ( L )) R = SQRT ( G ** 2 + 1. ) G = D ( M ) - D ( L ) + E ( L ) / ( G + SIGN ( R , G )) S = 1. C = 1. P = 0. DO I = M - 1 , L , - 1 F = S * E ( I ) B = C * E ( I ) IF ( ABS ( F ). GE . ABS ( G )) THEN C = G / F R = SQRT ( C ** 2 + 1. ) E ( I + 1 ) = F * R S = 1. / R C = C * S ELSE S = F / G R = SQRT ( S ** 2 + 1. ) E ( I + 1 ) = G * R C = 1. / R S = S * C END IF G = D ( I + 1 ) - P R = ( D ( I ) - G ) * S + 2. * C * B P = S * R D ( I + 1 ) = G + P G = C * R - B DO K = 1 , N F = Z ( K , I + 1 ) Z ( K , I + 1 ) = S * Z ( K , I ) + C * F Z ( K , I ) = C * Z ( K , I ) - S * F end do end do D ( L ) = D ( L ) - P E ( L ) = G E ( M ) = 0. GO TO 1 END IF end do END IF RETURN end subroutine tqli !----------------------------------- end program qfep","tags":"","loc":"sourcefile/qfep.f90.html","title":"qfep.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: october 14, 2015                                             ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !>  (c) 2015 Uppsala Molekylmekaniska HB, Uppsala, Sweden !>  program: qprep.f90 !>  by Johan Aqvist & John Marelius !>  qprep topology preparation main program !------------------------------------------------------------------------------! program qprep use iso_fortran_env use prep use avetr implicit none character ( * ), parameter :: PROGRAM_NAME = 'qprep' character ( * ), parameter :: PROGRAM_VERSION = '5.7' character ( * ), parameter :: PROGRAM_DATE = '2015-04-01' character ( * ), parameter :: PROGRAM_SUFFIX = '' character ( * ), parameter :: options = compiler_options () logical :: use_inputfile character ( 200 ) :: fileName = '' character ( len = 32 ) :: arg integer :: i call commandlineoptions call startup ! allocate memory for libraries call topo_set_max ( 0 , max_lib , 0 ) ! reset residue count call clearlib use_inputfile = check_inputfile ( fileName ) if ( use_inputfile ) then call qprep_from_inputfile ( fileName ) else call qprep_from_commandline endif call shutdown contains !----------------------------------------------------------------------------! !>  subroutine: qprep_from_inputfile !>  Read input from file and execute commands !----------------------------------------------------------------------------! subroutine qprep_from_inputfile ( filename ) character ( 200 ) :: filename character ( 200 ) :: command logical :: readable integer :: INPF_U = 0 integer :: stat !Fix so that file is read per line and parsed in the same way as in the command line if (. not . parse_open_file ( filename )) then write ( * , '(a,a)' ) 'Could not open ' , filename return endif do call get_string_arg ( command ) select case ( command ) case ( 'quit' , 'q' ) exit case default call parse_command ( command ) end select enddo end subroutine qprep_from_inputfile !----------------------------------------------------------------------------! !>  Read input from command line and execute commands !----------------------------------------------------------------------------! subroutine qprep_from_commandline character ( 200 ) :: command do call parse_reset call get_string_arg ( command , 'qprep> ' ) call locase ( command ) !make all lower case select case ( command ) case ( 'quit' , 'q' ) exit case default call parse_command ( command ) end select enddo end subroutine qprep_from_commandline !----------------------------------------------------------------------------! !>  Parse a command and call corresponding subroutine !----------------------------------------------------------------------------! subroutine parse_command ( command ) character ( * ), intent ( IN ) :: command ! --- Command loop select case ( command ) case ( 'average' , 'av' ) call avetr_calc case ( 'readlib' , 'rl' ) call readlib case ( 'clearlib' , 'cl' ) call clearlib case ( 'readpdb' , 'rp' ) call readpdb case ( 'readprm' , 'readff' , 'rff' , 'rprm' ) call readff case ( 'addbond' , 'ab' ) call addbond case ( 'clearbond' , 'clearbonds' ) call clearbond case ( 'maketop' , 'mt' ) call maketop case ( 'cleartop' ) call cleartop case ( 'listseq' , 'ls' ) call listseq case ( 'listres' , 'lr' ) call listres case ( 'writetop' , 'wt' ) call writetop case ( 'checkbonds' , 'cb' ) call checkbonds case ( 'checkangs' , 'ca' ) call checkangs case ( 'checktors' , 'ct' ) call checktors case ( 'checkimps' , 'ci' ) call checkimps case ( 'changeimp' ) call changeimp case ( 'readtop' , 'rt' ) call readtop case ( 'readx' , 'rx' ) call readx case ( 'makeshell' , 'ms' ) call make_shell2 case ( 'mask' , 'ma' ) call modify_mask case ( 'trajectory' , 'trj' , 'tr' ) call trajectory case ( 'readtrajectory' , 'readframe' , 'rf' ) call readframe case ( 'readnext' , 'rn' ) call readnext case ( 'solvate' , 'so' ) call solvate case ( 'writepdb' , 'wp' ) call writepdb case ( 'writemol2' , 'wm' ) call writemol2 case ( 'xlink' , 'crosslink' , 'xl' ) call xlink case ( 'prefs' , 'preferences' ) call listprefs case ( 'set' , 's' ) call set case ( 'help' , '?' , 'h' ) call help case ( 'boundary' , 'bc' ) call define_boundary_condition case default write ( * , '(/,a,a,a,/)' ) 'unrecognized command \"' , trim ( command ), '\" (type ? for help)' end select end subroutine parse_command !----------------------------------------------------------------------------! !> Give help on commands !----------------------------------------------------------------------------! subroutine help write ( * , * ) write ( * , '(a)' ) & 'command      argument            description' , & '----------- ------------------- -------------------------------------------------' , & 'addbond                          adds extra bonds(e.g. S-S)' ,& 'average                          computes an average structure from a trajectory file' ,& 'boundary    [boundary condition]  set boundary condition' ,& '            [centre] ' ,& '            (box) [boxlengths]' ,& '            (sphere) [radius]' ,& '            (sphere) [inner radius]' ,& 'changeimp                        redefine(specified) improper torsions' ,& 'checkangs   [energy_threshold]   check angle energies' ,& 'checkbonds  [energy_threshold]   check bonds energies' ,& 'checkimps   [energy_threshold]   check improper torsion energies' ,& 'checktors   [energy_threshold]   check torsion energies' ,& 'clearbond                        clears extra bonds' ,& 'clearlib                         unloads all libaries' ,& 'cleartop                         clears topology & parameters' ,& 'help                             shows command list' ,& 'listseq                          lists the residue sequence' ,& 'listres     [residue_number]     lists atoms in residue' ,& 'makeshell                        fix the mask of the atoms in the restrained shell' ,& 'maketop     [name]               generates the topology' ,& 'mask        [mask_def|none]      add to or clear atom mask' ,& 'preferences                      list preferences' , & 'quit                             quits the program' ,& 'readframe   [frame]              reads coordinates from trajectory' ,& 'readlib     [library_file]       reads library file' ,& 'readnext                         reads next frame from trajectory' , & 'readpdb     [pdb_file]           reads pdb file' ,& 'readprm     [param.file]         reads FF parameter file' ,& 'readtop     [topology_file]      reads topology file' ,& 'readx       [restart_file]       reads coord. file' ,& 'set                              set preferences' ,& 'solvate(boundry=sphere)          solvate sphere with specified options' ,& '            [centre]' ,& '            [radius]' ,& '            [grid|file|restart] ' ,& '            [solvent name] ' ,& '            [file name] ' ,& '' ,& 'solvate(boundry=box)             solvate box with specified options' ,& '            [grid|file|restart]  ' ,& '            [solvent name] ' ,& '            [file name] ' ,& '' ,& 'trajectory  [trajectory_file]    open trajectory file' ,& 'writetop    [topology_file]      writes topology file' ,& 'writepdb    [pdb_file]           writes pdb file' , & '            [hydrogen_flag [gap_flag [water_flag]]]' ,& '' ,& 'writemol2   [mol_no]             writes molecule mol_no (0 for all) to' ,& '            [mol2_file]          SYBYL mol2 file' , & '            [hydrogen_flag [water_flag]]' ,& '' ,& 'xlink                            add crosslink bonds interactively' , & '' , & 'short form meaning' ,& '---------- -------' , & 'ab          addbond' , & 'av          average' , & 'bc          boundary' , & 'cb,ca,ct,ci checkbonds, checkangs, checktors, checkimps' , & 'cl          clearlib' , & 'h, ?        help' , & 'lr          listres' , & 'ls          listseq' , & 'ma          mask' , & 'ma 0        clear mask' , & 'ms          makeshell' , & 'mt          maketop' , & 'prefs       preferences' , & 'q           quit' , & 'rf          readframe' , & 'rff         readprm' , & 'rl          readlib' , & 'rn          readnext' , & 'rp          readpdb' , & 'rt          readtop' , & 'rx          readx' , & 's           set' ,& 'so          solvate' , & 'trj, tr     trajectory' , & 'wp          writepdb' , & 'wt          writetop' , & 'xl          xlink' write ( * , * ) end subroutine help !----------------------------------------------------------------------------! !> Startup subroutine !----------------------------------------------------------------------------! subroutine startup !    call version_check(PROGRAM_NAME, PROGRAM_VERSION, PROGRAM_DATE, PROGRAM_SUFFIX) print '(a)' , '--------------------------------------------------------------------------------' print '(4a)' , 'Welcome to ' , PROGRAM_NAME , ' version: ' , PROGRAM_VERSION print '(a)' , ' ' print '(2a)' , 'This version was compiled using: ' , compiler_version () print '(a)' , ' ' print '(a)' , 'And using the following compiler options: ' write ( output_unit , * , delim = 'quote' ) options !  write ( *, '( A /)' ) trim ( compiler_options() ) !  print '(a)',  trim(compiler_options()) print '(a)' , ' ' print '(a)' , 'For command line options type qprep --help  or qprep -h at the terminal.' print '(a)' , ' ' print '(a)' , 'If you are using the interactive mode you can type \"help\"' print '(a)' , 'at the prompt. To quit type \"quit\".' print '(a)' , '--------------------------------------------------------------------------------' call prep_startup write ( * , * ) end subroutine startup !----------------------------------------------------------------------------! !> Shutdown subroutine !----------------------------------------------------------------------------! subroutine shutdown call prep_shutdown stop 'qprep ended normally' end subroutine shutdown !----------------------------------------------------------------------------! !> subroutine: commandlineoptions !----------------------------------------------------------------------------! subroutine commandlineoptions do i = 1 , command_argument_count () call get_command_argument ( i , arg ) select case ( arg ) case ( '-v' , '--version' ) print '(3a)' , PROGRAM_NAME , ' version ' , PROGRAM_VERSION stop case ( '-h' , '--help' ) call print_help () stop case default print '(a,a,/)' , 'Unrecognized command-line option: ' , arg call print_help () stop end select end do end subroutine commandlineoptions !----------------------------------------------------------------------------! !> subroutine: print_help !----------------------------------------------------------------------------! subroutine print_help () print '(a)' , 'usage:' print '(a)' , 'qprep [OPTION]' print '(a)' , '  or' print '(a)' , 'qprep < inputfile.inp > outputfile.out' print '(a)' , '' print '(a)' , 'Without options, qprep goes into interactive mode.' print '(a)' , '' print '(a)' , 'qprep [OPTION]:' print '(a)' , '' print '(a)' , '  -v, --version     print version information and exit' print '(a)' , '  -h, --help        print usage information and exit' end subroutine print_help !----------------------------------------------------------------------------! !> function: check_inputfile !> Determine if qprep is to be run from command line or from input file !----------------------------------------------------------------------------! logical function check_inputfile ( infilename ) !local variables integer :: num_args character ( 200 ), intent ( OUT ) :: infilename character ( 300 ) :: text ! read name of input file from the command line num_args = command_argument_count () if ( num_args . lt . 1 ) then check_inputfile = . false . return endif call getarg ( num_args , infilename ) text = 'Reading input from ' // infilename call centered_heading ( trim ( text ), '-' ) check_inputfile = . true . end function check_inputfile end program qprep","tags":"","loc":"sourcefile/qprep.f90.html","title":"qprep.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------- !  (c) 2015 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  sizes.f90 !  by John Marelius !  data storage specifications for all Q programs !------------------------------------------------------------------------------- module sizes implicit none ! Martin Nervall 2002-11-11 ! set a nice, portable standard for variables integer , parameter :: wp8 = selected_real_kind ( 15 , 307 ) integer , parameter :: sp = selected_real_kind ( 6 , 37 ) integer , parameter :: dp = selected_real_kind ( 15 , 307 ) integer , parameter :: qp = selected_real_kind ( 33 , 4931 ) integer , parameter :: q_int2 = selected_int_kind ( 4 ) integer , parameter :: q_int4 = selected_int_kind ( 9 ) integer , parameter :: q_int8 = selected_int_kind ( 18 ) integer , parameter :: int_byte = selected_int_kind ( 2 ) ! storage specifications for q ! change according to ! 1) the hardware of your machine ! 2) maximum number of atoms desired ! max number of atoms is limited only by the size of the variables used ! as indices to the atom arrays. ! here we use 16-bit signed integers for indexes to the atom arrays ! if more than 2**15-1=32767 atoms are required, change max_atom and ai ! integer, parameter :: ai = 2 !integer(ai) = integer(2) ! integer, parameter :: max_ai = 2**(8*ai-1)-1 ! change to this setting to allow up to 2**31-1 = 2147483647 atoms integer , parameter :: ai = 4 !integer(ai) = integer(4) ! size of integer for flag (1 or 0) variables ! change this for machines do byte-wise memory access slowly integer , parameter :: flag = 1 integer , parameter :: max_flag = 2 ** ( 8 * flag - 1 ) - 1 ! size of integer for small range variables ! (atom types, qatom/qangle/qtorsion/qimproper types,...) ! change this for machines do byte-wise memory access slowly integer , parameter :: tiny = 2 integer , parameter :: max_tiny = 2 ** ( 8 * tiny - 1 ) - 1 ! size of integer for medium range variables (angle/torsion types, ...) ! change this for machines do doublebyte-wise memory access slowly integer , parameter :: shrt = 2 integer , parameter :: max_shrt = 2 ** ( 8 * shrt - 1 ) - 1 ! note ! there are still a couple of hard-coded limitations left. ! the most important of these are ! * maxbndtyp   number of entries in bond type library ! * maxangtyp   number of entries in angle type library ! * max_atyp    number of entries in atom type library ! * max_states  number of different states in perturbations ! * max_qat     number of q-atoms ! note 2 ! it is important that you change the types in subroutine 'init_nodes' ! in md.f90 when you change the types above. otherwise the datastructures ! sent to the slave nodes will be incorrect. this can be dynamically ! handled with later versions of mpi, but is not supported in the ! current version. end module sizes","tags":"","loc":"sourcefile/sizes.f90.html","title":"sizes.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (C) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden !  topo.f90 !  by John Marelius & Johan Aqvist !  molecular topology data and I/O !------------------------------------------------------------------------------! module topo use sizes use misc implicit none ! constants real , private , parameter :: MODULE_VERSION = 5.7 character ( * ), private , parameter :: MODULE_DATE = '2015-02-22' integer , parameter :: nljtyp = 3 !TINY integer , parameter :: max_nbr_range = 25 ! types type bond_type integer ( ai ) :: i , j integer ( shrt ) :: cod end type bond_type type ang_type integer ( ai ) :: i , j , k integer ( shrt ) :: cod end type ang_type type bondlib_type real ( 8 ) :: fk , bnd0 end type bondlib_type type anglib_type real ( 8 ) :: fk , ang0 real ( 8 ) :: ureyfk , ureyr0 end type anglib_type type tor_type integer ( ai ) :: i , j , k , l integer ( shrt ) :: cod end type tor_type type torlib_type real :: fk , rmult , deltor real :: paths end type torlib_type type implib_type real :: fk , imp0 end type implib_type type cgp_type integer ( ai ) :: iswitch !switching atom integer ( ai ) :: first !index in cgpatom array for 1st member integer ( ai ) :: last !index in cgpatom array for last member end type cgp_type type iac_type real ( 8 ) :: mass real ( 8 ) :: avdw ( nljtyp ) real ( 8 ) :: bvdw ( nljtyp ) end type iac_type type lj2_type integer ( tiny ) :: i , j end type lj2_type type residue_type integer :: irc , start character ( 4 ) :: name end type residue_type !       memory management integer , private :: alloc_status !private subroutine private :: topo_check_alloc !topology information real :: version character ( len = 256 ) :: title = '' character ( len = 256 ) :: forcefield = '' character ( len = 256 ) :: creation_date character ( len = 256 ) :: pdb_file = '' character ( len = 256 ) :: lib_files = '' character ( len = 256 ) :: prm_file !atom information !nat_pro = total # of atoms in topology, nat_solute = # solute atoms (no water) integer :: nat_pro , nat_solute , max_atom real ( 8 ), allocatable :: xtop (:) ! topology/coordinates integer ( tiny ), allocatable :: iac (:) ! integer atom codes logical , allocatable :: heavy (:) ! boolean flag, true if atom >= he real , allocatable :: crg (:) ! charges integer ( ai ), allocatable :: cgpatom (:) ! charge groups integer , parameter :: solvent_spc = 0 , solvent_3atom = 1 , solvent_general = 2 integer :: solvent_type integer , allocatable :: glb_cofactor (:) ! 0 = protein or ligand atom, 1,2,3...= cofactor 1, 2, 3... integer , public :: ligand_offset ! topology index offset for ligand. xtop(1:ligand_offset) = protein !sphere information !!sim. sphere & water sphere centres real ( 8 ) :: xpcent ( 3 ), xwcent ( 3 ) real ( 8 ) :: rwat !solvation radius real ( 8 ) :: rexcl_o , rexcl_i integer :: nexats , nshellats , nexwat logical , allocatable :: shell (:) logical , allocatable :: excl (:) !box information real ( 8 ) :: boxlength ( 3 ) !length of the boxedges real ( 8 ) :: boxcentre ( 3 ) !center coordinates of the box real ( 8 ) :: inv_boxl ( 3 ) !inverse of the boxedges !flag indication if simulation sphere (.false.) or periodic box (.true.)is used. logical :: use_pbc = . false . !bond information integer :: nbonds , nbonds_solute , max_bonds type ( bond_type ), allocatable :: bnd (:) integer :: nbndcod , max_bondlib type ( bondlib_type ), allocatable :: bondlib (:) character ( len = 3 ), allocatable :: sybyl_bond_type (:) !angle information integer :: nangles , nangles_solute , max_angles type ( ang_type ), allocatable :: ang (:) integer :: nangcod , max_anglib type ( anglib_type ), allocatable :: anglib (:) !torsion information integer :: ntors , ntors_solute , ntorcod integer :: max_tors , max_torlib integer :: nimps , nimps_solute , nimpcod integer :: max_imps , max_implib , imp_type type ( tor_type ), target , allocatable :: tor (:) type ( tor_type ), target , allocatable :: imp (:) type ( torlib_type ), target , allocatable :: torlib (:) type ( implib_type ), target , allocatable :: implib (:) !charge group information integer :: ncgp , ncgp_solute , max_cgp type ( cgp_type ), allocatable :: cgp (:) !atom type information integer :: natyps , max_atyps integer :: nlj2 , max_lj2 type ( iac_type ), allocatable :: iaclib (:) character ( len = 5 ), allocatable :: sybyl_atom_type (:) character ( len = 8 ), allocatable :: tac (:) !text atom codes type ( lj2_type ), allocatable :: lj2 (:) !force field options integer :: ivdw_rule !combination rule integer , parameter :: vdw_geometric = 1 , vdw_arithmetic = 2 real ( 8 ) :: el14_scale !scaling of 1-4 electrostatics integer :: iuse_switch_atom !switching atoms in charge group real ( 8 ) :: coulomb_constant !constant in coulombs law !type of forcefield, one of ff_gromos, ff_amber, ff_charmm !this only (right now) affects how improper parameters are assigned integer :: ff_type integer , parameter :: ff_gromos = 1 , ff_amber = 2 , ff_charmm = 3 !neighbour lists integer :: n14nbrs integer :: nexnbrs , max_exbnrs integer :: n14long , max_14long integer :: nexlong , max_exlong logical , allocatable :: list14 (:,:) logical , allocatable :: listex (:,:) integer ( ai ), allocatable :: list14long (:,:) !listexlong may be reallocated to include special exclusions integer ( ai ), pointer :: listexlong (:,:) !residue and molecule bookkeeping information integer :: nres , nres_solute , max_res type ( residue_type ), allocatable :: res (:) integer :: nmol , max_mol integer , allocatable :: istart_mol (:) contains !---------------------------------------------------------------------- subroutine topo_startup end subroutine topo_startup !---------------------------------------------------------------------- subroutine topo_set_max ( max , max_lib , max_nbr ) !arguments integer :: max , max_lib , max_nbr max_atom = max max_bonds = 2 * max max_angles = 3 * max max_tors = 12 * max max_imps = max if ( max_lib > MAX_SHRT ) then write ( * , * ) 'ERROR: Cannot have larger libraries than ' , MAX_SHRT ,& ' with current word length.' stop 255 end if max_bondlib = max_lib max_anglib = max_lib max_torlib = max_lib max_implib = max_lib max_lj2 = max_lib max_14long = max_nbr max_exlong = max_nbr max_cgp = max max_res = max max_mol = max end subroutine topo_set_max !---------------------------------------------------------------------- subroutine topo_allocate_potential ( stat_out ) !arguments integer , optional , intent ( out ) :: stat_out !!$                bnd(max_bonds), & !!$             bondlib(max_bondlib), & !!$             SYBYL_bond_type(max_bondlib), & !!$             ang(max_angles), & !!$             anglib(max_anglib), & !!$             tor(max_tors), & !!$             torlib(max_torlib), & !!$             imp(max_imps), & !!$             implib(max_implib), & !!$             lj2(max_lj2), & allocate ( iaclib ( max_atyps ), & tac ( max_atyps ), & SYBYL_atom_type ( max_atyps ), & list14long ( 2 , max_14long ), & listexlong ( 2 , max_exlong ), & cgp ( max_cgp ), & stat = alloc_status ) if ( alloc_status /= 0 ) then write ( * , * ) 'ERROR: Out of memory when allocating topology arrays' if (. not . present ( stat_out )) then stop 255 else stat_out = alloc_status return end if end if end subroutine topo_allocate_potential !---------------------------------------------------------------------- subroutine topo_allocate_atom ( stat_out ) !arguments integer , optional , intent ( out ) :: stat_out allocate ( glb_cofactor ( max_atom ), & iac ( max_atom ), & crg ( max_atom ), & xtop ( 3 * max_atom ), & heavy ( max_atom ), & cgpatom ( max_atom ), & list14 ( max_nbr_range , max_atom ), & listex ( max_nbr_range , max_atom ), & excl ( max_atom ), shell ( max_atom ), & stat = alloc_status ) if ( alloc_status /= 0 ) then write ( * , * ) 'ERROR: Out of memory when allocating topology arrays' if (. not . present ( stat_out )) then stop 255 else stat_out = alloc_status return end if end if end subroutine topo_allocate_atom !---------------------------------------------------------------------- subroutine topo_deallocate ( keep_ff ) !arguments logical , optional , intent ( in ) :: keep_ff !locals logical :: keep keep = . false . if ( present ( keep_ff )) then if ( keep_ff ) keep = . true . end if if (. not . keep . and . allocated ( iaclib )) deallocate ( iaclib ) if (. not . keep . and . allocated ( SYBYL_atom_type )) deallocate ( SYBYL_atom_type ) if (. not . keep . and . allocated ( lj2 )) deallocate ( lj2 ) if (. not . keep . and . allocated ( tac )) deallocate ( tac ) if ( allocated ( glb_cofactor )) deallocate ( glb_cofactor ) if ( allocated ( bnd )) deallocate ( bnd ) if ( allocated ( bondlib )) deallocate ( bondlib ) if ( allocated ( SYBYL_bond_type )) deallocate ( SYBYL_bond_type ) if ( allocated ( ang )) deallocate ( ang ) if ( allocated ( anglib )) deallocate ( anglib ) if ( allocated ( tor )) deallocate ( tor ) if ( allocated ( torlib )) deallocate ( torlib ) if ( allocated ( imp )) deallocate ( imp ) if ( allocated ( implib )) deallocate ( implib ) if ( allocated ( iac )) deallocate ( iac ) if ( allocated ( crg )) deallocate ( crg ) if ( allocated ( xtop )) deallocate ( xtop ) if ( allocated ( heavy )) deallocate ( heavy ) if ( allocated ( cgpatom )) deallocate ( cgpatom ) if ( allocated ( list14 )) deallocate ( list14 ) if ( allocated ( listex )) deallocate ( listex ) if ( allocated ( res )) deallocate ( res ) if ( allocated ( istart_mol )) deallocate ( istart_mol ) if ( allocated ( cgp )) deallocate ( cgp ) if ( allocated ( list14long )) deallocate ( list14long ) if ( allocated ( excl )) deallocate ( excl ) if ( allocated ( shell )) deallocate ( shell ) deallocate ( listexlong , stat = alloc_status ) end subroutine topo_deallocate !---------------------------------------------------------------------- subroutine topo_reallocate_xtop ( atoms ) !arguments integer :: atoms real ( 8 ), allocatable :: r8temp (:) integer :: nat3old_array ( 1 ), nat3old nat3old_array = ubound ( xtop ) nat3old = nat3old_array ( 1 ) allocate ( r8temp ( nat3old ), stat = alloc_status ) call topo_check_alloc ( 'reallocating topology atom array' ) r8temp ( 1 : nat3old ) = xtop ( 1 : nat3old ) deallocate ( xtop ) allocate ( xtop ( atoms * 3 ), stat = alloc_status ) call topo_check_alloc ( 'reallocating topology atom array' ) xtop ( 1 : nat3old ) = r8temp ( 1 : nat3old ) deallocate ( r8temp ) end subroutine topo_reallocate_xtop !---------------------------------------------------------------------- subroutine topo_reallocate ( oldatoms , atoms , waters ) !arguments integer :: oldatoms , atoms , waters !locals integer :: oldbonds , bonds integer :: oldangles , angles real , allocatable :: r4temp (:) integer ( 1 ), allocatable :: i1temp (:) type ( BOND_TYPE ), allocatable :: bndtemp (:) type ( ANG_TYPE ), allocatable :: angtemp (:) oldbonds = nbonds bonds = oldbonds + 2 * waters oldangles = nangles angles = oldangles + 2 * waters !realloc bonds allocate ( bndtemp ( oldbonds ), stat = alloc_status ) call topo_check_alloc ( 'reallocating atom arrays' ) bndtemp ( 1 : oldbonds ) = bnd ( 1 : oldbonds ) deallocate ( bnd ) allocate ( bnd ( bonds ), stat = alloc_status ) call topo_check_alloc ( 'reallocating atom arrays' ) bnd ( 1 : oldbonds ) = bndtemp ( 1 : oldbonds ) deallocate ( bndtemp ) !realloc angles allocate ( angtemp ( oldangles ), stat = alloc_status ) call topo_check_alloc ( 'reallocating atom arrays' ) angtemp ( 1 : oldangles ) = ang ( 1 : oldangles ) deallocate ( ang ) allocate ( ang ( angles ), stat = alloc_status ) call topo_check_alloc ( 'reallocating atom arrays' ) ang ( 1 : oldangles ) = angtemp ( 1 : oldangles ) deallocate ( angtemp ) allocate ( r4temp ( oldatoms ), stat = alloc_status ) call topo_check_alloc ( 'reallocating atom arrays' ) !realloc. crg r4temp ( 1 : oldatoms ) = crg ( 1 : oldatoms ) deallocate ( crg ) allocate ( crg ( atoms ), stat = alloc_status ) call topo_check_alloc ( 'reallocating atom arrays' ) crg ( 1 : oldatoms ) = r4temp ( 1 : oldatoms ) !done with real's deallocate ( r4temp ) allocate ( i1temp ( oldatoms ), stat = alloc_status ) call topo_check_alloc ( 'reallocating atom arrays' ) !realloc. iac i1temp ( 1 : oldatoms ) = iac ( 1 : oldatoms ) deallocate ( iac ) allocate ( iac ( atoms ), stat = alloc_status ) call topo_check_alloc ( 'reallocating atom arrays' ) iac ( 1 : oldatoms ) = i1temp ( 1 : oldatoms ) !done with i1's deallocate ( i1temp ) end subroutine topo_reallocate !---------------------------------------------------------------------- subroutine topo_check_alloc ( message ) implicit none character ( * ) message if ( alloc_status . ne . 0 ) then write ( * , * ) & '>>> Out of memory trying to allocate ' , message stop 255 end if end subroutine topo_check_alloc !---------------------------------------------------------------------- logical function topo_load ( filename , require_version ) !arguments character ( * ) :: filename real , intent ( in ) :: require_version !locals integer :: u , readflag topo_load = . false . ! try opening the file u = topo_open ( filename ) if ( u <= 0 ) then write ( * , '(a,a)' ) 'ERROR: Failed to open topology file ' , & trim ( filename ) return end if ! topo_read topo_load = topo_read ( u , require_version ) ! close file close ( u ) end function topo_load !---------------------------------------------------------------------- integer function topo_open ( filename ) !arguments character ( * ) :: filename !locals integer :: u , stat_out u = freefile () open ( unit = u , file = filename , status = 'old' , form = 'formatted' , & action = 'read' , iostat = stat_out ) if ( stat_out /= 0 ) then write ( * , 10 ) trim ( filename ) topo_open = 0 return end if topo_open = u 10 format ( 'ERROR: Failed to open topology file ' , a ) end function topo_open !------------------------------------------------------------------------------ logical function topo_read ( u , require_version , extrabonds ) ! arguments integer :: u real , intent ( in ) :: require_version integer , optional , intent ( in ) :: extrabonds ! local variables integer :: rd integer :: nat3 , nwat integer :: i , j , k , n , si integer :: nhyds integer :: paths character ( len = 256 ) :: line , restofline character ( len = 10 ) :: key , boundary_type !PWadded integer :: filestat integer ( 1 ), allocatable :: temp_list (:,:) integer :: extra real ( 8 ) :: deprecated topo_read = . false . ! get rid of old topology call topo_deallocate !       This is the default / cutoffs based on switching atoms iuse_switch_atom = 1 !       read topology file call centered_heading ( 'Reading topology file' , '-' ) !handle extra bonds etc if ( present ( extrabonds )) then extra = extrabonds else extra = 0 end if !     read topology file ! --> 1. header or title row ! ========================== !clear header information pdb_file = '' prm_file = '' lib_files = '' forcefield = '' ff_type = FF_GROMOS !this is the default read ( u , '(a80)' , err = 1000 ) title if ( title == 'Q topology file' ) then !it's a file with header do read ( u , '(a256)' ) line read ( line , * ) key !workaround to allow / in strings restofline = adjustl ( line ( len_trim ( key ) + 1 : len ( line ))) call upcase ( key ) select case ( key ) case ( 'TITLE' ) title = restofline case ( 'DATE' ) creation_date = restofline case ( 'VERSION' ) read ( restofline , * ) version case ( 'PDB_FILE' ) pdb_file = restofline case ( 'LIB_FILES' ) lib_files = restofline case ( 'FORCEFIELD' ) forcefield = restofline case ( 'FF_TYPE' ) read ( restofline , * ) ff_type case ( 'PRM_FILE' ) prm_file = restofline case ( 'END' ) exit case default write ( * , '(a,a)' ) '>>>WARNING: Unrecognized key in header: ' , key end select end do else version = 2 end if write ( * , '(a80,/)' ) title if ( version < require_version ) goto 1100 ! --> 2. nat_pro (no. of atoms in topology) ! ========================================= read ( u , '(a)' , err = 1000 ) line read ( line , * , err = 1000 ) nat_pro !first read what must be there read ( line , * , iostat = filestat ) nat_pro , nat_solute !then try to read optional things too if ( filestat . ne . 0 ) then nat_solute = nat_pro !default is nat_solute = nat_pro end if write ( * , 20 ) nat_solute , nat_pro - nat_solute 20 format ( 'No. of solute atoms     = ' , i10 , / ,& 'No. of solvent atoms    = ' , i10 ) max_atom = nat_pro nwat = ( max_atom - nat_solute ) / 3 call topo_allocate_atom if ( nat_pro . eq . 0 ) write ( * , '(a)' ) & '>>> WARNING: Zero topology atoms.' ! --> 3. topology coordinates    ---->     xtop ! ===========================    ============== if ( nat_pro > 0 ) read ( unit = u , fmt =* , err = 1000 ) ( xtop ( rd ), rd = 1 , 3 * nat_pro ) write ( * , 40 ) 3 * nat_pro 40 format ( 'No. of coordinates      = ' , i10 ) ! --> 4. integer atom codes      ---->     iac ! ========================= read ( unit = u , fmt =* , err = 1000 ) ! skip if ( nat_pro > 0 ) read ( unit = u , fmt =* , err = 1000 ) ( iac ( rd ), rd = 1 , nat_pro ) write ( * , 50 ) nat_pro 50 format ( 'No. of atom type codes  = ' , i10 ) ! --> 5. bond list and params    ---->     bnd, bondlib ! =========================== read ( u , '(a)' , err = 1000 ) line read ( line , * , err = 1000 ) nbonds !first read what must be there read ( line , fmt =* , iostat = filestat ) nbonds , nbonds_solute if ( filestat /= 0 ) nbonds_solute = nbonds write ( * , 60 ) nbonds_solute write ( * , 61 ) nbonds - nbonds_solute 60 format ( 'No. of solute bonds     = ' , i10 ) 61 format ( 'No. of solvent bonds    = ' , i10 ) max_bonds = nbonds + 2 * nwat + extra allocate ( bnd ( max_bonds ), stat = alloc_status ) call topo_check_alloc ( 'bond list' ) if ( nbonds > 0 ) read ( unit = u , fmt =* , err = 1000 ) ( bnd ( rd ), rd = 1 , nbonds ) read ( unit = u , fmt =* , err = 1000 ) nbndcod !allocate one extra for water bond max_bondlib = nbndcod + 1 + extra allocate ( bondlib ( max_bondlib ), SYBYL_bond_type ( max_bondlib ), & stat = alloc_status ) call topo_check_alloc ( 'bond library' ) do i = 1 , nbndcod ! initialize sybyl bond type to nothing SYBYL_bond_type ( i ) = '   ' read ( unit = u , fmt = '(a)' , err = 1000 ) line read ( line , fmt =* , end = 700 , err = 700 ) j , bondlib ( i )% fk , bondlib ( i )% bnd0 , SYBYL_bond_type ( i ) !restofline !       call sscan(restofline, SYBYL_bond_type(i)) ! get WS-separated string 700 end do ! --> 6. angle list and params    ---->     ang, anglib ! ============================ read ( u , '(a)' , err = 1000 ) line read ( line , * , err = 1000 ) nangles read ( line , * , iostat = filestat ) nangles , nangles_solute if ( filestat /= 0 ) nangles_solute = nangles write ( * , 80 ) nangles_solute write ( * , 81 ) nangles - nangles_solute 80 format ( 'No. of solute angles    = ' , i10 ) 81 format ( 'No. of solvent angles   = ' , i10 ) max_angles = nangles + nwat + 2 * extra allocate ( ang ( max_angles ), stat = alloc_status ) call topo_check_alloc ( 'angle list' ) if ( nangles > 0 ) read ( unit = u , fmt =* , err = 1000 ) ( ang ( si ), si = 1 , nangles ) read ( unit = u , fmt =* , err = 1000 ) nangcod !allocate one extra for water angle max_anglib = nangcod + 1 + extra allocate ( anglib ( max_anglib ), stat = alloc_status ) call topo_check_alloc ( 'angle library' ) !set optional parameters to zero anglib (:)% ureyfk = 0. anglib (:)% ureyr0 = 0. do i = 1 , nangcod !handle optional Urey-Bradley params read ( unit = u , fmt = '(a)' , err = 1000 ) line !try to read all things read ( unit = line , fmt =* , iostat = filestat ) j , anglib ( i ) !accept end-of-data but not read errors if ( filestat > 0 ) goto 1000 end do ! --> 7. torsion list and params    ---->     tor, torlib ! ============================== read ( u , '(a)' , err = 1000 ) line read ( line , * , err = 1000 ) ntors read ( line , * , iostat = filestat ) ntors , ntors_solute if ( filestat /= 0 ) ntors_solute = ntors write ( * , 100 ) ntors_solute write ( * , 101 ) ntors - ntors_solute 100 format ( 'No. of solute torsions  = ' , i10 ) 101 format ( 'No. of solvent torsions = ' , i10 ) max_tors = ntors + 4 * extra allocate ( tor ( max_tors ), stat = alloc_status ) call topo_check_alloc ( 'torsion list' ) if ( ntors > 0 ) read ( unit = u , fmt =* , err = 1000 ) ( tor ( si ), si = 1 , ntors ) read ( unit = u , fmt =* , err = 1000 ) ntorcod max_torlib = ntorcod + extra allocate ( torlib ( max_torlib ), stat = alloc_status ) call topo_check_alloc ( 'torsion library' ) do i = 1 , ntorcod read ( unit = u , fmt =* , err = 1000 ) j , torlib ( i )% fk , torlib ( i )% rmult , & torlib ( i )% deltor , torlib ( i )% paths end do ! --> 8. improper torsion list and params    ---->     imp, implib ! ======================================= read ( u , '(a)' , err = 1000 ) line read ( line , * , err = 1000 ) nimps read ( line , * , iostat = filestat ) nimps , nimps_solute if ( filestat /= 0 ) nimps_solute = nimps write ( * , 120 ) nimps_solute write ( * , 121 ) nimps - nimps_solute 120 format ( 'No. of solute impropers = ' , i10 ) 121 format ( 'No. of solvent impropers= ' , i10 ) max_imps = nimps + 4 * extra allocate ( imp ( max_imps ), stat = alloc_status ) call topo_check_alloc ( 'impoper torsion list' ) if ( nimps > 0 ) read ( unit = u , fmt =* , err = 1000 ) imp ( 1 : nimps ) read ( unit = u , fmt =* , iostat = filestat ) nimpcod , imp_type if ( filestat /= 0 ) then !water atom type data present imp_type = 1 !default to harmonic end if max_implib = nimpcod + extra allocate ( implib ( max_implib ), stat = alloc_status ) call topo_check_alloc ( 'improper torsion library' ) do i = 1 , nimpcod read ( unit = u , fmt =* , err = 1000 ) j , implib ( i ) end do ! --> 9. charges charges charges                    ---->     crg ! ============================== read ( unit = u , fmt = '(a)' , err = 1000 ) line read ( unit = line , fmt =* , iostat = filestat ) nat_pro if ( nat_pro > 0 ) read ( unit = u , fmt =* , err = 1000 ) crg ( 1 : nat_pro ) write ( * , 130 ) nat_pro 130 format ( 'No. of atomic charges   = ' , i10 ) ! --> 10. charge groups                             ---->     cgp ! ===================== read ( u , '(a)' , err = 1000 ) line read ( line , * , err = 1000 ) ncgp !first read what must be there read ( line , fmt =* , iostat = filestat ) i , ncgp_solute if ( filestat /= 0 ) ncgp_solute = ncgp read ( line , fmt =* , iostat = filestat ) i , i , iuse_switch_atom if ( filestat /= 0 ) iuse_switch_atom = 1 !default to using sw. atoms write ( * , 140 ) ncgp_solute write ( * , 141 ) ncgp - ncgp_solute 140 format ( 'No. of solute chargegrps= ' , i10 ) 141 format ( 'No. of solvent chargegps= ' , i10 ) max_cgp = ncgp allocate ( cgp ( max_cgp ), stat = alloc_status ) call topo_check_alloc ( 'charge group list' ) k = 1 do i = 1 , ncgp read ( unit = u , fmt =* , err = 1000 ) n , cgp ( i )% iswitch cgp ( i )% first = k cgp ( i )% last = k + n - 1 read ( unit = u , fmt =* , err = 1000 ) ( cgpatom ( j ), j = cgp ( i )% first , cgp ( i )% last ) k = k + n end do if ( iuse_switch_atom == 0 ) then write ( * , 142 ) 'Any atoms' else write ( * , 142 ) 'Switching atoms' end if 142 format ( 'Charge group cut-off    : ' , a ) ! --> 11. Masses and van der Waals params ! ======================================= !read water atom types to temp. variables to avoid clearing default values read ( unit = u , fmt =* , err = 1000 ) natyps max_atyps = natyps allocate ( iaclib ( max_atyps ), SYBYL_atom_type ( max_atyps ), tac ( max_atyps ), & stat = alloc_status ) call topo_check_alloc ( 'atom type library' ) read ( unit = u , fmt =* , err = 1000 ) ivdw_rule write ( * , 162 ) ivdw_rule 162 format ( 'vdW  rule [ 1=G / 2=A ] = ' , i10 ) read ( u , '(a)' , err = 1000 ) line read ( line , * , err = 1000 ) el14_scale !first read what must be there !then try to read optional things read ( line , * , iostat = filestat ) el14_scale , coulomb_constant !set coulomb_constant to default if not present if ( filestat /= 0. . or . coulomb_constant <= 0 ) coulomb_constant = 33 2. write ( * , 164 ) el14_scale write ( * , 165 ) coulomb_constant 164 format ( 'El-static 1-4 damping   = ' , f10 . 3 ) 165 format ( 'Coulomb constant        = ' , f10 . 4 ) read ( unit = u , fmt =* , err = 1000 ) ! skip read ( unit = u , fmt =* , err = 1000 ) ( iaclib ( i )% mass , i = 1 , natyps ) do j = 1 , nljtyp read ( unit = u , fmt =* , err = 1000 ) ! skip read ( unit = u , fmt =* , err = 1000 ) ( iaclib ( i )% avdw ( j ), i = 1 , natyps ) read ( unit = u , fmt =* , err = 1000 ) ! skip read ( unit = u , fmt =* , err = 1000 ) ( iaclib ( i )% bvdw ( j ), i = 1 , natyps ) end do write ( * , 160 ) natyps 160 format ( 'No. of atom types       = ' , i10 ) read ( unit = u , fmt =* , err = 1000 ) nlj2 max_lj2 = nlj2 allocate ( lj2 ( nlj2 ), stat = alloc_status ) call topo_check_alloc ( 'vdw type 2 pair list' ) do i = 1 , nlj2 read ( unit = u , fmt =* , err = 1000 ) lj2 ( i )% i , lj2 ( i )% j end do write ( * , 161 ) nlj2 161 format ( 'No. of LJ type 2 pairs  = ' , i10 ) ! !       flag heavy atoms for various reasons ! nhyds = 0 do i = 1 , nat_pro if ( iaclib ( iac ( i ))% mass < 4.0 ) then ! lighter than He = H heavy ( i ) = . false . nhyds = nhyds + 1 else heavy ( i ) = . true . end if end do write ( * , 170 ) nat_pro - nhyds 170 format ( 'No. of heavy atoms      = ' , i10 ) ! --> 12. 1-4 neighbour and exclusion lists ! ========================================= read ( unit = u , fmt =* , err = 1000 ) n14nbrs write ( * , 180 ) n14nbrs 180 format ( 'No. of 1-4 neighbours   = ' , i10 ) allocate ( temp_list ( max_nbr_range , nat_solute ), stat = alloc_status ) if ( nat_solute > 0 ) then ! work-around to preserve file format ! read (unit=u,fmt='(80i1)', err=1000) ((list14(i,j),i=1,max_nbr_range),j=1,nat_solute) call topo_check_alloc ( 'temporary neighbor list' ) read ( unit = u , fmt = '(80i1)' , err = 1000 ) (( temp_list ( i , j ), i = 1 , max_nbr_range ), j = 1 , nat_solute ) do j = 1 , nat_solute do i = 1 , max_nbr_range list14 ( i , j ) = ( temp_list ( i , j ) . eq . 1 ) end do end do end if read ( unit = u , fmt =* , err = 1000 ) n14long write ( * , 200 ) n14long 200 format ( 'No. long-range 1-4 nbrs = ' , i10 ) max_14long = n14long allocate ( list14long ( 2 , max_14long ), stat = alloc_status ) call topo_check_alloc ( 'long-range neighbour list' ) do i = 1 , n14long read ( unit = u , fmt =* , err = 1000 ) ( list14long ( j , i ), j = 1 , 2 ) end do read ( unit = u , fmt =* , err = 1000 ) nexnbrs write ( * , 220 ) nexnbrs 220 format ( 'No. of nbor exclusions  = ' , i10 ) if ( nat_solute > 0 ) then read ( unit = u , fmt = '(80i1)' , err = 1000 ) (( temp_list ( i , j ), i = 1 , max_nbr_range ), j = 1 , nat_solute ) do j = 1 , nat_solute do i = 1 , max_nbr_range listex ( i , j ) = ( temp_list ( i , j ) . eq . 1 ) end do end do end if deallocate ( temp_list ) read ( unit = u , fmt =* , err = 1000 ) nexlong write ( * , 240 ) nexlong 240 format ( 'No. of long-range excls = ' , i10 ) max_exlong = nexlong allocate ( listexlong ( 2 , max_exlong ), stat = alloc_status ) call topo_check_alloc ( 'long-range exclusion list' ) do i = 1 , nexlong read ( unit = u , fmt =* , err = 1000 ) ( listexlong ( j , i ), j = 1 , 2 ) end do ! --- RESIDUE/MOLECULE BOOKKEEPING read ( u , '(a)' , err = 1000 ) line !Fix for inconsistent write/read of empty lists on SGI if ( line == '' ) read ( u , '(a)' , err = 1000 ) line READ ( line , fmt =* , err = 1000 ) nres !attempt to read #solute residues read ( line , * , iostat = filestat ) nres , nres_solute if ( filestat . ne . 0 ) then nres_solute = nres ! set # nolute residues to total # end if allocate ( res ( nres ), stat = alloc_status ) call topo_check_alloc ( 'residue list' ) if ( nres > 0 ) READ ( unit = u , fmt =* , err = 1000 ) res ( 1 : nres )% start READ ( unit = u , fmt =* , err = 1000 ) if ( nres > 0 ) then do i = 0 , int (( nres + 15 ) / 16 ) - 1 READ ( unit = u , fmt = '(16(a4,1x))' , err = 1000 ) ( res ( i * 16 + j )% name , j = 1 , min ( 16 , nres - i * 16 )) end do endif WRITE ( * , '(a,i10)' ) 'No. of residues         = ' , nres if ( nres_solute < nres ) then WRITE ( * , '(a,i10)' ) 'No of solute residues   = ' , nres_solute end if READ ( unit = u , fmt =* , err = 1000 ) nmol allocate ( istart_mol ( nmol + 1 ), stat = alloc_status ) call topo_check_alloc ( 'molecule list' ) if ( nmol > 0 ) READ ( unit = u , fmt =* , err = 1000 )( istart_mol ( i ), i = 1 , nmol ) WRITE ( * , '(a,i10)' ) 'No. of molecules        = ' , nmol read ( unit = u , fmt =* , iostat = filestat ) if ( natyps > 0 ) then do i = 0 , int (( natyps + 7 ) / 8 ) - 1 read ( unit = u , fmt = '(8(a8,1x))' , err = 900 , end = 900 ) ( tac ( i * 8 + j ), j = 1 , min ( 8 , natyps - i * 8 )) end do endif if ( filestat /= 0 ) then if ( version > 3.5 ) then goto 1000 !its an error elseif ( require_version > 3.5 ) then goto 1100 else goto 900 end if end if WRITE ( * , '(a,i10)' ) 'Atom type names         = ' , natyps read ( unit = u , fmt =* , iostat = filestat ) if ( natyps > 0 ) then do i = 0 , int (( natyps + 12 ) / 13 ) - 1 read ( unit = u , fmt = '(13(a5,1x))' , iostat = filestat ) & ( SYBYL_atom_type ( i * 13 + j ), j = 1 , min ( 13 , natyps - i * 13 )) end do endif if ( filestat /= 0 ) then if ( version > 3.5 ) then goto 1000 !its an error elseif ( require_version > 3.5 ) then goto 1100 else goto 900 end if end if WRITE ( * , '(a,i10)' ) 'SYBYL atom types        = ' , natyps if ( version < 4 ) then if ( require_version >= 4 ) then goto 1100 else goto 900 end if end if read ( unit = u , fmt =* , err = 1000 ) solvent_type !******PWadded input reading 2001-10-10 read ( u , '(a)' , err = 1000 ) line read ( line , * , err = 1000 ) boundary_type if ( boundary_type == 'PBC' ) then use_PBC = . true . write ( * , '(a)' ) 'Boundary: periodic box' read ( unit = u , fmt =* , err = 1000 ) boxlength (:) write ( * , '(a,3f10.3)' ) 'Box size                = ' , boxlength (:) read ( unit = u , fmt =* , err = 1000 ) boxcentre (:) write ( * , '(a,3f10.3)' ) 'Box centre              = ' , boxcentre (:) excl (:) = . false . shell (:) = . false . else use_PBC = . false . write ( * , '(a)' ) 'Boundary: sphere' !For backward compatibility the shell radius from the topology can be used. if ( version < 5.01 ) then print * , 'Using shell radius from topology < v5.01! ' read ( line , * , err = 1000 ) rexcl_o , rexcl_i , rwat write ( * , '(a,f10.3)' ) 'Exclusion radius        = ' , rexcl_o write ( * , '(a,f10.3)' ) 'Restrained shell radius = ' , rexcl_i write ( * , '(a,f10.3)' ) 'Eff. solvent radius     = ' , rwat else read ( line , * , err = 1000 ) rexcl_o , rwat write ( * , '(a,f10.3)' ) 'Exclusion radius        = ' , rexcl_o write ( * , '(a,f10.3)' ) 'Eff. solvent radius     = ' , rwat end if read ( unit = u , fmt =* , err = 1000 ) xpcent (:) write ( * , '(a,3f10.3)' ) 'Solute centre           = ' , xpcent (:) read ( unit = u , fmt =* , err = 1000 ) xwcent (:) write ( * , '(a,3f10.3)' ) 'Solvent centre          = ' , xwcent (:) excl (:) = . false . shell (:) = . false . read ( unit = u , fmt =* , err = 1000 , end = 1000 ) nexats , nexwat read ( unit = u , fmt = '(80l1)' ) excl ( 1 : nat_pro ) WRITE ( * , '(a,i10)' ) 'No. of excluded atoms   = ' , nexats endif 900 WRITE ( * , '(a,/)' ) 'Molecular topology read successfully.' topo_read = . true . return 1000 write ( * , 1001 ) 1001 format ( '>>>>> ERROR: Could not read topology file.' ) return 1100 write ( * , 1101 ) version , require_version 1101 format ( '>>>>> ERROR: Incompatible topology version ' , f5 . 2 , & ' found. Version >= ' , f5 . 2 , ' required.' ) return end function topo_read !---------------------------------------------------------------------- subroutine topo_save ( name ) !arguments character ( * ) :: name !locals integer :: i , j , u , ig , si integer ( 1 ), allocatable :: temp_list (:,:) real :: crgtot 10 format ( a , t29 , ': ' ) 20 format ( i6 ) 30 format ( f6 . 2 ) u = freefile () !get an unused unit number open ( unit = u , file = name , status = 'unknown' , form = 'formatted' , & action = 'write' , err = 100 ) call centered_heading ( 'Writing topology file' , '-' ) !---  HEADER 2 format ( a , t12 , a ) 4 format ( a , t12 , i1 ) write ( u , '(a)' ) 'Q topology file' if ( title > '' ) write ( u , 2 ) 'TITLE' , trim ( title ) write ( u , 2 ) 'DATE' , trim ( creation_date ) write ( u , '(a,t12,f5.2)' ) 'VERSION' , MODULE_VERSION if ( pdb_file > '' ) write ( u , 2 ) 'PDB_FILE' , trim ( pdb_file ) if ( lib_files > '' ) write ( u , 2 ) 'LIB_FILES' , trim ( lib_files ) if ( forcefield > '' ) write ( u , 2 ) 'FORCEFIELD' , trim ( forcefield ) write ( u , 4 ) 'FF_TYPE' , ff_type write ( u , 2 ) 'PRM_FILE' , trim ( prm_file ) write ( u , 2 ) 'END' , 'of header' write ( * , 10 , advance = 'no' ) 'solute atoms' write ( * , 20 ) nat_solute write ( * , 10 , advance = 'no' ) 'solvent atoms' write ( * , 20 ) nat_pro - nat_solute ! --- NAT_PRO / COORDINATES write ( * , 10 , advance = 'no' ) 'coordinates' write ( u , '(2i8,a)' ) nat_pro , nat_solute , & ' = Total no. of atoms, no. of solute atoms. Coordinates: (2*3 per line)' if ( nat_pro > 0 ) write ( u , '(2(3(f9.3,1x),1x))' ) ( xtop ( si ), si = 1 , 3 * nat_pro ) write ( * , 20 ) 3 * nat_pro ! --- INTEGER ATOM CODES write ( * , 10 , advance = 'no' ) 'integer atom codes' write ( u , '(i8,a)' ) nat_pro , ' = No. of integer atom codes. iac''s: ' if ( nat_pro > 0 ) write ( u , '(16(i4,1x))' ) iac ( 1 : nat_pro ) write ( * , 20 ) nat_pro ! --- BONDS write ( * , 10 , advance = 'no' ) 'solute bonds' write ( u , '(2i8,a)' ) nbonds , nbonds_solute , & ' = No. of bonds, no. of solute bonds. i - j - icode: (5 per line)' if ( nbonds > 0 ) write ( u , '(5(i5,1x,i5,1x,i3,1x))' ) ( bnd ( si ), si = 1 , nbonds ) write ( * , 20 ) nbonds_solute write ( * , 10 , advance = 'no' ) 'solvent bonds' write ( * , 20 ) nbonds - nbonds_solute write ( * , 10 , advance = 'no' ) 'bond parameters' write ( u , '(i8,a)' ) nbndcod , ' = No. of bond codes. Parameters: ' DO i = 1 , nbndcod write ( u , '(i5,f9.3,1x,f10.4,1x,a2)' ) i , bondlib ( i ), SYBYL_bond_type ( i ) enddo write ( * , 20 ) nbndcod ! --- ANGLES write ( * , 10 , advance = 'no' ) 'solute angles' write ( u , '(2i8,a)' ) nangles , nangles_solute , & ' = No. of angles, no. of solute angles. i - j - k - icode: (3 per line)' if ( nangles > 0 ) write ( u , '(3(i5,1x,i5,1x,i5,1x,i3,1x))' ) ( ang ( si ), si = 1 , nangles ) write ( * , 20 ) nangles_solute write ( * , 10 , advance = 'no' ) 'solvent angles' write ( * , 20 ) nangles - nangles_solute write ( * , 10 , advance = 'no' ) 'angle parameters' write ( u , '(i8,a)' ) nangcod , ' = No. of angle codes. Parameters:' DO i = 1 , nangcod write ( u , '(i5,f9.3,1x,f9.3,1x,f9.3,1x,f11.5)' ) i , anglib ( i ) enddo write ( * , 20 ) nangcod ! --- TORSIONS write ( * , 10 , advance = 'no' ) 'torsions' write ( u , '(2i8,a)' ) ntors , ntors_solute , & ' = No. of torsions, solute torsions. i - j - k - l - icode: (2 per line)' if ( ntors > 0 ) write ( u , '(2(4(i5,1x),i3,1x))' ) ( tor ( si ), si = 1 , ntors ) write ( * , 20 ) ntors write ( * , 10 , advance = 'no' ) 'torsion parameters' write ( u , '(i8,a)' ) ntorcod , ' = No. of torsion codes. Parameters:' DO i = 1 , ntorcod !%paths is a real but we write it as an integer for compatibility write ( u , '(i5,3(f9.3,1x),i5 )' ) i , & torlib ( i )% fk , torlib ( i )% rmult , torlib ( i )% deltor , int ( torlib ( i )% paths ) enddo write ( * , 20 ) ntorcod ! --- IMPROPERS write ( * , 10 , advance = 'no' ) 'impropers' write ( u , '(2i8,a)' ) nimps , nimps_solute , & ' = No. of impropers, solute impr. i - j - k - l - icode: (2 per line)' if ( nimps > 0 ) write ( u , '(2(4(i5,1x),i3,1x))' ) imp ( 1 : nimps ) write ( * , 20 ) nimps write ( * , 10 , advance = 'no' ) 'improper parameters' write ( u , '(2i8,a)' ) nimpcod , imp_type , & ' = No. of improper codes, type (1=harmonic,2=periodic). Parameters:' DO i = 1 , nimpcod write ( u , '(i5,f10.3,1x,f10.3)' ) i , implib ( i ) enddo write ( * , 20 ) nimpcod ! --- CHARGES write ( * , 10 , advance = 'no' ) 'charges' write ( u , '(i8,a)' ) nat_pro , ' = No. of atomic charges' if ( nat_pro > 0 ) write ( u , '(10(f7.4,1x))' ) crg ( 1 : nat_pro ) write ( * , 20 ) nat_pro crgtot = 0.0 if ( use_PBC ) then do i = 1 , nat_solute crgtot = crgtot + crg ( i ) end do write ( * , 10 , advance = 'no' ) 'total charge of system' else do i = 1 , nat_solute if (. not . excl ( i )) crgtot = crgtot + crg ( i ) end do write ( * , 10 , advance = 'no' ) 'total charge of not excluded' end if write ( * , 30 ) crgtot ! --- CHARGE GROUPS write ( * , 10 , advance = 'no' ) 'charge groups' write ( u , '(3i8,a)' ) ncgp , ncgp_solute , iuse_switch_atom , & ' = No. of charge groups, no of solvent cgps, switch atoms flag. nat_cgp, iswitch / atom list: ' DO ig = 1 , ncgp write ( u , '(i5,1x,i5)' ) cgp ( ig )% last - cgp ( ig )% first + 1 , cgp ( ig )% iswitch write ( u , '(13(i5,1x))' ) cgpatom ( cgp ( ig )% first : cgp ( ig )% last ) enddo write ( * , 20 ) ncgp ! --- ATOM TYPES write ( * , 10 , advance = 'no' ) 'atom type parameters' write ( u , '(i8,a)' ) max_atyps , ' = No. of atom types' write ( u , '(i8,a)' ) ivdw_rule , & ' = vdW combination rule (1 = Geom. / 2 = Arit.)' write ( u , '(f8.5,f9.4,a)' ) el14_scale , coulomb_constant , & ' = Electrostatic 1-4 scaling factor and  Coulomb constant' write ( u , '(a)' ) 'Masses: ' write ( u , '(10(f7.3,1x))' ) ( iaclib ( i )% mass , i = 1 , max_atyps ) IF ( ivdw_rule == VDW_GEOMETRIC ) then write ( u , '(a)' ) 'sqrt (Aii) normal:' write ( u , '(8(f8.2,1x))' ) ( iaclib ( i )% avdw ( 1 ), i = 1 , max_atyps ) write ( u , '(a)' ) 'sqrt (Bii) normal:' write ( u , '(8(f8.2,1x))' ) ( iaclib ( i )% bvdw ( 1 ), i = 1 , max_atyps ) write ( u , '(a)' ) 'sqrt (Aii) polar:' write ( u , '(8(f8.2,1x))' ) ( iaclib ( i )% avdw ( 2 ), i = 1 , max_atyps ) write ( u , '(a)' ) 'sqrt (Bii) polar:' write ( u , '(8(f8.2,1x))' ) ( iaclib ( i )% bvdw ( 2 ), i = 1 , max_atyps ) write ( u , '(a)' ) 'sqrt (Aii) 1-4:' write ( u , '(8(f8.2,1x))' ) ( iaclib ( i )% avdw ( 3 ), i = 1 , max_atyps ) write ( u , '(a)' ) 'sqrt (Bii) 1-4:' write ( u , '(8(f8.2,1x))' ) ( iaclib ( i )% bvdw ( 3 ), i = 1 , max_atyps ) elseif ( ivdw_rule == VDW_ARITHMETIC ) then write ( u , '(a)' ) 'R* normal:' write ( u , '(8(f7.4,1x))' ) ( iaclib ( i )% avdw ( 1 ), i = 1 , max_atyps ) write ( u , '(a)' ) 'epsilon normal:' write ( u , '(8(f10.7,1x))' ) ( iaclib ( i )% bvdw ( 1 ), i = 1 , max_atyps ) write ( u , '(a)' ) 'R* polar:' write ( u , '(8(f8.4,1x))' ) ( iaclib ( i )% avdw ( 2 ), i = 1 , max_atyps ) write ( u , '(a)' ) 'epsilon polar:' write ( u , '(8(f10.7,1x))' ) ( iaclib ( i )% bvdw ( 2 ), i = 1 , max_atyps ) write ( u , '(a)' ) 'R* 1-4:' write ( u , '(8(f8.4,1x))' ) ( iaclib ( i )% avdw ( 3 ), i = 1 , max_atyps ) write ( u , '(a)' ) 'epsilon 1-4:' write ( u , '(8(f10.7,1x))' ) ( iaclib ( i )% bvdw ( 3 ), i = 1 , max_atyps ) ENDIF write ( * , 20 ) max_atyps write ( * , 10 , advance = 'no' ) 'polar LJ pairs' write ( u , '(i8,a)' ) nlj2 , ' = No. of type-2 vdW interactions. pairs: ' DO i = 1 , nlj2 write ( u , '(i4,1x,i4)' ) lj2 ( i ) enddo write ( * , 20 ) nlj2 ! --- 1-4 NEIGHBOUR LIST write ( * , 10 , advance = 'no' ) 'neighbour list' write ( u , '(i8,a)' ) n14nbrs , ' = No. of 1-4 neighbours. nborlist (range=max_nbr_range): ' ! work-around to preserve file format !       write(u, '(80i1)') list14(1:max_nbr_range, 1:nat_solute) allocate ( temp_list ( max_nbr_range , nat_solute ), stat = alloc_status ) call topo_check_alloc ( 'temporary neighbor list' ) temp_list (:,:) = 0 do j = 1 , nat_solute do i = 1 , max_nbr_range if ( list14 ( i , j )) temp_list ( i , j ) = 1 end do end do if ( nat_solute > 0 ) write ( u , '(80i1)' ) temp_list ( 1 : max_nbr_range , 1 : nat_solute ) write ( * , 20 ) n14nbrs write ( * , 10 , advance = 'no' ) 'long-range neighbour list' write ( u , '(i8,a)' ) n14long , & ' = No. of long 1-4 nbrs (>max_nbr_range). pairlist: ' DO i = 1 , n14long write ( u , '(i5,1x,i5)' ) list14long ( 1 : 2 , i ) enddo write ( * , 20 ) n14long ! --- EXCLUSION NEIGHBOUR LIST write ( * , 10 , advance = 'no' ) 'neighbour exclusion list' write ( u , '(i8,a)' ) nexnbrs , & ' = No. of exclusions. exclusion list (range=max_nbr_range): ' ! work-around to preserve file format !       write(u, '(80i1)') listex(1:max_nbr_range, 1:nat_solute) temp_list (:,:) = 0 do j = 1 , nat_solute do i = 1 , max_nbr_range if ( listex ( i , j )) temp_list ( i , j ) = 1 end do end do if ( nat_solute > 0 ) write ( u , '(80i1)' ) temp_list ( 1 : max_nbr_range , 1 : nat_solute ) deallocate ( temp_list ) write ( * , 20 ) nexnbrs write ( * , 10 , advance = 'no' ) 'long-range exclusions' write ( u , '(i8,a)' ) nexlong , & ' = No. of long exclusions (>max_nbr_range). pairlist: ' if ( nexlong > 0 ) write ( u , '(i5,1x,i5)' ) listexlong ( 1 : 2 , 1 : nexlong ) write ( * , 20 ) nexlong ! --- RESIDUE/MOLECULE BOOKKEEPING write ( * , 10 , advance = 'no' ) 'residues' if ( nres_solute < nres ) then write ( u , '(2i8,a)' ) nres , nres_solute , ' = No. of residues, No of solute residues. start atoms: ' else write ( u , '(i8,a)' ) nres , ' = No. of residues. start atoms: ' end if if ( nres > 0 ) write ( u , '(13(i5,1x))' ) res ( 1 : nres )% start write ( u , '(a)' ) 'Sequence: ' if ( nres > 0 ) write ( u , '(16(a4,1x))' ) res ( 1 : nres )% name write ( * , 20 ) nres write ( * , 10 , advance = 'no' ) 'molecules' write ( u , '(i8,a)' ) nmol , & ' = No. of separate molecules. start atoms:' if ( nmol > 0 ) write ( u , '(13(i5,1x))' ) istart_mol ( 1 : nmol ) write ( * , 20 ) nmol write ( * , 10 , advance = 'no' ) 'Atom type names' write ( u , '(i8,a)' ) max_atyps , & ' = No. of atom types:' if ( max_atyps > 0 ) write ( u , '(8(a8,1x))' ) tac ( 1 : max_atyps ) write ( * , 20 ) max_atyps write ( * , 10 , advance = 'no' ) 'SYBYL type information' write ( u , '(i8,a)' ) max_atyps , & ' = No. of SYBYL atom types:' if ( max_atyps > 0 ) write ( u , '(13(a5,1x))' ) SYBYL_atom_type ( 1 : max_atyps ) write ( * , 20 ) max_atyps !solvent type & atom types write ( u , '(i8,a)' ) solvent_type , & ' = solvent type (0=SPC,1=3-atom,2=general)' !boundary !******PWedited this part if ( use_PBC ) then !use periodic box write ( u , '(a8,a)' ) 'PBC' , ' = kind of boundary' !PBC-parameters write ( u , '(3f8.3, a)' ) boxlength (:), ' = Size of box, x y z' write ( u , '(3f8.3, a)' ) boxcentre (:), ' = Centre coordinate of box' else !use simulation sphere !radii & centres write ( u , '(2f8.3,a)' ) rexcl_o , rwat , & ' = Exclusion, solvent radii' write ( u , '(3f8.3,a)' ) xpcent (:), ' = Solute centre' write ( u , '(3f8.3,a)' ) xwcent (:), ' = Solvent centre' !exluded atoms write ( * , 10 , advance = 'no' ) 'excluded atom list' write ( u , '(2i8,a)' ) nexats , nexwat , & ' = No. of excluded atoms (incl. water), no. of excluded waters' write ( u , fmt = '(80l1)' ) excl ( 1 : nat_pro ) write ( * , 20 ) nexats end if close ( u ) write ( * , * ) return 100 write ( * , * ) 'ERROR: Failed to open topology file ' , trim ( name ) end subroutine topo_save !---------------------------------------------------------------------- end module topo","tags":"","loc":"sourcefile/topo.f90.html","title":"topo.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: july 13, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! !  (c) 2000 Uppsala Molekylmekaniska HB, Uppsala, Sweden                       ! !  trj.f90                                                                     ! !  by John Marelius                                                            ! !  Q trajectory data, access and DCD format I/O                                ! !------------------------------------------------------------------------------! module trj use atom_mask use misc implicit none character ( * ), private , parameter :: MODULE_VERSION = '5.7' character ( * ), private , parameter :: MODULE_DATE = '2015-02-22' type , private :: REC1 sequence character ( len = 4 ) :: trj_type integer ( 4 ) :: n_frames , n_steps_before , interval , n_steps integer ( 4 ) :: interval_velcheck , unused6 , unused7 , n_degf integer ( 4 ) :: n_fixed , unused10 , const_p , unused12 integer ( 4 ) :: unused13 , unused14 , unused15 , unused16 integer ( 4 ) :: unused17 , unused18 , unused19 , charmm_version end type REC1 type ( REC1 ), private :: r1 character ( len = 80 ), private :: topology integer , private :: mask_rows integer , parameter :: max_mask_rows = 20 character ( len = 80 ) :: mask_row ( max_mask_rows ) integer , private :: lun = 0 integer , private :: current_frame = 0 !mask integer , private :: ncoords real ( 4 ), private , allocatable :: xmasked (:) type ( MASK_TYPE ), private :: mask contains subroutine trj_startup mask_rows = 0 call mask_startup end subroutine trj_startup subroutine trj_shutdown call trj_close call mask_shutdown end subroutine trj_shutdown subroutine trj_initialize ( frames , steps_before , interval , steps , degf , topfile ) !arguments integer , intent ( in ) :: frames , steps_before , interval , steps integer , intent ( in ) :: degf character ( * ), intent ( in ) :: topfile !clear file number lun = 0 !set defaults r1 % trj_type = 'CORD' !coordinate trajectory (not velocity) r1 % INTERVAL_VELCHECK = 0 r1 % CONST_P = 0 r1 % CHARMM_VERSION = 0 r1 % n_fixed = 0 !required by VMD program !set values r1 % N_FRAMES = frames r1 % N_STEPS_BEFORE = steps_before r1 % INTERVAL = interval r1 % N_STEPS = steps r1 % N_DEGF = degf topology = topfile call mask_initialize ( mask ) end subroutine trj_initialize integer function trj_add ( line ) !arguments character ( * ) :: line if ( lun /= 0 ) then !file open - can't add now write ( * , 910 ) 910 format ( '>>>>> ERROR: Trajectory file open, cannot add atoms to mask' ) trj_add = 0 elseif ( mask_rows < max_mask_rows ) then mask_rows = mask_rows + 1 mask_row ( mask_rows ) = line trj_add = mask_add ( mask , line ) else write ( * , 900 ) max_mask_rows 900 format ( '>>>>> ERROR: Too many trajectory atom mask rows (max' , i3 , ').' ) trj_add = 0 end if end function trj_add logical function trj_store_mask ( line ) !arguments character ( * ) :: line if ( mask_rows < max_mask_rows ) then mask_rows = mask_rows + 1 mask_row ( mask_rows ) = line trj_store_mask = . true . else write ( * , 900 ) max_mask_rows 900 format ( '>>>>> ERROR: Too many trajectory atom mask rows (max' , i3 , ').' ) trj_store_mask = . false . end if end function trj_store_mask integer function trj_commit_mask () !locals integer :: row if ( lun /= 0 ) then !file open - can't add now write ( * , 910 ) 910 format ( '>>>>> ERROR: Trajectory file open, cannot add atoms to mask' ) else do row = 1 , mask_rows trj_commit_mask = mask_add ( mask , mask_row ( row )) end do end if trj_commit_mask = mask % included end function trj_commit_mask integer function trj_count () trj_count = mask % included end function trj_count logical function trj_create ( filename , append ) !arguments character ( * ) :: filename logical , optional :: append !locals integer :: filestat character ( len = 10 ) :: writemode character ( len = 80 ) :: titlerow !allocated masked coordinate array ncoords = 3 * mask % included allocate ( xmasked ( ncoords )) titlerow = 'Q DCD trajectory version ' // MODULE_VERSION writemode = 'REWIND' if ( present ( append )) then if ( append ) writemode = 'APPEND' end if lun = freefile () open ( unit = lun , file = filename , status = 'unknown' , form = 'unformatted' , action = 'write' ,& position = writemode , err = 900 ) if ( writemode /= 'APPEND' ) then !write the first 3 DCD format records write ( lun , err = 920 ) r1 write ( lun , err = 920 ) 2 + mask_rows , titlerow , topology , mask_row ( 1 : mask_rows ) write ( lun , err = 920 ) int ( mask % included , 4 ) end if trj_create = . true . return !error handling !open error 900 write ( * , 910 ) trim ( filename ) 910 format ( '>>>>> ERROR: failed to open trajectory ' , a ) trj_create = . false . return !write header error 920 write ( * , 930 ) 930 format ( '>>>>> ERROR: failed to write trajectory header.' ) trj_create = . false . return end function trj_create !****************************************************** !Write real(4) coords to trajectory. Writes only ! atoms in current mask. !****************************************************** logical function trj_write ( x ) !arguments real ( 8 ) :: x (:) !extract coordinates call mask_get ( mask , x , xmasked ) !write x record write ( lun , err = 900 ) xmasked ( 1 : ncoords : 3 ) !write y record write ( lun , err = 900 ) xmasked ( 2 : ncoords : 3 ) !write z record write ( lun , err = 900 ) xmasked ( 3 : ncoords : 3 ) trj_write = . true . return !error handling 900 trj_write = . false . end function trj_write !****************************************************** ! Read a frame from trajectory file and return coordinates ! associated with atomnumbers in topology. !****************************************************** logical function trj_read ( x ) !arguments real ( 8 ) :: x (:) !read x record to temp variable xmasked read ( lun , err = 900 , end = 900 ) xmasked ( 1 : ncoords : 3 ) !read y record read ( lun , err = 900 , end = 900 ) xmasked ( 2 : ncoords : 3 ) !read z record read ( lun , err = 900 , end = 900 ) xmasked ( 3 : ncoords : 3 ) !assign masked coordinates to right atom in topology call mask_put ( mask , x , xmasked ) trj_read = . true . current_frame = current_frame + 1 return !error handling 900 trj_read = . false . end function trj_read !****************************************************** ! Read a frame from trajectory file containing masked atoms, ! return only masked coordinates. !REAL(4)! !****************************************************** logical function trj_read_masked ( x ) !arguments real ( 4 ) :: x (:) !read x record to temp variable xmasked read ( lun , err = 900 , end = 900 ) x ( 1 : ncoords : 3 ) !read y record read ( lun , err = 900 , end = 900 ) x ( 2 : ncoords : 3 ) !read z record read ( lun , err = 900 , end = 900 ) x ( 3 : ncoords : 3 ) trj_read_masked = . true . current_frame = current_frame + 1 return !error handling 900 trj_read_masked = . false . end function trj_read_masked !****************************************************** logical function trj_seek ( frame ) !arguments integer :: frame !locals integer :: i !optionally fast-forward to selected frame if ( frame > r1 % N_FRAMES . or . frame < 1 ) then write ( * , 962 ) frame 962 format ( '>>>>> ERROR: Frame' , i6 , ' does not exist.' ) close ( lun ) trj_seek = . false . elseif ( frame > current_frame ) then do i = current_frame + 1 , frame !read x y and z records read ( lun , err = 980 ) read ( lun , err = 980 ) read ( lun , err = 980 ) end do current_frame = frame trj_seek = . true . elseif ( frame < current_frame ) then do i = current_frame , frame + 1 , - 1 !read x y and z records backspace ( lun , err = 980 ) backspace ( lun , err = 980 ) backspace ( lun , err = 980 ) end do current_frame = frame trj_seek = . true . else !already correctly positiones trj_seek = . true . end if return 980 write ( * , 990 ) i , frame 990 format ( '>>>>> ERROR: Read error at frame' , i6 , ' while looking for frame' , i6 ) trj_seek = . false . return end function trj_seek subroutine trj_close !locals logical :: is_open inquire ( lun , opened = is_open ) if ( is_open ) close ( lun ) lun = 0 if ( allocated ( xmasked )) deallocate ( xmasked ) call mask_finalize ( mask ) ncoords = 0 current_frame = 0 end subroutine trj_close !*********************************************** logical function trj_open ( filename ) !arguments character ( * ) :: filename !locals character ( len = 80 ) :: titlerow integer :: atoms integer :: i !open file lun = freefile () open ( unit = lun , file = filename , status = 'old' , form = 'unformatted' , action = 'read' ,& err = 900 ) !read header read ( lun , err = 920 ) r1 if ( r1 % trj_type /= 'CORD' ) then write ( * , 940 ) 940 format ( '>>>>> ERROR: Not a DCD Coordinate trajectory.' ) close ( lun ) trj_open = . false . return end if !       write(*,456) r1%n_frames 456 format ( i10 ) read ( lun , err = 920 ) mask_rows , titlerow , topology , mask_row ( 1 : mask_rows - 2 ) if ( titlerow ( 1 : 16 ) /= 'Q DCD trajectory' ) then write ( * , 941 ) 941 format ( '>>>>> ERROR: Not a Q DCD trajectory.' ) close ( lun ) trj_open = . false . return end if mask_rows = mask_rows - 2 read ( lun , err = 920 ) atoms !re-create mask call mask_initialize ( mask ) if ( allocated ( xmasked )) deallocate ( xmasked ) trj_open = . true . do i = 1 , mask_rows if ( mask_add ( mask , mask_row ( i )) == 0 ) then write ( * , 950 ) trim ( mask_row ( i )) end if end do 950 format ( '>>> WARNING: no atoms in mask ' , a ) if ( mask % included /= atoms ) then write ( * , 960 ) atoms , mask % included write ( * , * ) 'Ignored' !               close(lun) !               trj_open = .false. !               return end if 960 format ( '>>>>> ERROR: Different number of atoms in mask and trajectory' , / ,& i6 , ' atoms in trajectory,' , i6 , ' atoms in mask.' ) !allocated masked coordinate array ncoords = 3 * atoms allocate ( xmasked ( ncoords )) current_frame = 1 return !error handling !open error 900 write ( * , 910 ) trim ( filename ) 910 format ( '>>>>> ERROR: failed to open trajectory ' , a ) trj_open = . false . return !read header error 920 write ( * , 930 ) 930 format ( '>>>>> ERROR: failed to read trajectory header.' ) trj_open = . false . close ( lun ) return end function trj_open integer function trj_intersection ( m ) !arguments type ( MASK_TYPE ) :: m trj_intersection = count ( m % mask . and . mask % mask ) end function trj_intersection subroutine trj_clone_mask ( m ) !arguments type ( MASK_TYPE ) :: m if ( size ( m % mask ) == size ( mask % mask )) then m = mask end if end subroutine trj_clone_mask integer function trj_get_ncoords () trj_get_ncoords = ncoords end function trj_get_ncoords end module trj","tags":"","loc":"sourcefile/trj.f90.html","title":"trj.f90 – Fortran Program"},{"text":"Source Code !------------------------------------------------------------------------------! !  Q v.5.7 makefile                                                            ! !  Code authors: Johan Aqvist, Martin Almlof, Martin Ander, Jens Carlson,      ! !  Isabella Feierberg, Peter Hanspers, Anders Kaplan, Karin Kolmodin,          ! !  Kajsa Ljunjberg, John Marelius, Martin Nervall                              ! !  Maintainers: Beat Amrein, Alexandre Barrozo, Paul Bauer, Mauricio Esguerra, ! !  Irek Szeler                                                                 ! !  latest update: November 22, 2015                                                ! !------------------------------------------------------------------------------! !------------------------------------------------------------------------------! ! (c) 2015 Uppsala Molekylmekaniska HB, Uppsala, Sweden ! version.f90 ! initial date: 2015 ! by Ireneusz Szeler ! q version and help print info !------------------------------------------------------------------------------! module version implicit none contains subroutine version_check ( q_program , q_version , q_date , q_suffix ) ! arguments character ( * ) :: q_program character ( * ) :: q_version character ( * ) :: q_date character ( * ) :: q_suffix character ( len = 32 ) :: arg ! local logical :: fin integer :: i integer :: count integer :: datum ( 8 ) character ( 200 ) :: flag !  if (nodeid .eq. 0) then fin = . false . count = command_argument_count () if ( count . gt . 0 ) then call getarg ( 1 , flag ) call lowcase ( flag ) if ( flag . eq . '-v' . or . flag . eq . '-version' . or . flag . eq . '--version' ) fin = . true . end if ! start-of-header write ( * , '(80a)' ) ( '-' , i = 1 , 80 ) if ( q_program . eq . 'qdyn' ) then #if defined (dum) write ( * , '(a,a,a)' ) 'qdum input checker version ' , trim ( q_version ), ' initializing' #elif defined(eval) write ( * , '(a,a,a)' ) 'qdyn evaluation version ' , trim ( q_version ), ' initializing' write ( * , '(a)' ) 'This version is for evaluation purposes only.' write ( * , '(a)' ) 'Optimizations are disabled - runs at <20% of maximum speed.' #endif end if call date_and_time ( values = datum ) write ( * , 130 ) datum ( 1 ), datum ( 2 ), datum ( 3 ) write ( * , 140 ) datum ( 5 ), datum ( 6 ), datum ( 7 ) 130 format ( 'Program run date = ' , i4 , '-' , i2 , '-' , i2 ) 140 format ( 'Program run time = ' , i2 , ':' , i2 , ':' , i2 ) !  call version_print(q_program, q_version, q_date, q_suffix) call lowcase ( q_program ) if ( flag . eq . '-h' . or . flag . eq . '-help' . or . flag . eq . '--help' ) then fin = . true . write ( * , * ) write ( * , '(a,a)' ) trim ( q_program ), ' help information' select case ( q_program ) case ( 'qdyn' ) write ( * , * ) write ( * , '(a)' ) 'To run calculations use: ' write ( * , '(a,a,a)' ) '    ' , trim ( q_program ), '5 inputfile.inp > output.file' write ( * , '(a)' ) ' or for parallel version' write ( * , '(a,a,a)' ) '    mpienvironmment ' , trim ( q_program ), '5p inputfile.inp > output.file' write ( * , * ) write ( * , '(a)' ) 'where:' write ( * , '(a)' ) 'mpienvironment - e.q. mpirun -n 4, for more info check cluster information ' write ( * , * ) case ( 'qfep' ) write ( * , * ) write ( * , '(a,a)' ) 'You are running program: ' , trim ( q_program ) write ( * , * ) case ( 'qprep' ) write ( * , * ) write ( * , '(a,a)' ) 'You are running program: ' , trim ( q_program ) write ( * , * ) case ( 'qcalc' ) write ( * , * ) write ( * , '(a,a)' ) 'You are running program: ' , trim ( q_program ) write ( * , * ) case default write ( * , * ) write ( * , '(a)' ) 'Is this a new program added to Q?' write ( * , * ) end select end if if ( fin ) stop select case ( q_program ) case ( 'qdyn' ) write ( * , * ) case ( 'qfep' ) write ( * , * ) write ( * , '(a,a)' ) 'Welcome to: ' , trim ( q_program ) write ( * , '(a,a)' ) 'Latest changes in the source code: ' , trim ( q_date ) write ( * , * ) case ( 'qprep' ) write ( * , * ) write ( * , '(a,a)' ) 'Welcome to: ' , trim ( q_program ) write ( * , '(a,a)' ) 'Latest changes in the source code: ' , trim ( q_date ) write ( * , * ) case ( 'qcalc' ) write ( * , * ) write ( * , '(a,a)' ) 'Welcome to: ' , trim ( q_program ) write ( * , '(a,a)' ) 'Latest changes in the source code: ' , trim ( q_date ) write ( * , * ) case default write ( * , * ) write ( * , '(a)' ) 'Welcome to ...' write ( * , * ) end select !  end if ! node .eq. 0 end subroutine version_check elemental subroutine lowcase ( word ) character ( * ), intent ( in out ) :: word integer :: i , ic , nlen nlen = len ( word ) do i = 1 , nlen ic = ichar ( word ( i : i )) if ( ic >= 65 . and . ic < 90 ) word ( i : i ) = char ( ic + 32 ) end do end subroutine lowcase subroutine version_print ( q_program , q_version , q_date , q_suffix ) ! arguments character ( * ) :: q_program character ( * ) :: q_version character ( * ) :: q_date character ( * ) :: q_suffix ! local integer :: i integer :: datum ( 8 ) ! start-of-header write ( * , * ) write ( * , '(a)' ) 'Build and version information' write ( * , * ) !  write (*,'(79a)') ('#',i=1,79) if ( q_program . eq . 'qdyn' ) then #if defined (dum) write ( * , '(a,a,a)' ) 'qdum input checker version ' , trim ( q_version ), ' initializing' #elif defined(eval) write ( * , '(a,a,a)' ) 'qdyn evaluation version ' , trim ( q_version ), ' initializing' write ( * , '(a)' ) 'This version is for evaluation purposes only.' write ( * , '(a)' ) 'Optimizations are disabled - runs at <20% of maximum speed.' #endif end if call date_and_time ( values = datum ) write ( * , 130 ) datum ( 1 ), datum ( 2 ), datum ( 3 ) write ( * , 140 ) datum ( 5 ), datum ( 6 ), datum ( 7 ) 130 format ( 'Program run date = ' , i4 , '-' , i2 , '-' , i2 ) 140 format ( 'Program run time = ' , i2 , ':' , i2 , ':' , i2 ) end subroutine version_print end module version","tags":"","loc":"sourcefile/version.f90.html","title":"version.f90 – Fortran Program"},{"text":"type, public :: score_precalc_type Components Type Visibility Attributes Name Initial character(len=80), public :: chFilename integer, public :: iType","tags":"","loc":"type/score_precalc_type.html","title":"score_precalc_type – Fortran Program "},{"text":"type, public :: score_type Components Type Visibility Attributes Name Initial character(len=80), public :: chFilename integer, public :: frame real(kind=8), public :: score real(kind=8), public :: h_bonds real(kind=8), public :: metal real(kind=8), public :: lipophil real(kind=8), public :: rot_bond","tags":"","loc":"type/score_type.html","title":"score_type – Fortran Program "},{"text":"type, public :: SCORE_COORD_TYPE Components Type Visibility Attributes Name Initial real(kind=8), public, pointer :: xr (:) real(kind=8), public :: xrcm (3)","tags":"","loc":"type/score_coord_type.html","title":"SCORE_COORD_TYPE – Fortran Program "},{"text":"type, public :: wat Components Type Visibility Attributes Name Initial integer(kind=AI), public :: O integer(kind=AI), public :: H1 integer(kind=AI), public :: H2 real, public :: score","tags":"","loc":"type/wat.html","title":"wat – Fortran Program "},{"text":"type, public :: donor Components Type Visibility Attributes Name Initial integer(kind=AI), public :: heavy integer(kind=AI), public :: hydr","tags":"","loc":"type/donor.html","title":"donor – Fortran Program "},{"text":"type, public :: lipos Components Type Visibility Attributes Name Initial integer, public :: n_lip integer, public :: n_nonlip","tags":"","loc":"type/lipos.html","title":"lipos – Fortran Program "},{"text":"type, public :: bond_pointer Components Type Visibility Attributes Name Initial type( q_bond ), public, pointer :: qb","tags":"","loc":"type/bond_pointer.html","title":"bond_pointer – Fortran Program "},{"text":"type, public :: q_atom Components Type Visibility Attributes Name Initial integer, public :: top_nr integer, public :: n type( bond_pointer ), public, dimension(1:6) :: bd logical, public :: contact integer, public :: at_type integer, public :: hybrid logical, public :: been_there logical, public, pointer :: cyclic (:) logical, public :: active","tags":"","loc":"type/q_atom.html","title":"q_atom – Fortran Program "},{"text":"type, public :: q_bond Components Type Visibility Attributes Name Initial type( q_atom ), public, pointer :: a type( q_atom ), public, pointer :: b logical, public :: rotatable logical, public :: acontact logical, public :: bcontact logical, public :: been_there integer, public :: a_nonlip integer, public :: b_nonlip integer, public :: a_lip integer, public :: b_lip logical, public, pointer :: cyclic (:) logical, public :: active","tags":"","loc":"type/q_bond.html","title":"q_bond – Fortran Program "},{"text":"type, public :: ATOM_DATA_TYPE Components Type Visibility Attributes Name Initial real, public :: radius logical, public :: prop (NPROPS)","tags":"","loc":"type/atom_data_type.html","title":"ATOM_DATA_TYPE – Fortran Program "},{"text":"type, public :: COM_COORD_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: x (:) real, public, pointer :: y (:) real, public, pointer :: z (:) real, public, pointer :: mass (:)","tags":"","loc":"type/com_coord_type.html","title":"COM_COORD_TYPE – Fortran Program "},{"text":"type, public :: COORD_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: xyz (:)","tags":"","loc":"type/coord_type.html","title":"COORD_TYPE – Fortran Program "},{"text":"type, public :: MASS_AVE_TYPE Components Type Visibility Attributes Name Initial real, public :: x real, public :: y real, public :: z","tags":"","loc":"type/mass_ave_type.html","title":"MASS_AVE_TYPE – Fortran Program "},{"text":"type, public :: COM_KE_COORD_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: x (:) real, public, pointer :: y (:) real, public, pointer :: z (:) real, public, pointer :: mass (:)","tags":"","loc":"type/com_ke_coord_type.html","title":"COM_KE_COORD_TYPE – Fortran Program "},{"text":"type, public :: COM_KE_VELOCITY_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: x (:) real, public, pointer :: y (:) real, public, pointer :: z (:)","tags":"","loc":"type/com_ke_velocity_type.html","title":"COM_KE_VELOCITY_TYPE – Fortran Program "},{"text":"type, public :: COORD_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: xyz (:)","tags":"","loc":"type/coord_type~2.html","title":"COORD_TYPE – Fortran Program "},{"text":"type, public :: DP_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: dp (:)","tags":"","loc":"type/dp_type.html","title":"DP_TYPE – Fortran Program "},{"text":"type, public :: MASS_AVE_TYPE Components Type Visibility Attributes Name Initial real, public :: x real, public :: y real, public :: z","tags":"","loc":"type/mass_ave_type~2.html","title":"MASS_AVE_TYPE – Fortran Program "},{"text":"type, public :: EIGEN_STUFF_TYPE Components Type Visibility Attributes Name Initial real, public :: evalue (3) real, public :: evector (3,3)","tags":"","loc":"type/eigen_stuff_type.html","title":"EIGEN_STUFF_TYPE – Fortran Program "},{"text":"type, public :: COVARIANCE_MATRIX Components Type Visibility Attributes Name Initial real(kind=8), public :: Exy real(kind=8), public :: Ex real(kind=8), public :: Ey","tags":"","loc":"type/covariance_matrix.html","title":"COVARIANCE_MATRIX – Fortran Program "},{"text":"type, public :: ENTROPY_COORD_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: x (:) real, public, pointer :: xref (:) real(kind=8), public, pointer :: xr (:) real(kind=8), public :: xrcm (3) integer, public :: interval integer, public :: Calc_type character(len=9), public :: Calc_select real(kind=8), public :: Temperature integer, public :: tot_no_frames","tags":"","loc":"type/entropy_coord_type.html","title":"ENTROPY_COORD_TYPE – Fortran Program "},{"text":"type, public :: trajectory Components Type Visibility Attributes Name Initial type( COVARIANCE_MATRIX ), public, pointer :: COV_DATA (:,:) real(kind=8), public, pointer :: C (:,:) real(kind=8), public, pointer :: VIZ (:) real(kind=8), public, pointer :: massvector (:) real(kind=8), public, pointer :: Xcm (:,:) real(kind=8), public, pointer :: Xrot (:) real(kind=8), public, pointer :: X (:,:) integer, public :: startframe integer, public :: endframe integer, public :: no_atoms integer, public :: no_frames integer, public :: store_cov integer, public :: Temperature integer, public :: Calc_type real(kind=8), public, dimension(3,3) :: ROT real(kind=8), public :: masstot","tags":"","loc":"type/trajectory.html","title":"trajectory – Fortran Program "},{"text":"type, public :: FIT_COORD_TYPE Components Type Visibility Attributes Name Initial real(kind=8), public, pointer :: xr (:) real(kind=8), public :: xrcm (3)","tags":"","loc":"type/fit_coord_type.html","title":"FIT_COORD_TYPE – Fortran Program "},{"text":"type, public :: GEOM_TYPE Components Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: l integer, public :: cod integer, public :: kind","tags":"","loc":"type/geom_type.html","title":"GEOM_TYPE – Fortran Program "},{"text":"type, public :: NB_LIST_TYPE Components Type Visibility Attributes Name Initial integer, public :: number_of_NB integer, public, pointer :: atom1 (:) integer, public, pointer :: atom2 (:) real, public, pointer :: AA (:) real, public, pointer :: BB (:) real, public, pointer :: qq (:)","tags":"","loc":"type/nb_list_type.html","title":"NB_LIST_TYPE – Fortran Program "},{"text":"type, public :: AVERAGES Components Type Visibility Attributes Name Initial real, public :: lj real, public :: el","tags":"","loc":"type/averages.html","title":"AVERAGES – Fortran Program "},{"text":"type, public :: NB_QP_TYPE Components Type Visibility Attributes Name Initial integer, public :: p_first integer, public :: p_last integer, public :: q_first integer, public :: q_last","tags":"","loc":"type/nb_qp_type.html","title":"NB_QP_TYPE – Fortran Program "},{"text":"type, public :: NB_LIST_TYPE Components Type Visibility Attributes Name Initial integer, public :: number_of_NB integer, public, pointer :: atom1 (:) integer, public, pointer :: atom2 (:) real, public, pointer :: AA (:) real, public, pointer :: BB (:) real, public, pointer :: qq (:)","tags":"","loc":"type/nb_list_type~2.html","title":"NB_LIST_TYPE – Fortran Program "},{"text":"type, public :: AVERAGES Components Type Visibility Attributes Name Initial real, public :: lj real, public :: el","tags":"","loc":"type/averages~2.html","title":"AVERAGES – Fortran Program "},{"text":"type, public :: NB_QP_TYPE Components Type Visibility Attributes Name Initial integer, public :: p_first integer, public :: p_last integer, public :: q_first integer, public :: q_last","tags":"","loc":"type/nb_qp_type~2.html","title":"NB_QP_TYPE – Fortran Program "},{"text":"type, public :: RDF_CALC_TYPE Components Type Visibility Attributes Name Initial integer, public :: atoms_in_mask1 integer, public :: frames = 0 integer, public :: Nbins real(kind=8), public :: rdf_radius real(kind=8), public, pointer :: bins (:)","tags":"","loc":"type/rdf_calc_type.html","title":"RDF_CALC_TYPE – Fortran Program "},{"text":"type, public :: RDF_LIST_TYPE Components Type Visibility Attributes Name Initial integer, public :: number_of_pairs integer, public, pointer :: atom1 (:) integer, public, pointer :: atom2 (:)","tags":"","loc":"type/rdf_list_type.html","title":"RDF_LIST_TYPE – Fortran Program "},{"text":"type, public :: RMS_COORD_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: x (:) real, public, pointer :: x0 (:)","tags":"","loc":"type/rms_coord_type.html","title":"RMS_COORD_TYPE – Fortran Program "},{"text":"type, public :: RMSF_COORD_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: x (:) real, public, pointer :: x0 (:) real, public, pointer :: x2 (:)","tags":"","loc":"type/rmsf_coord_type.html","title":"RMSF_COORD_TYPE – Fortran Program "},{"text":"type, public :: indexentry Components Type Visibility Attributes Name Initial character(len=KEYLENGTH), public :: key integer, public :: ndx","tags":"","loc":"type/indexentry.html","title":"indexentry – Fortran Program "},{"text":"type, public :: MASK_TYPE Components Type Visibility Attributes Name Initial integer, public :: included logical(kind=1), public, pointer :: mask (:)","tags":"","loc":"type/mask_type.html","title":"MASK_TYPE – Fortran Program "},{"text":"type, public :: PAIR_ASSIGNMENT_TYPE Components Type Visibility Attributes Name Initial integer, public :: start integer, public :: end integer, public :: max","tags":"","loc":"type/pair_assignment_type.html","title":"PAIR_ASSIGNMENT_TYPE – Fortran Program "},{"text":"type, public :: NODE_ASSIGNMENT_TYPE Components Type Visibility Attributes Name Initial type( PAIR_ASSIGNMENT_TYPE ), public :: pp type( PAIR_ASSIGNMENT_TYPE ), public :: pw type( PAIR_ASSIGNMENT_TYPE ), public :: ww type( PAIR_ASSIGNMENT_TYPE ), public :: qp type( PAIR_ASSIGNMENT_TYPE ), public :: qw","tags":"","loc":"type/node_assignment_type.html","title":"NODE_ASSIGNMENT_TYPE – Fortran Program "},{"text":"type, public :: MPI_NB_ENERGIES sequence Components Type Visibility Attributes Name Initial real(kind=dp), public :: lrf type(NB_ENERGIES), public :: pp type(NB_ENERGIES), public :: pw type(NB_ENERGIES), public :: ww","tags":"","loc":"type/mpi_nb_energies.html","title":"MPI_NB_ENERGIES – Fortran Program "},{"text":"type, public :: MPI_NBQ_ENERGIES sequence Components Type Visibility Attributes Name Initial type(NB_ENERGIES), public :: qp type(NB_ENERGIES), public :: qw","tags":"","loc":"type/mpi_nbq_energies.html","title":"MPI_NBQ_ENERGIES – Fortran Program "},{"text":"type, public :: substring Components Type Visibility Attributes Name Initial integer, public :: istart integer, public :: iend","tags":"","loc":"type/substring.html","title":"substring – Fortran Program "},{"text":"type, public :: lib_bond_type Components Type Visibility Attributes Name Initial integer(kind=AI), public :: i integer(kind=AI), public :: j","tags":"","loc":"type/lib_bond_type.html","title":"lib_bond_type – Fortran Program "},{"text":"type, public :: lib_imp_type Components Type Visibility Attributes Name Initial character(len=1+4), public :: i character(len=1+4), public :: j character(len=1+4), public :: k character(len=1+4), public :: l","tags":"","loc":"type/lib_imp_type.html","title":"lib_imp_type – Fortran Program "},{"text":"type, public :: lib_rule_type Components Type Visibility Attributes Name Initial integer, public :: kind integer, public :: atom (4) real, public :: value","tags":"","loc":"type/lib_rule_type.html","title":"lib_rule_type – Fortran Program "},{"text":"type, public :: lib_entry_type Components Type Visibility Attributes Name Initial integer, public :: nat integer, public :: nbnd integer, public :: nimp integer, public :: ncgp integer, public :: nrules integer, public :: head integer, public :: tail logical, public :: hetatm logical, public :: solvent real, public :: density character(len=4), public :: nam character(len=8), public :: sybyltype character(len=4), public, pointer :: atnam (:) character(len=keylength), public, pointer :: tac_lib (:) real, public, pointer :: crg_lib (:) type( lib_rule_type ), public, pointer :: rules (:) type( lib_bond_type ), public, pointer :: bnd (:) type( lib_imp_type ), public, pointer :: imp (:) integer(kind=ai), public, pointer :: natcgp (:) integer(kind=ai), public, pointer :: switch (:) integer(kind=ai), public, pointer :: atcgp (:,:)","tags":"","loc":"type/lib_entry_type.html","title":"lib_entry_type – Fortran Program "},{"text":"type, public :: bond_type_type Components Type Visibility Attributes Name Initial character(len=keylength), public :: taci character(len=keylength), public :: tacj integer, public :: cod","tags":"","loc":"type/bond_type_type.html","title":"bond_type_type – Fortran Program "},{"text":"type, public :: bond_prm_type Components Type Visibility Attributes Name Initial type( bondlib_type ), public :: prm character(len=2), public :: SYBYLtype","tags":"","loc":"type/bond_prm_type.html","title":"bond_prm_type – Fortran Program "},{"text":"type, public :: angle_type_type Components Type Visibility Attributes Name Initial character(len=keylength), public :: taci character(len=keylength), public :: tacj character(len=keylength), public :: tack integer, public :: cod","tags":"","loc":"type/angle_type_type.html","title":"angle_type_type – Fortran Program "},{"text":"type, public :: torsion_type_type Components Type Visibility Attributes Name Initial character(len=keylength), public :: taci character(len=keylength), public :: tacj character(len=keylength), public :: tack character(len=keylength), public :: tacl integer, public :: cod","tags":"","loc":"type/torsion_type_type.html","title":"torsion_type_type – Fortran Program "},{"text":"type, public :: tor_codes Components Type Visibility Attributes Name Initial integer, public :: ncod integer, public :: cod (10)","tags":"","loc":"type/tor_codes.html","title":"tor_codes – Fortran Program "},{"text":"type, public :: imp_prm_type Components Type Visibility Attributes Name Initial character(len=keylength), public :: taci character(len=keylength), public :: tacj character(len=keylength), public :: tack character(len=keylength), public :: tacl type( implib_type ), public :: prm","tags":"","loc":"type/imp_prm_type.html","title":"imp_prm_type – Fortran Program "},{"text":"type, public :: LINE_TYPE Components Type Visibility Attributes Name Initial character(len=900), public :: text type( LINE_TYPE ), public, pointer :: next","tags":"","loc":"type/line_type.html","title":"LINE_TYPE – Fortran Program "},{"text":"type, public :: SECTION_TYPE Components Type Visibility Attributes Name Initial character(len=80), public :: name type( SECTION_TYPE ), public, pointer :: next type( LINE_TYPE ), public, pointer :: lp integer, public :: count integer, public :: max_enum","tags":"","loc":"type/section_type.html","title":"SECTION_TYPE – Fortran Program "},{"text":"type, public :: QBOND_TYPE Components Type Visibility Attributes Name Initial integer(kind=AI), public :: i integer(kind=AI), public :: j integer(kind=TINY), public :: cod (max_states)","tags":"","loc":"type/qbond_type.html","title":"QBOND_TYPE – Fortran Program "},{"text":"type, public :: QBONDLIB_TYPE Components Type Visibility Attributes Name Initial real(kind=8), public :: Dmz real(kind=8), public :: amz real(kind=8), public :: r0 real(kind=8), public :: fk","tags":"","loc":"type/qbondlib_type.html","title":"QBONDLIB_TYPE – Fortran Program "},{"text":"type, public :: QANGLE_TYPE Components Type Visibility Attributes Name Initial integer(kind=AI), public :: i integer(kind=AI), public :: j integer(kind=AI), public :: k integer(kind=TINY), public :: cod (max_states)","tags":"","loc":"type/qangle_type.html","title":"QANGLE_TYPE – Fortran Program "},{"text":"type, public :: SPECEX_TYPE Components Type Visibility Attributes Name Initial integer(kind=AI), public :: i integer(kind=AI), public :: j logical, public :: flag (max_states)","tags":"","loc":"type/specex_type.html","title":"SPECEX_TYPE – Fortran Program "},{"text":"type, public :: monitor_group_pair_TYPE Components Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=8), public :: Vel (max_states) real(kind=8), public :: Vlj (max_states) real(kind=8), public :: Vwel real(kind=8), public :: Vwlj real(kind=8), public :: Vwsum","tags":"","loc":"type/monitor_group_pair_type.html","title":"monitor_group_pair_TYPE – Fortran Program "},{"text":"type, public :: monitor_atom_group_TYPE Components Type Visibility Attributes Name Initial integer, public, pointer :: atom (:) integer, public :: n","tags":"","loc":"type/monitor_atom_group_type.html","title":"monitor_atom_group_TYPE – Fortran Program "},{"text":"type, public :: qq_el_scale_type Components Type Visibility Attributes Name Initial integer(kind=AI), public :: iqat integer(kind=AI), public :: jqat real(kind=8), public :: el_scale (max_states)","tags":"","loc":"type/qq_el_scale_type.html","title":"qq_el_scale_type – Fortran Program "},{"text":"type :: calc_type Components Type Visibility Attributes Name Initial character(len=60), public :: desc integer, public :: i integer, public :: typ","tags":"","loc":"type/calc_type.html","title":"calc_type – Fortran Program "},{"text":"type :: calc_kind_type Components Type Visibility Attributes Name Initial character(len=40), public :: desc character(len=14), public :: key logical, public :: output","tags":"","loc":"type/calc_kind_type.html","title":"calc_kind_type – Fortran Program "},{"text":"type :: FEP_DATA_TYPE Components Type Visibility Attributes Name Initial integer, public :: npts real(kind=8), public :: lambda (mxstates) real(kind=8), public, pointer :: v (:,:) real(kind=8), public, pointer :: r (:,:) real(kind=8), public, pointer :: vg (:) real(kind=8), public, pointer :: gap (:) real(kind=8), public, pointer :: c1 (:) real(kind=8), public, pointer :: c2 (:)","tags":"","loc":"type/fep_data_type.html","title":"FEP_DATA_TYPE – Fortran Program "},{"text":"type, public :: bond_type Components Type Visibility Attributes Name Initial integer(kind=ai), public :: i integer(kind=ai), public :: j integer(kind=shrt), public :: cod","tags":"","loc":"type/bond_type.html","title":"bond_type – Fortran Program "},{"text":"type, public :: ang_type Components Type Visibility Attributes Name Initial integer(kind=ai), public :: i integer(kind=ai), public :: j integer(kind=ai), public :: k integer(kind=shrt), public :: cod","tags":"","loc":"type/ang_type.html","title":"ang_type – Fortran Program "},{"text":"type, public :: bondlib_type Components Type Visibility Attributes Name Initial real(kind=8), public :: fk real(kind=8), public :: bnd0","tags":"","loc":"type/bondlib_type.html","title":"bondlib_type – Fortran Program "},{"text":"type, public :: anglib_type Components Type Visibility Attributes Name Initial real(kind=8), public :: fk real(kind=8), public :: ang0 real(kind=8), public :: ureyfk real(kind=8), public :: ureyr0","tags":"","loc":"type/anglib_type.html","title":"anglib_type – Fortran Program "},{"text":"type, public :: tor_type Components Type Visibility Attributes Name Initial integer(kind=ai), public :: i integer(kind=ai), public :: j integer(kind=ai), public :: k integer(kind=ai), public :: l integer(kind=shrt), public :: cod","tags":"","loc":"type/tor_type.html","title":"tor_type – Fortran Program "},{"text":"type, public :: torlib_type Components Type Visibility Attributes Name Initial real, public :: fk real, public :: rmult real, public :: deltor real, public :: paths","tags":"","loc":"type/torlib_type.html","title":"torlib_type – Fortran Program "},{"text":"type, public :: implib_type Components Type Visibility Attributes Name Initial real, public :: fk real, public :: imp0","tags":"","loc":"type/implib_type.html","title":"implib_type – Fortran Program "},{"text":"type, public :: cgp_type Components Type Visibility Attributes Name Initial integer(kind=ai), public :: iswitch integer(kind=ai), public :: first integer(kind=ai), public :: last","tags":"","loc":"type/cgp_type.html","title":"cgp_type – Fortran Program "},{"text":"type, public :: iac_type Components Type Visibility Attributes Name Initial real(kind=8), public :: mass real(kind=8), public :: avdw (nljtyp) real(kind=8), public :: bvdw (nljtyp)","tags":"","loc":"type/iac_type.html","title":"iac_type – Fortran Program "},{"text":"type, public :: lj2_type Components Type Visibility Attributes Name Initial integer(kind=tiny), public :: i integer(kind=tiny), public :: j","tags":"","loc":"type/lj2_type.html","title":"lj2_type – Fortran Program "},{"text":"type, public :: residue_type Components Type Visibility Attributes Name Initial integer, public :: irc integer, public :: start character(len=4), public :: name","tags":"","loc":"type/residue_type.html","title":"residue_type – Fortran Program "},{"text":"subroutine EIGEN(A, R, N, mv) Arguments Type Intent Optional Attributes Name double precision :: A double precision :: R integer :: N integer :: mv Description *GENERATE IDENTITY MATRIX COMPUTE INITIAL AND FINAL NORMS (ANORM AND ANRMX) *INITIALIZE INDICATORS AND COMPUTE THRESHOLD, THR COMPUT SIN AND COS *ROTATE L AND M COLUMNS *TESTS FOR COMPLETION *TEST FOR M = LAST COLUMN TEST FOR L = SECOND FROM LAST COLUMN *COMPARE THRESHOLD WITH FINAL NORM SORT EIGENVALUES AND EIGENVECTORS Variables Type Visibility Attributes Name Initial double precision, public :: B double precision, public :: C double precision, public :: D double precision, public :: E double precision, public :: F double precision, public :: G double precision, public :: H double precision, public :: O double precision, public :: P double precision, public :: Q double precision, public :: S double precision, public :: T double precision, public :: U double precision, public :: V double precision, public :: W double precision, public :: X double precision, public :: Y double precision, public :: Z double precision, public :: anorm double precision, public :: anrmx double precision, public :: thr double precision, public :: sinx double precision, public :: sinx2 double precision, public :: cosx double precision, public :: cosx2 double precision, public :: sincs integer, public :: I integer, public :: J integer, public :: K integer, public :: L integer, public :: M integer, public :: range integer, public :: iq integer, public :: ij integer, public :: ia integer, public :: ind integer, public :: mq integer, public :: lq integer, public :: lm integer, public :: ll integer, public :: mm integer, public :: ilq integer, public :: imq integer, public :: im integer, public :: il integer, public :: ilr integer, public :: imr integer, public :: jq","tags":"","loc":"proc/eigen.html","title":"EIGEN – Fortran Program"},{"text":"function sigint_handler(sig_num) Uses: md Arguments Type Intent Optional Attributes Name integer(kind=4) :: sig_num Return Value integer(kind=4)","tags":"","loc":"proc/sigint_handler.html","title":"sigint_handler – Fortran Program"},{"text":"function sigkill_handler(sig_num) Uses: md Arguments Type Intent Optional Attributes Name integer(kind=4) :: sig_num Return Value integer(kind=4)","tags":"","loc":"proc/sigkill_handler.html","title":"sigkill_handler – Fortran Program"},{"text":"function sigabrt_handler(sig_num) Uses: md Arguments Type Intent Optional Attributes Name integer(kind=4) :: sig_num Return Value integer(kind=4)","tags":"","loc":"proc/sigabrt_handler.html","title":"sigabrt_handler – Fortran Program"},{"text":"public subroutine avetr_calc() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: allocation_status character(len=1), public :: ans logical, public :: fin","tags":"","loc":"proc/avetr_calc.html","title":"avetr_calc – Fortran Program"},{"text":"public subroutine add_coordinates() Arguments None","tags":"","loc":"proc/add_coordinates.html","title":"add_coordinates – Fortran Program"},{"text":"public subroutine average() Arguments None","tags":"","loc":"proc/average.html","title":"average – Fortran Program"},{"text":"public subroutine write_average() Arguments None","tags":"","loc":"proc/write_average.html","title":"write_average – Fortran Program"},{"text":"public recursive function lip_atom(atom) result(ans) Arguments Type Intent Optional Attributes Name type( q_atom ), , pointer :: atom Return Value type( lipos ) Variables Type Visibility Attributes Name Initial type( lipos ), public :: lipo type( lipos ), public :: temp integer, public :: i type( q_bond ), public, pointer :: bond","tags":"","loc":"proc/lip_atom.html","title":"lip_atom – Fortran Program"},{"text":"public recursive function find_contact(atom) result(ans) Arguments Type Intent Optional Attributes Name type( q_atom ), , pointer :: atom Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: i logical, public :: cont type( q_bond ), public, pointer :: bond","tags":"","loc":"proc/find_contact.html","title":"find_contact – Fortran Program"},{"text":"public recursive function trace_ring(atom, ir) result(ans) Arguments Type Intent Optional Attributes Name type( q_atom ), , pointer :: atom integer :: ir Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: i logical, public :: found type( q_bond ), public, pointer :: bond","tags":"","loc":"proc/trace_ring.html","title":"trace_ring – Fortran Program"},{"text":"public function angle(a, b, c) Arguments Type Intent Optional Attributes Name integer :: a integer :: b integer :: c Return Value real Variables Type Visibility Attributes Name Initial real, public :: ab_sq real, public :: bc_sq real, public :: ca_sq real, public :: scp real, public, parameter :: pi = 4.0*atan(1.0)","tags":"","loc":"proc/angle.html","title":"angle – Fortran Program"},{"text":"public function dist(a, b) Arguments Type Intent Optional Attributes Name integer :: a integer :: b Return Value real Description ! Gives the distance between two atoms. Variables Type Visibility Attributes Name Initial real, public, dimension(3) :: delta","tags":"","loc":"proc/dist.html","title":"dist – Fortran Program"},{"text":"public function distsq(a, b) Arguments Type Intent Optional Attributes Name integer :: a integer :: b Return Value real Description ! Gives the squared distance between two atoms. Variables Type Visibility Attributes Name Initial real, public, dimension(3) :: delta","tags":"","loc":"proc/distsq.html","title":"distsq – Fortran Program"},{"text":"public function fr_lip(a, b) Arguments Type Intent Optional Attributes Name integer :: a integer :: b Return Value real Description ! Gives f(rlL) i.e. contribution from one lipophilic - lipophilic pair Variables Type Visibility Attributes Name Initial real, public :: dr real, public :: R1","tags":"","loc":"proc/fr_lip.html","title":"fr_lip – Fortran Program"},{"text":"public function fr_met(a, b) Arguments Type Intent Optional Attributes Name integer :: a integer :: b Return Value real Variables Type Visibility Attributes Name Initial real, public :: dr","tags":"","loc":"proc/fr_met.html","title":"fr_met – Fortran Program"},{"text":"public function g1_hb(a, b) Arguments Type Intent Optional Attributes Name integer :: a integer :: b Return Value real Variables Type Visibility Attributes Name Initial real, public :: dr real, public :: dev_dr","tags":"","loc":"proc/g1_hb.html","title":"g1_hb – Fortran Program"},{"text":"public function g2_hb(a, b, c) Arguments Type Intent Optional Attributes Name integer :: a integer :: b integer :: c Return Value real Description ! Gives g2(dev_ang) i.e. contribution depending on the H-bond angle at the hydrogen atom Variables Type Visibility Attributes Name Initial real, public :: ang real, public :: dev_ang","tags":"","loc":"proc/g2_hb.html","title":"g2_hb – Fortran Program"},{"text":"public function score_add(desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: ats integer, public :: iRe character(len=400), public :: chInFile character(len=400), public :: chBuf","tags":"","loc":"proc/score_add.html","title":"score_add – Fortran Program"},{"text":"public subroutine score_initialize() Arguments None","tags":"","loc":"proc/score_initialize.html","title":"score_initialize – Fortran Program"},{"text":"public subroutine chemscore_finalize() Arguments None","tags":"","loc":"proc/chemscore_finalize.html","title":"chemscore_finalize – Fortran Program"},{"text":"public subroutine log_frame(iFrame) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iFrame Variables Type Visibility Attributes Name Initial type( score_type ), public, pointer :: new_aScore (:)","tags":"","loc":"proc/log_frame.html","title":"log_frame – Fortran Program"},{"text":"public subroutine score_heading(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/score_heading.html","title":"score_heading – Fortran Program"},{"text":"public subroutine calc_hbonds() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real, public :: score1 real, public :: score2","tags":"","loc":"proc/calc_hbonds.html","title":"calc_hbonds – Fortran Program"},{"text":"public subroutine calc_lipo() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real, public :: fij","tags":"","loc":"proc/calc_lipo.html","title":"calc_lipo – Fortran Program"},{"text":"public subroutine calc_metals() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real, public :: score","tags":"","loc":"proc/calc_metals.html","title":"calc_metals – Fortran Program"},{"text":"public subroutine calc_rot() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: nfrozen real, public :: pa real, public :: pb real, public :: hrot real, public :: sum","tags":"","loc":"proc/calc_rot.html","title":"calc_rot – Fortran Program"},{"text":"public subroutine calc_scores() Arguments None","tags":"","loc":"proc/calc_scores.html","title":"calc_scores – Fortran Program"},{"text":"public subroutine count_qlipo() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i type( lipos ), public :: lipo","tags":"","loc":"proc/count_qlipo.html","title":"count_qlipo – Fortran Program"},{"text":"public subroutine frozen() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j type( q_bond ), public, pointer :: bond type( q_atom ), public, pointer :: atom","tags":"","loc":"proc/frozen.html","title":"frozen – Fortran Program"},{"text":"public subroutine get_atom_data() Arguments None Description ! Go through all atoms and give them a vdW radius.\n! I represents atom number. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real, public :: rad (natyps) real, public :: radius logical, public :: stat logical, public :: novdw (natyps) character(len=8), public :: tac_in","tags":"","loc":"proc/get_atom_data.html","title":"get_atom_data – Fortran Program"},{"text":"public subroutine make_tac_index() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/make_tac_index.html","title":"make_tac_index – Fortran Program"},{"text":"public subroutine q_contacts() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: tnr real, public :: distance","tags":"","loc":"proc/q_contacts.html","title":"q_contacts – Fortran Program"},{"text":"public subroutine q_types() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: nr integer, public :: a_type","tags":"","loc":"proc/q_types.html","title":"q_types – Fortran Program"},{"text":"public subroutine report_ligand() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: top integer, public :: cont","tags":"","loc":"proc/report_ligand.html","title":"report_ligand – Fortran Program"},{"text":"public subroutine report_protein() Arguments None","tags":"","loc":"proc/report_protein.html","title":"report_protein – Fortran Program"},{"text":"public subroutine report_rings() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","loc":"proc/report_rings.html","title":"report_rings – Fortran Program"},{"text":"public subroutine reset_waters() Arguments None","tags":"","loc":"proc/reset_waters.html","title":"reset_waters – Fortran Program"},{"text":"public subroutine score_waters() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k real, public :: score1 real, public :: score2 real, public :: sum_score","tags":"","loc":"proc/score_waters.html","title":"score_waters – Fortran Program"},{"text":"public subroutine set_ligand() Arguments None","tags":"","loc":"proc/set_ligand.html","title":"set_ligand – Fortran Program"},{"text":"public subroutine set_rings() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ir type( q_atom ), public, pointer :: start_atom integer, public :: i integer, public :: j","tags":"","loc":"proc/set_rings.html","title":"set_rings – Fortran Program"},{"text":"public recursive subroutine search_ring(bond, ir) Arguments Type Intent Optional Attributes Name type( q_bond ), , pointer :: bond integer :: ir Variables Type Visibility Attributes Name Initial type( q_atom ), public, pointer :: atom integer, public :: i","tags":"","loc":"proc/search_ring.html","title":"search_ring – Fortran Program"},{"text":"public subroutine mark_ring(bond, ir) Arguments Type Intent Optional Attributes Name type( q_bond ), , pointer :: bond integer :: ir Variables Type Visibility Attributes Name Initial logical, public :: found","tags":"","loc":"proc/mark_ring.html","title":"mark_ring – Fortran Program"},{"text":"public subroutine set_rotatable() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","loc":"proc/set_rotatable.html","title":"set_rotatable – Fortran Program"},{"text":"public subroutine set_waters() Arguments None","tags":"","loc":"proc/set_waters.html","title":"set_waters – Fortran Program"},{"text":"public subroutine sort_atoms() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: a_type","tags":"","loc":"proc/sort_atoms.html","title":"sort_atoms – Fortran Program"},{"text":"public subroutine sort_bonds() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: atom1 integer, public :: atom2 integer, public :: hydrogen_atom integer, public :: heavy_at integer, public :: a_type integer, public :: type1 integer, public :: type2 integer, public :: i integer, public :: j integer, public :: k logical, public :: polar","tags":"","loc":"proc/sort_bonds.html","title":"sort_bonds – Fortran Program"},{"text":"public subroutine sort_waters() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/sort_waters.html","title":"sort_waters – Fortran Program"},{"text":"public subroutine start() Arguments None Description ! Takes vdw_radii from vdw_file and puts into vector vdwr.\n! Also assigns radii to every solute atom Variables Type Visibility Attributes Name Initial integer(kind=4), public :: u integer(kind=4), public :: nat3 integer, public :: i","tags":"","loc":"proc/start.html","title":"start – Fortran Program"},{"text":"public subroutine store_waters() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","loc":"proc/store_waters.html","title":"store_waters – Fortran Program"},{"text":"public subroutine score_precalc() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i character(len=200), public :: chBuf","tags":"","loc":"proc/score_precalc.html","title":"score_precalc – Fortran Program"},{"text":"public subroutine score_mean() Arguments None Variables Type Visibility Attributes Name Initial real(kind=8), public :: m_score real(kind=8), public :: m_hbond real(kind=8), public :: m_metal real(kind=8), public :: m_lipo real(kind=8), public :: m_rot","tags":"","loc":"proc/score_mean.html","title":"score_mean – Fortran Program"},{"text":"public subroutine score_calc(iCalc, iFrame) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iCalc integer, intent(in) :: iFrame","tags":"","loc":"proc/score_calc.html","title":"score_calc – Fortran Program"},{"text":"public function COM_add(desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Variables Type Visibility Attributes Name Initial character(len=80), public :: line integer, public :: readstat integer, public :: ats integer, public :: j","tags":"","loc":"proc/com_add.html","title":"COM_add – Fortran Program"},{"text":"public subroutine COM_initialize() Arguments None","tags":"","loc":"proc/com_initialize.html","title":"COM_initialize – Fortran Program"},{"text":"public subroutine COM_finalize(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/com_finalize.html","title":"COM_finalize – Fortran Program"},{"text":"public subroutine COM_calc(i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i","tags":"","loc":"proc/com_calc.html","title":"COM_calc – Fortran Program"},{"text":"public subroutine COM_put_mass(i) Arguments Type Intent Optional Attributes Name integer :: i Variables Type Visibility Attributes Name Initial integer, public :: k integer, public :: j integer, public :: at real, public :: mass","tags":"","loc":"proc/com_put_mass.html","title":"COM_put_mass – Fortran Program"},{"text":"public subroutine COM_heading(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/com_heading.html","title":"COM_heading – Fortran Program"},{"text":"public function COM_KE_add(desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Variables Type Visibility Attributes Name Initial character(len=80), public :: line integer, public :: readstat integer, public :: ats integer, public :: j","tags":"","loc":"proc/com_ke_add.html","title":"COM_KE_add – Fortran Program"},{"text":"public subroutine COM_KE_initialize() Arguments None","tags":"","loc":"proc/com_ke_initialize.html","title":"COM_KE_initialize – Fortran Program"},{"text":"public subroutine COM_KE_finalize(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/com_ke_finalize.html","title":"COM_KE_finalize – Fortran Program"},{"text":"public subroutine COM_KE_calc(i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Variables Type Visibility Attributes Name Initial integer, public :: info integer, public :: IPIV (3,3) integer, public :: j double precision, public :: A (3,3) double precision, public :: B (3) double precision, public :: W (30) double precision, public :: K (6) double precision, public :: C (6) real(kind=8), public :: KE real(kind=8), public :: IXX real(kind=8), public :: IXY real(kind=8), public :: IXZ real(kind=8), public :: IYY real(kind=8), public :: IYZ real(kind=8), public :: IZZ real(kind=8), public :: tot_KE_rot","tags":"","loc":"proc/com_ke_calc.html","title":"COM_KE_calc – Fortran Program"},{"text":"public subroutine COM_KE_put_mass(i) Arguments Type Intent Optional Attributes Name integer :: i Variables Type Visibility Attributes Name Initial integer, public :: k integer, public :: j integer, public :: at real, public :: mass","tags":"","loc":"proc/com_ke_put_mass.html","title":"COM_KE_put_mass – Fortran Program"},{"text":"public subroutine COM_KE_heading(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/com_ke_heading.html","title":"COM_KE_heading – Fortran Program"},{"text":"public function entropy_add(desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: ats","tags":"","loc":"proc/entropy_add.html","title":"entropy_add – Fortran Program"},{"text":"public subroutine construct_trajectory(t, Temp, startframe, endframe, no_atoms, Calc_type) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t real(kind=8) :: Temp integer :: startframe integer :: endframe integer :: no_atoms integer :: Calc_type Variables Type Visibility Attributes Name Initial integer, public :: no_frames integer, public :: i integer, public :: j character(len=20), public :: dcd character(len=20), public :: top","tags":"","loc":"proc/construct_trajectory.html","title":"construct_trajectory – Fortran Program"},{"text":"public subroutine ENTROPY_initialize() Arguments None","tags":"","loc":"proc/entropy_initialize.html","title":"ENTROPY_initialize – Fortran Program"},{"text":"public subroutine ENTROPY_finalize(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/entropy_finalize.html","title":"ENTROPY_finalize – Fortran Program"},{"text":"public subroutine entropy_heading(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/entropy_heading.html","title":"entropy_heading – Fortran Program"},{"text":"public subroutine entropy_calc(i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: k integer, public :: l integer, public :: n integer, public :: m integer, public :: o real(kind=8), public :: det real(kind=8), public :: gauss real(kind=8), public :: uniform type( trajectory ), public :: t real(kind=8), public, dimension(3) :: uin real(kind=8), public, dimension(3) :: vin","tags":"","loc":"proc/entropy_calc.html","title":"entropy_calc – Fortran Program"},{"text":"public subroutine CovarianceMatrix(t) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","loc":"proc/covariancematrix.html","title":"CovarianceMatrix – Fortran Program"},{"text":"public subroutine SchlittersFormula(t, det) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t real(kind=8) :: det Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k","tags":"","loc":"proc/schlittersformula.html","title":"SchlittersFormula – Fortran Program"},{"text":"public subroutine MultiplyMatrices(t) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: l integer, public :: n real(kind=8), public :: det real(kind=8), public :: c","tags":"","loc":"proc/multiplymatrices.html","title":"MultiplyMatrices – Fortran Program"},{"text":"public subroutine CholeskyFactorization(t) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: l","tags":"","loc":"proc/choleskyfactorization.html","title":"CholeskyFactorization – Fortran Program"},{"text":"public subroutine RotationAndTranslation(t, i) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t integer, intent(in) :: i Variables Type Visibility Attributes Name Initial integer, public :: at integer, public :: j integer, public :: k integer, public :: lsqstatus real(kind=8), public :: totmass real(kind=8), public :: error real(kind=8), public :: xcm (3)","tags":"","loc":"proc/rotationandtranslation.html","title":"RotationAndTranslation – Fortran Program"},{"text":"public subroutine fit_make_reference(i) Arguments Type Intent Optional Attributes Name integer :: i Variables Type Visibility Attributes Name Initial integer, public :: at real(kind=8), public :: totmass","tags":"","loc":"proc/fit_make_reference.html","title":"fit_make_reference – Fortran Program"},{"text":"public subroutine Quasiharmonic_analysis(i, t, det) Arguments Type Intent Optional Attributes Name integer :: i type( trajectory ) :: t real(kind=8) :: det Variables Type Visibility Attributes Name Initial real(kind=8), public, dimension(:,:), pointer :: R","tags":"","loc":"proc/quasiharmonic_analysis.html","title":"Quasiharmonic_analysis – Fortran Program"},{"text":"public subroutine massweight(t) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","loc":"proc/massweight.html","title":"massweight – Fortran Program"},{"text":"public subroutine VIZ(t) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k","tags":"","loc":"proc/viz.html","title":"VIZ – Fortran Program"},{"text":"public subroutine entropy_ho(m, t, det) Arguments Type Intent Optional Attributes Name integer :: m type( trajectory ) :: t real(kind=8) :: det Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: no_freq real(kind=8), public :: hswkT real(kind=8), public :: w real(kind=8), public :: cm real(kind=8), public :: scaling","tags":"","loc":"proc/entropy_ho.html","title":"entropy_ho – Fortran Program"},{"text":"public subroutine PCA(t, det) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t real(kind=8) :: det Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: rotation real(kind=8), public, dimension(:,:), pointer :: R","tags":"","loc":"proc/pca.html","title":"PCA – Fortran Program"},{"text":"public subroutine Euler_angles(t) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t Variables Type Visibility Attributes Name Initial real(kind=8), public :: phi real(kind=8), public :: psi real(kind=8), public :: theta real(kind=8), public :: delta integer, public :: i integer, public :: j integer, public :: k","tags":"","loc":"proc/euler_angles.html","title":"Euler_angles – Fortran Program"},{"text":"public subroutine UpdateCovariancematrix(t, i) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t integer :: i Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: k","tags":"","loc":"proc/updatecovariancematrix.html","title":"UpdateCovariancematrix – Fortran Program"},{"text":"public function fit_add(desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: ats","tags":"","loc":"proc/fit_add.html","title":"fit_add – Fortran Program"},{"text":"public function LSQSTR(NR, W, XP, X, E, U) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NR logical(kind=1), intent(in) :: W (:) real(kind=8), intent(in) :: XP (:) real(kind=8), intent(inout) :: X (:) real(kind=8), intent(out), optional :: E real(kind=8) , optional :: U (3,3) Return Value integer Description *CONSTRUCT OMEGA, DIAGONALIZE IT AND DETERMINE H AND K DETERMINE R AND ROTATE X ***CALCULATE E, WHEN REQUIRED Variables Type Visibility Attributes Name Initial real(kind=8), public :: COM (21) real(kind=8), public :: OM (6,6) real(kind=8), public :: VH (3,3) real(kind=8), public :: VK (3,3) real(kind=8), public :: DU real(kind=8), public :: SIG integer, public :: I integer, public :: J integer, public :: M integer, public :: M1 integer, public :: M2 ****CALCULATE THE MATRIX U AND ITS DETERMINANT","tags":"","loc":"proc/lsqstr.html","title":"LSQSTR – Fortran Program"},{"text":"public subroutine fit_initialize() Arguments None","tags":"","loc":"proc/fit_initialize.html","title":"fit_initialize – Fortran Program"},{"text":"public subroutine fit_finalize(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/fit_finalize.html","title":"fit_finalize – Fortran Program"},{"text":"public subroutine fit_calc(i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Variables Type Visibility Attributes Name Initial integer, public :: at integer, public :: lsqstatus real(kind=8), public :: xcm (3) real(kind=8), public :: totmass real(kind=8), public :: U (3,3) real(kind=8), public :: E","tags":"","loc":"proc/fit_calc.html","title":"fit_calc – Fortran Program"},{"text":"public subroutine fit_make_ref(i) Arguments Type Intent Optional Attributes Name integer :: i Variables Type Visibility Attributes Name Initial integer, public :: at real(kind=8), public :: totmass","tags":"","loc":"proc/fit_make_ref.html","title":"fit_make_ref – Fortran Program"},{"text":"public function dist_add(desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Variables Type Visibility Attributes Name Initial character(len=80), public :: line integer, public :: readstat integer, public :: b","tags":"","loc":"proc/dist_add.html","title":"dist_add – Fortran Program"},{"text":"public function angle_add(desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Variables Type Visibility Attributes Name Initial character(len=80), public :: line integer, public :: readstat integer, public :: i integer, public :: j integer, public :: k integer, public :: b","tags":"","loc":"proc/angle_add.html","title":"angle_add – Fortran Program"},{"text":"public function torsion_add(desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Variables Type Visibility Attributes Name Initial character(len=80), public :: line integer, public :: readstat integer, public :: i integer, public :: j integer, public :: k integer, public :: l integer, public :: b","tags":"","loc":"proc/torsion_add.html","title":"torsion_add – Fortran Program"},{"text":"public subroutine geom_initialize() Arguments None","tags":"","loc":"proc/geom_initialize.html","title":"geom_initialize – Fortran Program"},{"text":"public subroutine geom_finalize() Arguments None","tags":"","loc":"proc/geom_finalize.html","title":"geom_finalize – Fortran Program"},{"text":"public subroutine dist_calc(i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Variables Type Visibility Attributes Name Initial real(kind=8), public :: rji (3) real(kind=8), public :: r2 real(kind=8), public :: r real(kind=8), public :: V","tags":"","loc":"proc/dist_calc.html","title":"dist_calc – Fortran Program"},{"text":"public subroutine angle_calc(i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Variables Type Visibility Attributes Name Initial real(kind=8), public :: rji (3) real(kind=8), public :: rjk (3) real(kind=8), public :: scp real(kind=8), public :: a real(kind=8), public :: V","tags":"","loc":"proc/angle_calc.html","title":"angle_calc – Fortran Program"},{"text":"public subroutine torsion_calc(i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Variables Type Visibility Attributes Name Initial real(kind=8), public :: rji (3) real(kind=8), public :: rjk (3) real(kind=8), public :: rkl (3) real(kind=8), public :: rnj (3) real(kind=8), public :: rnk (3) real(kind=8), public :: scp real(kind=8), public :: phi real(kind=8), public :: sgn real(kind=8), public :: arg real(kind=8), public :: V integer, public :: ic","tags":"","loc":"proc/torsion_calc.html","title":"torsion_calc – Fortran Program"},{"text":"public subroutine dist_heading(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/dist_heading.html","title":"dist_heading – Fortran Program"},{"text":"public subroutine angle_heading(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/angle_heading.html","title":"angle_heading – Fortran Program"},{"text":"public subroutine torsion_heading(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/torsion_heading.html","title":"torsion_heading – Fortran Program"},{"text":"public function nb_add(desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: ats1 integer, public :: ats2","tags":"","loc":"proc/nb_add.html","title":"nb_add – Fortran Program"},{"text":"public function nb_qp_add(desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Variables Type Visibility Attributes Name Initial character(len=200), public :: line integer, public :: ires integer, public :: ats1 integer, public :: ats2","tags":"","loc":"proc/nb_qp_add.html","title":"nb_qp_add – Fortran Program"},{"text":"public subroutine nb_initialize() Arguments None","tags":"","loc":"proc/nb_initialize.html","title":"nb_initialize – Fortran Program"},{"text":"public subroutine nb_finalize(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/nb_finalize.html","title":"nb_finalize – Fortran Program"},{"text":"public subroutine nb_calc(i) Arguments Type Intent Optional Attributes Name integer :: i Variables Type Visibility Attributes Name Initial real(kind=8), public :: NB_Vlj real(kind=8), public :: NB_Vel","tags":"","loc":"proc/nb_calc.html","title":"nb_calc – Fortran Program"},{"text":"public subroutine nb_calc_lists(NB_Vlj, NB_Vel, nb_list) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: NB_Vlj real(kind=8), intent(out) :: NB_Vel type( NB_LIST_TYPE ), intent(in) :: nb_list Variables Type Visibility Attributes Name Initial real(kind=8), public :: r real(kind=8), public :: x1 real(kind=8), public :: x2 real(kind=8), public :: y1 real(kind=8), public :: y2 real(kind=8), public :: z1 real(kind=8), public :: z2 real(kind=8), public :: invr real(kind=8), public :: invr6 real(kind=8), public :: invr12 integer, public :: j integer, public :: k integer, public :: storleken","tags":"","loc":"proc/nb_calc_lists.html","title":"nb_calc_lists – Fortran Program"},{"text":"public subroutine nb_make_list(mask1, mask2, nb_list) Arguments Type Intent Optional Attributes Name type(MASK_TYPE), intent(in) :: mask1 type(MASK_TYPE), intent(in) :: mask2 type( NB_LIST_TYPE ) :: nb_list Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: k integer, public :: l integer, public :: m integer, public :: nat1 integer, public :: nat2 integer, public :: LJ_code integer, public :: nl integer, public :: qq_pair integer, public :: atomj integer, public :: atomk integer, public :: b integer, public :: size_groupm integer, public, allocatable :: group1 (:) integer, public, allocatable :: group2 (:) integer, public :: ljcod (255,255) integer, public :: groupm (nat_pro) logical, public :: NB","tags":"","loc":"proc/nb_make_list.html","title":"nb_make_list – Fortran Program"},{"text":"public subroutine nb_heading(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/nb_heading.html","title":"nb_heading – Fortran Program"},{"text":"public subroutine nb_qp_calc() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ires integer, public :: count integer, public :: i real(kind=8), public :: vdw real(kind=8), public :: el","tags":"","loc":"proc/nb_qp_calc.html","title":"nb_qp_calc – Fortran Program"},{"text":"public subroutine nb_qp_finalize() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ires","tags":"","loc":"proc/nb_qp_finalize.html","title":"nb_qp_finalize – Fortran Program"},{"text":"public function nb_add(desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: ats1 integer, public :: ats2","tags":"","loc":"proc/nb_add~2.html","title":"nb_add – Fortran Program"},{"text":"public function dist_group1(atom2) Arguments Type Intent Optional Attributes Name integer :: atom2 Return Value integer Variables Type Visibility Attributes Name Initial real, public :: x1 real, public :: x2 real, public :: y1 real, public :: y2 real, public :: z1 real, public :: z2","tags":"","loc":"proc/dist_group1.html","title":"dist_group1 – Fortran Program"},{"text":"public function nb_qp_add(desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Variables Type Visibility Attributes Name Initial character(len=200), public :: line integer, public :: ires integer, public :: ats1 integer, public :: ats2","tags":"","loc":"proc/nb_qp_add~2.html","title":"nb_qp_add – Fortran Program"},{"text":"public subroutine nb_initialize() Arguments None","tags":"","loc":"proc/nb_initialize~2.html","title":"nb_initialize – Fortran Program"},{"text":"public subroutine nb_finalize(i) Arguments Type Intent Optional Attributes Name integer :: i Variables Type Visibility Attributes Name Initial integer, public :: j","tags":"","loc":"proc/nb_finalize~2.html","title":"nb_finalize – Fortran Program"},{"text":"public subroutine calc_center() Arguments None Variables Type Visibility Attributes Name Initial integer, public, allocatable :: group1 (:) real, public :: sum_center_mask1 (3) integer, public :: nat1 integer, public :: j integer, public :: l","tags":"","loc":"proc/calc_center.html","title":"calc_center – Fortran Program"},{"text":"public subroutine nb_calc(i) Arguments Type Intent Optional Attributes Name integer :: i Variables Type Visibility Attributes Name Initial real(kind=8), public :: NB_Vlj real(kind=8), public :: NB_Vel","tags":"","loc":"proc/nb_calc~2.html","title":"nb_calc – Fortran Program"},{"text":"public subroutine nb_calc_lists(NB_Vlj, NB_Vel, nb_list) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: NB_Vlj real(kind=8), intent(out) :: NB_Vel type( NB_LIST_TYPE ), intent(in) :: nb_list Variables Type Visibility Attributes Name Initial real(kind=8), public :: r real(kind=8), public :: x1 real(kind=8), public :: x2 real(kind=8), public :: y1 real(kind=8), public :: y2 real(kind=8), public :: z1 real(kind=8), public :: z2 real(kind=8), public :: invr real(kind=8), public :: invr6 real(kind=8), public :: invr12 integer, public :: j integer, public :: k integer, public :: storleken","tags":"","loc":"proc/nb_calc_lists~2.html","title":"nb_calc_lists – Fortran Program"},{"text":"public subroutine nb_make_list(mask1, mask2, nb_list) Arguments Type Intent Optional Attributes Name type(MASK_TYPE), intent(in) :: mask1 type(MASK_TYPE), intent(in) :: mask2 type( NB_LIST_TYPE ) :: nb_list Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: k integer, public :: l integer, public :: m integer, public :: nat1 integer, public :: nat2 integer, public :: LJ_code integer, public :: nl integer, public :: qq_pair integer, public :: atomj integer, public :: atomk integer, public :: b integer, public :: size_groupm integer, public, allocatable :: group1 (:) integer, public, allocatable :: group2 (:) integer, public :: ljcod (255,255) integer, public :: groupm (nat_pro) logical, public :: NB","tags":"","loc":"proc/nb_make_list~2.html","title":"nb_make_list – Fortran Program"},{"text":"public subroutine nb_heading(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/nb_heading~2.html","title":"nb_heading – Fortran Program"},{"text":"public subroutine nb_qp_calc() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ires integer, public :: count integer, public :: i real(kind=8), public :: vdw real(kind=8), public :: el","tags":"","loc":"proc/nb_qp_calc~2.html","title":"nb_qp_calc – Fortran Program"},{"text":"public subroutine nb_qp_finalize() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ires","tags":"","loc":"proc/nb_qp_finalize~2.html","title":"nb_qp_finalize – Fortran Program"},{"text":"public function RDF_add(desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: ats","tags":"","loc":"proc/rdf_add.html","title":"RDF_add – Fortran Program"},{"text":"public function r(a, b) Arguments Type Intent Optional Attributes Name integer :: a integer :: b Return Value real Variables Type Visibility Attributes Name Initial real, public, dimension(3) :: delta","tags":"","loc":"proc/r.html","title":"r – Fortran Program"},{"text":"public function rdf_make_list(mask1, mask2, rdf_list) Arguments Type Intent Optional Attributes Name type(MASK_TYPE), intent(in) :: mask1 type(MASK_TYPE), intent(in) :: mask2 type( RDF_LIST_TYPE ) :: rdf_list Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: l integer, public :: m integer, public :: nat1 integer, public :: nat2 integer, public, allocatable :: group1 (:) integer, public, allocatable :: group2 (:)","tags":"","loc":"proc/rdf_make_list.html","title":"rdf_make_list – Fortran Program"},{"text":"public subroutine RDF_initialize() Arguments None","tags":"","loc":"proc/rdf_initialize.html","title":"RDF_initialize – Fortran Program"},{"text":"public subroutine RDF_finalize(i) Arguments Type Intent Optional Attributes Name integer :: i Variables Type Visibility Attributes Name Initial integer, public :: j real(kind=8), public :: volume","tags":"","loc":"proc/rdf_finalize.html","title":"RDF_finalize – Fortran Program"},{"text":"public subroutine RDF_calc(i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: binidx real, public :: dist","tags":"","loc":"proc/rdf_calc.html","title":"RDF_calc – Fortran Program"},{"text":"public subroutine RDF_heading(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/rdf_heading.html","title":"RDF_heading – Fortran Program"},{"text":"public function RMS_add(desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: ats","tags":"","loc":"proc/rms_add.html","title":"RMS_add – Fortran Program"},{"text":"public subroutine RMS_initialize() Arguments None","tags":"","loc":"proc/rms_initialize.html","title":"RMS_initialize – Fortran Program"},{"text":"public subroutine RMS_finalize(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/rms_finalize.html","title":"RMS_finalize – Fortran Program"},{"text":"public subroutine RMS_calc(i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Variables Type Visibility Attributes Name Initial real(kind=8), public :: r","tags":"","loc":"proc/rms_calc.html","title":"RMS_calc – Fortran Program"},{"text":"public subroutine RMS_make_ref(i) Arguments Type Intent Optional Attributes Name integer :: i Variables Type Visibility Attributes Name Initial integer, public :: at","tags":"","loc":"proc/rms_make_ref.html","title":"RMS_make_ref – Fortran Program"},{"text":"public subroutine RMS_heading(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/rms_heading.html","title":"RMS_heading – Fortran Program"},{"text":"public function RMSF_add(desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: ats","tags":"","loc":"proc/rmsf_add.html","title":"RMSF_add – Fortran Program"},{"text":"public subroutine RMSF_initialize() Arguments None","tags":"","loc":"proc/rmsf_initialize.html","title":"RMSF_initialize – Fortran Program"},{"text":"public subroutine RMSF_finalize(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/rmsf_finalize.html","title":"RMSF_finalize – Fortran Program"},{"text":"public subroutine RMSF_calc(i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Variables Type Visibility Attributes Name Initial real(kind=8), public :: r","tags":"","loc":"proc/rmsf_calc.html","title":"RMSF_calc – Fortran Program"},{"text":"public subroutine RMSF_make_ref(i) Arguments Type Intent Optional Attributes Name integer :: i Variables Type Visibility Attributes Name Initial integer, public :: at","tags":"","loc":"proc/rmsf_make_ref.html","title":"RMSF_make_ref – Fortran Program"},{"text":"public subroutine RMSF_heading(i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"proc/rmsf_heading.html","title":"RMSF_heading – Fortran Program"},{"text":"public function index_add(key, index) Arguments Type Intent Optional Attributes Name character(len=*) :: key integer :: index Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","loc":"proc/index_add.html","title":"index_add – Fortran Program"},{"text":"public function index_alias(alias, key) Arguments Type Intent Optional Attributes Name character(len=*) :: alias character(len=*) :: key Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: index","tags":"","loc":"proc/index_alias.html","title":"index_alias – Fortran Program"},{"text":"public function index_get(key, i, allow_wildcard) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key integer, intent(out) :: i logical , optional :: allow_wildcard Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: hi integer, public :: lo integer, public :: mid","tags":"","loc":"proc/index_get.html","title":"index_get – Fortran Program"},{"text":"public subroutine index_create(size) Arguments Type Intent Optional Attributes Name integer , optional :: size","tags":"","loc":"proc/index_create.html","title":"index_create – Fortran Program"},{"text":"public subroutine index_clear() Arguments None","tags":"","loc":"proc/index_clear.html","title":"index_clear – Fortran Program"},{"text":"public subroutine index_shutdown() Arguments None","tags":"","loc":"proc/index_shutdown.html","title":"index_shutdown – Fortran Program"},{"text":"public subroutine index_startup() Arguments None","tags":"","loc":"proc/index_startup.html","title":"index_startup – Fortran Program"},{"text":"public subroutine index_resize(size) Arguments Type Intent Optional Attributes Name integer :: size Variables Type Visibility Attributes Name Initial integer, public :: mintop type( indexentry ), public, pointer :: new_ndx (:)","tags":"","loc":"proc/index_resize.html","title":"index_resize – Fortran Program"},{"text":"public function mask_count(m) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m Return Value integer","tags":"","loc":"proc/mask_count.html","title":"mask_count – Fortran Program"},{"text":"public function mask_add(m, line, pretop) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m character(len=*) :: line logical, intent(in), optional :: pretop Return Value integer Variables Type Visibility Attributes Name Initial character(len=80), public :: word integer, public :: pos type(set), public :: s integer, public :: i logical, public :: empty integer, public :: readstat integer, public :: inthis","tags":"","loc":"proc/mask_add.html","title":"mask_add – Fortran Program"},{"text":"public subroutine mask_startup() Arguments None","tags":"","loc":"proc/mask_startup.html","title":"mask_startup – Fortran Program"},{"text":"public subroutine mask_shutdown() Arguments None","tags":"","loc":"proc/mask_shutdown.html","title":"mask_shutdown – Fortran Program"},{"text":"public subroutine mask_initialize(m) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m","tags":"","loc":"proc/mask_initialize.html","title":"mask_initialize – Fortran Program"},{"text":"public subroutine mask_finalize(m) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m","tags":"","loc":"proc/mask_finalize.html","title":"mask_finalize – Fortran Program"},{"text":"public subroutine mask_clear(m) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m","tags":"","loc":"proc/mask_clear.html","title":"mask_clear – Fortran Program"},{"text":"public subroutine mask_all(m) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m","tags":"","loc":"proc/mask_all.html","title":"mask_all – Fortran Program"},{"text":"public subroutine get_sybylcode(sybylname) Arguments Type Intent Optional Attributes Name character(len=*) :: sybylname Variables Type Visibility Attributes Name Initial integer, public :: i = 1 integer, public :: check_sybylcode character(len=5), public :: this_sybyl_caps","tags":"","loc":"proc/get_sybylcode.html","title":"get_sybylcode – Fortran Program"},{"text":"public subroutine mask_get(m, x, xmasked) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m real(kind=8) :: x (:) real :: xmasked (:) Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: i3 integer, public :: j","tags":"","loc":"proc/mask_get.html","title":"mask_get – Fortran Program"},{"text":"public subroutine mask_put(m, x, xmasked) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m real(kind=8) :: x (:) real :: xmasked (:) Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: i3 integer, public :: j","tags":"","loc":"proc/mask_put.html","title":"mask_put – Fortran Program"},{"text":"public function maskmanip_make(mask) Arguments Type Intent Optional Attributes Name type(MASK_TYPE) :: mask Return Value integer Variables Type Visibility Attributes Name Initial character(len=200), public :: line integer, public :: included integer, public :: inthis","tags":"","loc":"proc/maskmanip_make.html","title":"maskmanip_make – Fortran Program"},{"text":"public function maskmanip_make_pretop(mask) Arguments Type Intent Optional Attributes Name type(MASK_TYPE) :: mask Return Value integer Variables Type Visibility Attributes Name Initial character(len=200), public :: line integer, public :: included integer, public :: inthis logical, public :: pretop = .true.","tags":"","loc":"proc/maskmanip_make_pretop.html","title":"maskmanip_make_pretop – Fortran Program"},{"text":"public subroutine maskmanip_help() Arguments None","tags":"","loc":"proc/maskmanip_help.html","title":"maskmanip_help – Fortran Program"},{"text":"public subroutine maskmanip_help_pretop() Arguments None","tags":"","loc":"proc/maskmanip_help_pretop.html","title":"maskmanip_help_pretop – Fortran Program"},{"text":"public function freefile() Arguments None Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: u logical, public :: used","tags":"","loc":"proc/freefile.html","title":"freefile – Fortran Program"},{"text":"public function onoff(l) Arguments Type Intent Optional Attributes Name logical :: l Return Value character(len=3)","tags":"","loc":"proc/onoff.html","title":"onoff – Fortran Program"},{"text":"public function string_part(string, separator, start) Arguments Type Intent Optional Attributes Name character(len=*) :: string character(len=*) :: separator integer :: start Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: totlen","tags":"","loc":"proc/string_part.html","title":"string_part – Fortran Program"},{"text":"public function rtime() Arguments None Return Value real(kind=8) Variables Type Visibility Attributes Name Initial integer, public :: timevals (8)","tags":"","loc":"proc/rtime.html","title":"rtime – Fortran Program"},{"text":"public subroutine centered_heading(msg, fill) Arguments Type Intent Optional Attributes Name character(len=*) :: msg character :: fill Variables Type Visibility Attributes Name Initial integer, public :: n integer, public :: i","tags":"","loc":"proc/centered_heading.html","title":"centered_heading – Fortran Program"},{"text":"public subroutine skip_comments(unit) Arguments Type Intent Optional Attributes Name integer :: unit Variables Type Visibility Attributes Name Initial character(len=1000), public :: c","tags":"","loc":"proc/skip_comments.html","title":"skip_comments – Fortran Program"},{"text":"public subroutine getlin(intxt, outtxt) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: intxt character(len=*), intent(in), optional :: outtxt","tags":"","loc":"proc/getlin.html","title":"getlin – Fortran Program"},{"text":"public subroutine upcase(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: c","tags":"","loc":"proc/upcase.html","title":"upcase – Fortran Program"},{"text":"public subroutine locase(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: c","tags":"","loc":"proc/locase.html","title":"locase – Fortran Program"},{"text":"public function parse_open_file(filename) Arguments Type Intent Optional Attributes Name character(len=*) :: filename Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: stat","tags":"","loc":"proc/parse_open_file.html","title":"parse_open_file – Fortran Program"},{"text":"public function openit(lun, fil, stat, frm, mode) Arguments Type Intent Optional Attributes Name integer :: lun character(len=*) :: fil character(len=*) :: stat character(len=*) :: frm character(len=*) :: mode Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: errcode","tags":"","loc":"proc/openit.html","title":"openit – Fortran Program"},{"text":"public function get_string_single_line(arg, prompt) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arg character(len=*), intent(in), optional :: prompt Return Value logical","tags":"","loc":"proc/get_string_single_line.html","title":"get_string_single_line – Fortran Program"},{"text":"public function get_int_arg(prompt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: prompt Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: value","tags":"","loc":"proc/get_int_arg.html","title":"get_int_arg – Fortran Program"},{"text":"public function get_real_arg(prompt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: prompt Return Value real Variables Type Visibility Attributes Name Initial real, public :: value","tags":"","loc":"proc/get_real_arg.html","title":"get_real_arg – Fortran Program"},{"text":"public subroutine parse_startup() Arguments None","tags":"","loc":"proc/parse_startup.html","title":"parse_startup – Fortran Program"},{"text":"public subroutine split() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: p logical, public :: ws_flag logical, public :: quote_flag character, public, save :: TAB = achar(9) integer, public :: inlen integer, public :: trimlen (1)","tags":"","loc":"proc/split.html","title":"split – Fortran Program"},{"text":"public subroutine getline() Arguments None","tags":"","loc":"proc/getline.html","title":"getline – Fortran Program"},{"text":"public subroutine get_string_arg(arg, prompt) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arg character(len=*), intent(in), optional :: prompt","tags":"","loc":"proc/get_string_arg.html","title":"get_string_arg – Fortran Program"},{"text":"public subroutine get_line_arg(arg, prompt) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arg character(len=*), intent(in), optional :: prompt","tags":"","loc":"proc/get_line_arg.html","title":"get_line_arg – Fortran Program"},{"text":"public subroutine parse_reset() Arguments None","tags":"","loc":"proc/parse_reset.html","title":"parse_reset – Fortran Program"},{"text":"public function pref_add(name, ival, rval, sval) Arguments Type Intent Optional Attributes Name character(len=*), , target :: name integer, , optional target :: ival real, , optional target :: rval character(len=*), , optional target :: sval Return Value logical","tags":"","loc":"proc/pref_add.html","title":"pref_add – Fortran Program"},{"text":"public function pref_set(string, inval) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in), optional :: inval Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: i character(len=40), public :: name character(len=PREF_LEN), public :: value integer, public :: name_end integer, public :: readstat character(len=PREF_LEN), public :: line","tags":"","loc":"proc/pref_set.html","title":"pref_set – Fortran Program"},{"text":"public subroutine pref_initialize(max) Arguments Type Intent Optional Attributes Name integer , optional :: max","tags":"","loc":"proc/pref_initialize.html","title":"pref_initialize – Fortran Program"},{"text":"public subroutine pref_list(heading) Arguments Type Intent Optional Attributes Name character(len=*) , optional :: heading Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/pref_list.html","title":"pref_list – Fortran Program"},{"text":"public function anglecode(taci, tacj, tack) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: taci character(len=*), intent(in) :: tacj character(len=*), intent(in) :: tack Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: i character(len=KEYLENGTH), public :: ti character(len=KEYLENGTH), public :: tj character(len=KEYLENGTH), public :: tk","tags":"","loc":"proc/anglecode.html","title":"anglecode – Fortran Program"},{"text":"public function wildcard_tac(taci) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: taci Return Value character(len=keylength) Variables Type Visibility Attributes Name Initial integer, public :: hash_pos","tags":"","loc":"proc/wildcard_tac.html","title":"wildcard_tac – Fortran Program"},{"text":"public function bondcode(taci, tacj) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: taci character(len=*), intent(in) :: tacj Return Value integer Variables Type Visibility Attributes Name Initial character(len=keylength), public :: ti character(len=keylength), public :: tj integer, public :: i integer, public :: leni integer, public :: lenj integer, public :: score integer, public :: max_score = 0 integer, public :: max_cod","tags":"","loc":"proc/bondcode.html","title":"bondcode – Fortran Program"},{"text":"public function cross_product(a, b) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) real(kind=8) :: b (3) Return Value real(kind=8)\n  (3)","tags":"","loc":"proc/cross_product.html","title":"cross_product – Fortran Program"},{"text":"public function impcode(taci, tacj, tack, tacl) Arguments Type Intent Optional Attributes Name character(len=KEYLENGTH) :: taci character(len=KEYLENGTH) :: tacj character(len=KEYLENGTH) :: tack character(len=KEYLENGTH) :: tacl Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: i character(len=KEYLENGTH), public :: ti character(len=KEYLENGTH), public :: tj character(len=KEYLENGTH), public :: tk character(len=KEYLENGTH), public :: tl logical, public :: found1 logical, public :: found2 logical, public :: found3 logical, public :: found4","tags":"","loc":"proc/impcode.html","title":"impcode – Fortran Program"},{"text":"public function makeextrabonds() Arguments None Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: ix integer, public :: ib integer, public :: iaci integer, public :: iacj character(len=KEYLENGTH), public :: taci character(len=KEYLENGTH), public :: tacj","tags":"","loc":"proc/makeextrabonds.html","title":"makeextrabonds – Fortran Program"},{"text":"public function makesomebonds(startres, endres) Arguments Type Intent Optional Attributes Name integer :: startres integer :: endres Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ib integer, public :: ires integer, public :: imol","tags":"","loc":"proc/makesomebonds.html","title":"makesomebonds – Fortran Program"},{"text":"public function genH(j, residue) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: residue Return Value integer Variables Type Visibility Attributes Name Initial real(kind=8), public :: xj (3) real(kind=8), public :: xk (3) integer, public :: ligand integer, public :: H integer, public :: kt integer, public :: lt real(kind=8), public :: old_xH (3) real(kind=8), public :: xH (3) real(kind=8), public :: V real(kind=8), public :: Vtot real(kind=8), public :: dV (3) real(kind=8), public :: dvLast (3) real(kind=8), public :: gamma real(kind=8), public :: dVtot (3) real(kind=8), public :: VtotLast real(kind=8), public :: dx (3) real(kind=8), public :: dx_line real(kind=8), public :: rms_dV real(kind=8), public, parameter :: convergence_criterum = 0.1 real(kind=8), public, parameter :: dV_scale = 0.025 real(kind=8), public, parameter :: max_dx = 1. real(kind=8), public :: local_min = 30 real(kind=8), public :: tors_fk = 10. integer, public, parameter :: max_cg_iterations = 100 integer, public, parameter :: max_line_iterations = 35 integer, public :: cgiter integer, public :: lineiter real(kind=8), public :: bnd0 integer, public :: nHang integer, public :: Hang_atom (max_conn) integer, public :: Hang_code (max_conn) integer, public :: rule type( lib_entry_type ), public, pointer :: lp integer, public :: a integer, public :: b integer, public :: axis real(kind=8), public :: bond_length real(kind=8), public :: db real(kind=8), public :: rjH (3) real(kind=8), public :: rjk (3) real(kind=8), public :: bjHinv real(kind=8), public :: bjkinv real(kind=8), public :: scp real(kind=8), public :: angle real(kind=8), public :: angle_deg real(kind=8), public :: dVangle real(kind=8), public :: da real(kind=8), public :: f1 real(kind=8), public :: xkt (3) real(kind=8), public :: xlt (3) real(kind=8), public :: rjkt (3) real(kind=8), public :: rktlt (3) real(kind=8), public :: rnj (3) real(kind=8), public :: rnk (3) real(kind=8), public :: bj real(kind=8), public :: bk real(kind=8), public :: phi real(kind=8), public :: phi_deg real(kind=8), public :: sgn real(kind=8), public :: dVtors real(kind=8), public :: arg real(kind=8), public :: dH (3) logical, public :: flipped integer, public :: setH integer, public, parameter :: nsetH = 5","tags":"","loc":"proc/genh.html","title":"genH – Fortran Program"},{"text":"public function find_atom(ires, atom) Arguments Type Intent Optional Attributes Name integer :: ires character(len=5) :: atom Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: my_res integer, public :: iat integer, public :: irc character(len=4), public :: my_atom integer, public :: mol1 integer, public :: mol2","tags":"","loc":"proc/find_atom.html","title":"find_atom – Fortran Program"},{"text":"public function randm(seed, seed_only) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: seed logical, intent(in), optional :: seed_only Return Value real Variables Type Visibility Attributes Name Initial integer, public, parameter :: m = 100000000 integer, public, parameter :: m1 = 10000 integer, public, parameter :: mult = 31415821 integer, public, save :: irand = 0 integer, public :: irandh integer, public :: irandl integer, public :: multh integer, public :: multl real, public :: r","tags":"","loc":"proc/randm.html","title":"randm – Fortran Program"},{"text":"public function countpdb(pdb_fileno, atoms, residues, molecules) Arguments Type Intent Optional Attributes Name integer :: pdb_fileno integer :: atoms integer :: residues integer :: molecules Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: resno integer, public :: oldno character(len=4), public :: resnam character(len=4), public :: atnam character(len=4), public :: oldresnam character(len=80), public :: line real, public :: xtmp (3) integer, public :: atoms_in_res integer, public :: atoms_in_file integer, public :: rescode integer, public :: oldrescode","tags":"","loc":"proc/countpdb.html","title":"countpdb – Fortran Program"},{"text":"public function set_irc_solvent() Arguments None Return Value logical","tags":"","loc":"proc/set_irc_solvent.html","title":"set_irc_solvent – Fortran Program"},{"text":"public function get_atom_from_descriptor(aid) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: aid Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: separator_pos character(len=20), public :: res_str character(len=5), public :: atom_str integer, public :: filestat integer, public :: resnum integer, public :: atnum","tags":"","loc":"proc/get_atom_from_descriptor.html","title":"get_atom_from_descriptor – Fortran Program"},{"text":"public function set_boundary_condition() Arguments None Return Value logical Variables Type Visibility Attributes Name Initial character(len=80), public :: kind_of_boundary","tags":"","loc":"proc/set_boundary_condition.html","title":"set_boundary_condition – Fortran Program"},{"text":"public function set_simulation_sphere() Arguments None Return Value logical Variables Type Visibility Attributes Name Initial character(len=80), public :: line integer, public :: filestat integer, public :: centre_atom real, public :: rwat_in real, public :: xwat_in","tags":"","loc":"proc/set_simulation_sphere.html","title":"set_simulation_sphere – Fortran Program"},{"text":"public function set_solvent_box() Arguments None Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: i character(len=80), public :: line integer, public :: centre_atom integer, public :: filestat real, public :: xwat_in real, public :: coord_in","tags":"","loc":"proc/set_solvent_box.html","title":"set_solvent_box – Fortran Program"},{"text":"public function set_solvent_sphere() Arguments None Return Value logical Variables Type Visibility Attributes Name Initial character(len=80), public :: line integer, public :: filestat integer, public :: centre_atom real, public :: rwat_in real, public :: xwat_in","tags":"","loc":"proc/set_solvent_sphere.html","title":"set_solvent_sphere – Fortran Program"},{"text":"public function rwat_eff() Arguments None Return Value real Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: kr integer, public :: isort integer, public :: bins real(kind=8), public :: rc real(kind=8), public :: rnwat integer, public, allocatable :: npro_of_r (:) real(kind=8), public :: rho_ratio real(kind=8), public :: solvent_volume real(kind=8), public :: rho_solvent","tags":"","loc":"proc/rwat_eff.html","title":"rwat_eff – Fortran Program"},{"text":"public function torcode(taci, tacj, tack, tacl) Arguments Type Intent Optional Attributes Name character(len=KEYLENGTH) :: taci character(len=KEYLENGTH) :: tacj character(len=KEYLENGTH) :: tack character(len=KEYLENGTH) :: tacl Return Value type( tor_codes ) Variables Type Visibility Attributes Name Initial integer, public :: i character(len=KEYLENGTH), public :: ti character(len=KEYLENGTH), public :: tj character(len=KEYLENGTH), public :: tk character(len=KEYLENGTH), public :: tl","tags":"","loc":"proc/torcode.html","title":"torcode – Fortran Program"},{"text":"public function check_residues() Arguments None Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","loc":"proc/check_residues.html","title":"check_residues – Fortran Program"},{"text":"public function get_centre_by_mass(centre) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: centre (3) Return Value logical Variables Type Visibility Attributes Name Initial type(mask_type), public :: mask integer, public :: ats integer, public :: imaskat integer, public :: iat real(kind=8), public :: totmass real(kind=8), public :: mass","tags":"","loc":"proc/get_centre_by_mass.html","title":"get_centre_by_mass – Fortran Program"},{"text":"public subroutine prep_startup() Arguments None Variables Type Visibility Attributes Name Initial logical, public :: l","tags":"","loc":"proc/prep_startup.html","title":"prep_startup – Fortran Program"},{"text":"public subroutine allocate_for_pdb(atoms, residues, molecules) Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms integer, intent(in) :: residues integer, intent(in) :: molecules","tags":"","loc":"proc/allocate_for_pdb.html","title":"allocate_for_pdb – Fortran Program"},{"text":"public subroutine prep_shutdown() Arguments None","tags":"","loc":"proc/prep_shutdown.html","title":"prep_shutdown – Fortran Program"},{"text":"public subroutine clearlib() Arguments None","tags":"","loc":"proc/clearlib.html","title":"clearlib – Fortran Program"},{"text":"public subroutine addbond() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ia integer, public :: ja real(kind=8), public :: bond_dist real(kind=8), public :: rij (3) character(len=80), public :: reply integer, public :: readstat","tags":"","loc":"proc/addbond.html","title":"addbond – Fortran Program"},{"text":"public subroutine clearbond() Arguments None","tags":"","loc":"proc/clearbond.html","title":"clearbond – Fortran Program"},{"text":"public subroutine angle_ene(emax, nlarge, av_ene) Arguments Type Intent Optional Attributes Name real :: emax integer :: nlarge real :: av_ene Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: ia integer, public :: ic integer, public :: istart integer, public :: iend integer, public :: i3 integer, public :: j3 integer, public :: k3 real, public :: rji (3) real, public :: rjk (3) real, public :: bji real, public :: bjk real, public :: scp real, public :: angle real, public :: da real, public :: ae real, public :: dv real, public :: f1 real, public :: di (3) real, public :: dk (3)","tags":"","loc":"proc/angle_ene.html","title":"angle_ene – Fortran Program"},{"text":"public subroutine bond_ene(emax, nlarge, av_ene) Arguments Type Intent Optional Attributes Name real :: emax integer :: nlarge real :: av_ene Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: ib integer, public :: ic integer, public :: istart integer, public :: iend integer, public :: i3 integer, public :: j3 real, public :: rij (3) real, public :: b real, public :: db real, public :: be real, public :: dv","tags":"","loc":"proc/bond_ene.html","title":"bond_ene – Fortran Program"},{"text":"public subroutine changeimp() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ii integer, public :: ip integer, public :: i integer, public :: j integer, public :: k integer, public :: l integer, public :: noptimp integer, public :: nchange integer, public :: nlarge real, public :: emax real, public :: av_ene","tags":"","loc":"proc/changeimp.html","title":"changeimp – Fortran Program"},{"text":"public subroutine checkangs() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nlarge real, public :: emax real, public :: av_ene","tags":"","loc":"proc/checkangs.html","title":"checkangs – Fortran Program"},{"text":"public subroutine checkbonds() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nlarge real, public :: emax real, public :: av_ene","tags":"","loc":"proc/checkbonds.html","title":"checkbonds – Fortran Program"},{"text":"public subroutine checkimps() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nlarge real, public :: emax real, public :: av_ene","tags":"","loc":"proc/checkimps.html","title":"checkimps – Fortran Program"},{"text":"public subroutine checktors() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nlarge real, public :: emax real, public :: av_ene","tags":"","loc":"proc/checktors.html","title":"checktors – Fortran Program"},{"text":"public subroutine xlink() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ires integer, public :: jres integer, public :: iat integer, public :: jat integer, public :: i integer, public :: j integer, public :: b integer, public :: irc integer, public :: jrc real, public :: d2 character(len=1), public :: reply","tags":"","loc":"proc/xlink.html","title":"xlink – Fortran Program"},{"text":"public subroutine impr_ene(emax, nlarge, av_ene, mode) Arguments Type Intent Optional Attributes Name real :: emax integer :: nlarge real :: av_ene integer :: mode Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: l integer, public :: ip integer, public :: ic integer, public :: i3 integer, public :: j3 integer, public :: k3 integer, public :: l3 real, public :: rji (3) real, public :: rjk (3) real, public :: rkl (3) real, public :: rnj (3) real, public :: rnk (3) real, public :: bj real, public :: bk real, public :: scp real, public :: phi real, public :: sgn real, public :: pe real, public :: dv real, public :: rki (3) real, public :: rlj (3) real, public :: dp (12) real, public :: arg real, public :: f1 real, public :: di (3) real, public :: dl (3)","tags":"","loc":"proc/impr_ene.html","title":"impr_ene – Fortran Program"},{"text":"public subroutine listres() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iat integer, public :: ires type( lib_entry_type ), public, pointer :: lp","tags":"","loc":"proc/listres.html","title":"listres – Fortran Program"},{"text":"public subroutine listseq() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/listseq.html","title":"listseq – Fortran Program"},{"text":"public subroutine make14list() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: it integer, public :: i integer, public :: j integer, public :: ioff integer, public :: l","tags":"","loc":"proc/make14list.html","title":"make14list – Fortran Program"},{"text":"public subroutine makeangles() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ib integer, public :: jb integer, public :: ia integer, public :: i integer, public :: j integer, public :: k integer, public :: iaci integer, public :: iacj integer, public :: iack logical, public :: used (nang_prm+max_extrabnd) integer, public :: itrans (nang_prm+max_extrabnd)","tags":"","loc":"proc/makeangles.html","title":"makeangles – Fortran Program"},{"text":"public subroutine make_solute_bonds() Arguments None","tags":"","loc":"proc/make_solute_bonds.html","title":"make_solute_bonds – Fortran Program"},{"text":"public subroutine makebonds() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: nbonds_solvent integer, public :: nbonds_extra integer, public :: i","tags":"","loc":"proc/makebonds.html","title":"makebonds – Fortran Program"},{"text":"public subroutine set_bondcodes() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ib integer, public :: iaci integer, public :: iacj logical, public :: used (nbnd_prm) integer, public :: itrans (nbnd_prm) character(len=keylength), public :: taci character(len=keylength), public :: tacj","tags":"","loc":"proc/set_bondcodes.html","title":"set_bondcodes – Fortran Program"},{"text":"public subroutine makeexlist() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ib integer, public :: ia integer, public :: i integer, public :: j integer, public :: ioff","tags":"","loc":"proc/makeexlist.html","title":"makeexlist – Fortran Program"},{"text":"public subroutine makehyds() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: nH_solute integer, public :: nH_solvent integer, public :: nH_required real, public :: r integer, public :: atom integer, public :: residue","tags":"","loc":"proc/makehyds.html","title":"makehyds – Fortran Program"},{"text":"public subroutine makeimps() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/makeimps.html","title":"makeimps – Fortran Program"},{"text":"public subroutine imp_params() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ii integer, public :: iaci integer, public :: iacj integer, public :: iack integer, public :: iacl integer, public :: iused (nimp_prm+max_extrabnd) integer, public :: itrans (nimp_prm+max_extrabnd)","tags":"","loc":"proc/imp_params.html","title":"imp_params – Fortran Program"},{"text":"public subroutine makeimps_explicit() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ires integer, public :: irc integer, public :: iimp integer, public :: i","tags":"","loc":"proc/makeimps_explicit.html","title":"makeimps_explicit – Fortran Program"},{"text":"public subroutine maketop() Arguments None","tags":"","loc":"proc/maketop.html","title":"maketop – Fortran Program"},{"text":"public subroutine set_default_mask() Arguments None","tags":"","loc":"proc/set_default_mask.html","title":"set_default_mask – Fortran Program"},{"text":"public subroutine makeconn() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ib","tags":"","loc":"proc/makeconn.html","title":"makeconn – Fortran Program"},{"text":"public subroutine maketors() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: ic integer, public :: jc integer, public :: ib integer, public :: it integer, public :: iaci integer, public :: iacj integer, public :: iack integer, public :: iacl integer, public :: iused (ntor_prm+max_extrabnd) integer, public :: itrans (ntor_prm+max_extrabnd) type( tor_codes ), public :: torcodes integer, public :: icod","tags":"","loc":"proc/maketors.html","title":"maketors – Fortran Program"},{"text":"public subroutine prompt(outtxt) Arguments Type Intent Optional Attributes Name character(len=*) :: outtxt","tags":"","loc":"proc/prompt.html","title":"prompt – Fortran Program"},{"text":"public subroutine oldreadlib(filnam) Arguments Type Intent Optional Attributes Name character(len=*) :: filnam Variables Type Visibility Attributes Name Initial character, public :: line *200 integer, public :: irec integer, public :: i integer, public :: iat integer, public :: ires integer, public :: j integer, public :: igp integer, public :: ntot real, public :: qtot real, public :: qgrp real, public :: qtot_grp character(len=KEYLENGTH), public, pointer :: tac_lib (:) character(len=4), public, pointer :: atnam (:) real, public, pointer :: crg_lib (:) integer(kind=AI), public, pointer :: natcgp (:) integer(kind=AI), public, pointer :: switch (:) integer(kind=AI), public, pointer :: atcgp (:,:) type( lib_bond_type ), public, pointer :: bnd (:) integer, public :: stat","tags":"","loc":"proc/oldreadlib.html","title":"oldreadlib – Fortran Program"},{"text":"public subroutine readlib(file) Arguments Type Intent Optional Attributes Name character(len=*) , optional :: file Variables Type Visibility Attributes Name Initial character, public :: line *200 character, public :: filnam *200 integer, public :: irec integer, public :: i integer, public :: iat integer, public :: ires integer, public :: j integer, public :: igp integer, public :: ntot real, public :: qtot real, public :: qgrp real, public :: qtot_grp character(len=80), public :: resnam integer, public :: res_count logical, public :: prm_res integer, public :: cgp_read (max_atcgplib) character(len=KEYLENGTH), public, pointer :: tac_lib (:) character(len=4), public, pointer :: atnam (:) real, public, pointer :: crg_lib (:) integer(kind=AI), public, pointer :: natcgp (:) integer(kind=AI), public, pointer :: switch (:) integer(kind=AI), public, pointer :: atcgp (:,:) type( lib_bond_type ), public, pointer :: bnd (:) type( lib_imp_type ), public, pointer :: imp (:) logical, public :: lib_exists character(len=8), public :: atnam1 character(len=8), public :: atnam2 character(len=8), public :: atnam3 character(len=8), public :: atnam4 integer, public :: atno1 integer, public :: atno2 integer, public :: atno3 integer, public :: atno4 logical, public :: yes integer, public :: atoms_in_rule integer, public :: readstat","tags":"","loc":"proc/readlib.html","title":"readlib – Fortran Program"},{"text":"public subroutine check_overload(resnam) Arguments Type Intent Optional Attributes Name character(len=80) :: resnam Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/check_overload.html","title":"check_overload – Fortran Program"},{"text":"public subroutine oldreadparm(flag) Arguments Type Intent Optional Attributes Name logical :: flag Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ityp integer, public :: filestat character(len=200), public :: line character(len=KEYLENGTH), public :: taci character(len=KEYLENGTH), public :: tacj character(len=KEYLENGTH), public :: tack character(len=KEYLENGTH), public :: tacl integer, public :: iaci integer, public :: iacj integer, public :: iack integer, public :: iacl","tags":"","loc":"proc/oldreadparm.html","title":"oldreadparm – Fortran Program"},{"text":"public subroutine readff() Arguments None","tags":"","loc":"proc/readff.html","title":"readff – Fortran Program"},{"text":"public subroutine readparm(filnam) Arguments Type Intent Optional Attributes Name character(len=*) :: filnam Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ityp integer, public :: j character(len=200), public :: line character(len=200), public :: restofline real, public :: rdummy logical, public :: ldummy character(len=KEYLENGTH), public :: taci character(len=KEYLENGTH), public :: tacj character(len=KEYLENGTH), public :: tack character(len=KEYLENGTH), public :: tacl integer, public :: iaci integer, public :: iacj integer, public :: iack integer, public :: iacl character(len=80), public :: section logical, public :: SYBYL_warn = .false. integer, public :: naliases type( bond_prm_type ), public :: bnd_prm_tmp type( anglib_type ), public :: ang_prm_tmp type( torlib_type ), public :: tor_prm_tmp","tags":"","loc":"proc/readparm.html","title":"readparm – Fortran Program"},{"text":"public subroutine clearpdb() Arguments None","tags":"","loc":"proc/clearpdb.html","title":"clearpdb – Fortran Program"},{"text":"public subroutine cleartop() Arguments None","tags":"","loc":"proc/cleartop.html","title":"cleartop – Fortran Program"},{"text":"public subroutine readpdb() Arguments None Variables Type Visibility Attributes Name Initial character(len=256), public :: pdb_file character, public :: atnam_tmp *4 character, public :: resnam_tmp *4 character(len=80), public :: line integer, public :: resnum_tmp integer, public :: oldnum integer, public :: irec integer, public :: i integer, public :: atom_id (max_atlib) integer, public :: j real, public :: xtmp (3) logical, public :: res_found logical, public :: at_found integer, public :: first_res_of_mol logical, public :: last_line_was_gap integer, public :: atoms integer, public :: residues integer, public :: molecules","tags":"","loc":"proc/readpdb.html","title":"readpdb – Fortran Program"},{"text":"public subroutine readtop() Arguments None Variables Type Visibility Attributes Name Initial character(len=200), public :: filnam character(len=200), public :: files_to_load integer, public :: i integer, public :: j integer, public :: ires logical, public :: loaded logical, public :: res_found integer, public :: fn_start integer, public :: fn_end integer, public :: totlen character(len=4), public :: resnam_tmp","tags":"","loc":"proc/readtop.html","title":"readtop – Fortran Program"},{"text":"public subroutine readx() Arguments None Variables Type Visibility Attributes Name Initial character(len=80), public :: filnam integer, public :: i integer(kind=4), public :: nat3 integer, public :: u","tags":"","loc":"proc/readx.html","title":"readx – Fortran Program"},{"text":"public subroutine readnext() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: filestat integer, public :: nat3 logical, public :: isopen character(len=10), public :: buf","tags":"","loc":"proc/readnext.html","title":"readnext – Fortran Program"},{"text":"public subroutine readframe() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: frame","tags":"","loc":"proc/readframe.html","title":"readframe – Fortran Program"},{"text":"public subroutine trajectory() Arguments None Variables Type Visibility Attributes Name Initial character(len=80), public :: reply","tags":"","loc":"proc/trajectory.html","title":"trajectory – Fortran Program"},{"text":"public subroutine modify_mask() Arguments None Variables Type Visibility Attributes Name Initial character(len=80), public :: mask_def integer, public :: atoms_added","tags":"","loc":"proc/modify_mask.html","title":"modify_mask – Fortran Program"},{"text":"public subroutine set_cgp() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ires integer, public :: igp integer, public :: i integer, public :: ntot integer, public :: ntot_solute integer, public :: i3 integer, public :: switchatom integer, public :: ia integer, public :: ncgp_skipped = 0 real, public :: r2 real(kind=8), public :: cgp_cent (3) integer, public :: nheavy","tags":"","loc":"proc/set_cgp.html","title":"set_cgp – Fortran Program"},{"text":"public subroutine set_crg() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ires integer, public :: i integer, public :: ntot","tags":"","loc":"proc/set_crg.html","title":"set_crg – Fortran Program"},{"text":"public subroutine set_iac() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ires integer, public :: i integer, public :: ntot integer, public :: iaci logical, public :: used (max_atyps)","tags":"","loc":"proc/set_iac.html","title":"set_iac – Fortran Program"},{"text":"public subroutine set_solvent_type() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: irc_solvent integer, public :: i integer, public :: iac_H1 integer, public :: iac_H2 logical, public :: dummy","tags":"","loc":"proc/set_solvent_type.html","title":"set_solvent_type – Fortran Program"},{"text":"public subroutine define_boundary_condition() Arguments None","tags":"","loc":"proc/define_boundary_condition.html","title":"define_boundary_condition – Fortran Program"},{"text":"public subroutine solvate() Arguments None","tags":"","loc":"proc/solvate.html","title":"solvate – Fortran Program"},{"text":"public subroutine solvate_box() Arguments None Variables Type Visibility Attributes Name Initial character(len=80), public :: solvate_mode","tags":"","loc":"proc/solvate_box.html","title":"solvate_box – Fortran Program"},{"text":"public subroutine solvate_box_grid() Arguments None Variables Type Visibility Attributes Name Initial real(kind=8), public :: xmin real(kind=8), public :: xmax real(kind=8), public :: ymin real(kind=8), public :: ymax real(kind=8), public :: zmin real(kind=8), public :: zmax real(kind=8), public :: xgrid real(kind=8), public :: ygrid real(kind=8), public :: zgrid integer, public :: max_wat integer, public :: waters_in_box real(kind=8), public :: radius2 real(kind=8), public :: solvent_grid character(len=200), public :: solvent","tags":"","loc":"proc/solvate_box_grid.html","title":"solvate_box_grid – Fortran Program"},{"text":"public subroutine solvate_box_file() Arguments None Variables Type Visibility Attributes Name Initial character(len=80), public :: xwat_file integer, public :: fstat character(len=80), public :: line real(kind=8), public :: boxl real(kind=8), public :: waterbox_v real(kind=8), public :: waterbox (1:3) character(len=6), public :: sphere logical, public :: replicate integer, public :: extension (1:3) real(kind=8), public :: extensionbox_v real(kind=8), public :: ext (3,3) integer, public :: nw integer, public :: nnw integer, public :: i integer, public :: j integer, public :: k integer, public :: filestat character(len=3), public :: atomnames character(len=4), public :: resnam (3) integer, public :: resno (3) integer, public :: nbox integer, public :: nwat_allocate real(kind=8), public :: xcm (3) real(kind=8), public :: wshift (3) integer, public :: nwat_keep real(kind=8), public :: temp (3)","tags":"","loc":"proc/solvate_box_file.html","title":"solvate_box_file – Fortran Program"},{"text":"public subroutine solvate_sphere() Arguments None Variables Type Visibility Attributes Name Initial character(len=80), public :: solvate_mode","tags":"","loc":"proc/solvate_sphere.html","title":"solvate_sphere – Fortran Program"},{"text":"public subroutine solvate_sphere_grid() Arguments None Variables Type Visibility Attributes Name Initial real(kind=8), public :: xmin real(kind=8), public :: xmax real(kind=8), public :: ymin real(kind=8), public :: ymax real(kind=8), public :: zmin real(kind=8), public :: zmax real(kind=8), public :: xgrid real(kind=8), public :: ygrid real(kind=8), public :: zgrid integer, public :: max_wat integer, public :: waters_in_sphere real(kind=8), public :: radius2 real(kind=8), public :: solvent_grid character(len=200), public :: solvent","tags":"","loc":"proc/solvate_sphere_grid.html","title":"solvate_sphere_grid – Fortran Program"},{"text":"public subroutine solvate_sphere_file(shift) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: shift Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: nw integer, public :: nnw integer, public :: nwat_allocate integer, public :: nwat_keep real(kind=8), public :: rmax2 real(kind=8), public :: dx2 real(kind=8), public :: boxl real(kind=8), public :: newboxl real(kind=8), public, save :: xcm (3) real(kind=8), public, save :: wshift (3) integer, public :: fstat logical, public :: is_box character(len=6), public :: sphere character(len=80), public :: line real(kind=8), public :: volume real, public :: r4dum character(len=80), public :: xwat_file real(kind=8), public :: xwshift (3,7) integer, public :: box character(len=3), public :: atomnames integer, public :: filestat character(len=10), public :: filepos integer, public :: resno (3) character(len=4), public :: resnam (3) real(kind=8), public :: xwtmp (3,max_atlib) integer, public :: at_id (max_atlib)","tags":"","loc":"proc/solvate_sphere_file.html","title":"solvate_sphere_file – Fortran Program"},{"text":"public subroutine solvate_restart() Arguments None Variables Type Visibility Attributes Name Initial integer(kind=4), public :: natom integer(kind=4), public :: nat3 integer(kind=4), public :: waters_added character(len=80), public :: xfile integer, public :: u integer, public :: fstat real(kind=8), public, allocatable :: xtmp (:) character(len=200), public :: solvent","tags":"","loc":"proc/solvate_restart.html","title":"solvate_restart – Fortran Program"},{"text":"public subroutine add_solvent_to_topology(waters_in_sphere, max_waters, make_hydrogens, pack) Arguments Type Intent Optional Attributes Name integer :: waters_in_sphere integer :: max_waters logical :: make_hydrogens real :: pack Description *PWchanged way of computing packing *PWadded new loop checking water-water distance Variables Type Visibility Attributes Name Initial integer, public :: waters_added real(kind=8), public :: rpack2 integer, public :: w_at integer, public :: w_mol integer, public :: p_atom logical, public :: wheavy (max_atlib) real(kind=8), public :: dx real(kind=8), public :: dy real(kind=8), public :: dz real(kind=8), public :: r2 integer, public :: next_wat integer, public :: next_atom","tags":"","loc":"proc/add_solvent_to_topology.html","title":"add_solvent_to_topology – Fortran Program"},{"text":"public subroutine grow_arrays_for_solvent(nmore, atoms_per_molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmore integer, intent(in) :: atoms_per_molecule Variables Type Visibility Attributes Name Initial real(kind=8), public, allocatable :: r8temp (:) logical, public, allocatable :: ltemp (:) integer, public, allocatable :: itemp (:) integer, public :: new_nat integer, public :: nat3old type( residue_type ), public, allocatable :: restemp (:)","tags":"","loc":"proc/grow_arrays_for_solvent.html","title":"grow_arrays_for_solvent – Fortran Program"},{"text":"public subroutine tors_ene(emax, nlarge, av_ene) Arguments Type Intent Optional Attributes Name real :: emax integer :: nlarge real :: av_ene Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: l integer, public :: ip integer, public :: ic integer, public :: i3 integer, public :: j3 integer, public :: k3 integer, public :: l3 real, public :: rji (3) real, public :: rjk (3) real, public :: rkl (3) real, public :: rnj (3) real, public :: rnk (3) real, public :: bj real, public :: bk real, public :: scp real, public :: phi real, public :: sgn real, public :: pe real, public :: dv real, public :: rki (3) real, public :: rlj (3) real, public :: dp (12) real, public :: arg real, public :: f1 real, public :: di (3) real, public :: dl (3)","tags":"","loc":"proc/tors_ene.html","title":"tors_ene – Fortran Program"},{"text":"public subroutine writepdb() Arguments None Variables Type Visibility Attributes Name Initial character(len=80), public :: filnam character(len=1), public :: reply character(len=*), public, parameter :: gap = '                 GAP                                      ' character(len=*), public, parameter :: ter = 'TER   ' integer, public :: i integer, public :: j integer, public :: k integer, public :: l integer, public :: imol integer, public :: iat integer, public :: iwrite_g logical, public :: wrote_atom_in_molecule character(len=6), public :: PDBtype integer, public :: lig (4)","tags":"","loc":"proc/writepdb.html","title":"writepdb – Fortran Program"},{"text":"public subroutine writemol2() Arguments None Variables Type Visibility Attributes Name Initial character, public :: filnam *80 character, public :: reply *1 character, public :: mol_name *16 character, public :: ti *1 character, public :: tj *1 integer, public :: i integer, public :: cnt integer, public :: j integer, public :: iat integer, public :: u integer, public :: mol integer, public :: mol_start integer, public :: mol_end integer, public :: nat_mol integer, public :: nbnd_mol integer, public :: at_start integer, public :: at_end integer, public :: res_start integer, public :: res_end integer, public :: bnd_start integer, public :: bnd_end integer, public :: new_last integer, public :: new_res logical, public :: iwrite_h logical, public :: iwrite_w integer, public :: nres_mol integer, public :: res_atoms (nres) integer, public :: new_num (nat_pro) integer, public :: new_resnum (nres) integer, public :: dict_type","tags":"","loc":"proc/writemol2.html","title":"writemol2 – Fortran Program"},{"text":"public subroutine writetop() Arguments None Variables Type Visibility Attributes Name Initial character, public :: filnam *80 integer, public :: i integer, public :: j integer, public :: ig character, public :: answer *10","tags":"","loc":"proc/writetop.html","title":"writetop – Fortran Program"},{"text":"public subroutine listprefs() Arguments None","tags":"","loc":"proc/listprefs.html","title":"listprefs – Fortran Program"},{"text":"public subroutine set() Arguments None Variables Type Visibility Attributes Name Initial character(len=PREF_LEN), public :: name character(len=PREF_LEN), public :: value logical, public :: l","tags":"","loc":"proc/set.html","title":"set – Fortran Program"},{"text":"public subroutine make_shell2() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ig integer, public :: i3 integer, public :: k real(kind=8), public :: rout2 real(kind=8), public :: rin2 real(kind=8), public :: r2 real(kind=8), public, allocatable :: cgp_cent (:,:)","tags":"","loc":"proc/make_shell2.html","title":"make_shell2 – Fortran Program"},{"text":"public function prm_get_integer_by_key(key, value, default) Arguments Type Intent Optional Attributes Name character(len=*) :: key integer, intent(out) :: value integer, intent(in), optional :: default Return Value logical Variables Type Visibility Attributes Name Initial character(len=80), public :: inkey","tags":"","loc":"proc/prm_get_integer_by_key.html","title":"prm_get_integer_by_key – Fortran Program"},{"text":"public function prm_get_real_by_key(key, value, default) Arguments Type Intent Optional Attributes Name character(len=*) :: key real, intent(out) :: value real, intent(in), optional :: default Return Value logical Variables Type Visibility Attributes Name Initial character(len=80), public :: inkey","tags":"","loc":"proc/prm_get_real_by_key.html","title":"prm_get_real_by_key – Fortran Program"},{"text":"public function prm_get_real8_by_key(key, value, default) Arguments Type Intent Optional Attributes Name character(len=*) :: key real(kind=8), intent(out) :: value real(kind=8), intent(in), optional :: default Return Value logical Variables Type Visibility Attributes Name Initial character(len=80), public :: inkey","tags":"","loc":"proc/prm_get_real8_by_key.html","title":"prm_get_real8_by_key – Fortran Program"},{"text":"public function prm_get_string_by_key(key, value, default) Arguments Type Intent Optional Attributes Name character(len=*) :: key character(len=*), intent(out) :: value character(len=*), intent(in), optional :: default Return Value logical Variables Type Visibility Attributes Name Initial character(len=80), public :: mykey character(len=80), public :: inkey character(len=80), public :: invalue","tags":"","loc":"proc/prm_get_string_by_key.html","title":"prm_get_string_by_key – Fortran Program"},{"text":"public function prm_get_line_by_key(key, value, default) Arguments Type Intent Optional Attributes Name character(len=*) :: key character(len=*), intent(out) :: value character(len=*), intent(in), optional :: default Return Value logical Variables Type Visibility Attributes Name Initial character(len=80), public :: inkey character(len=200), public :: invalue","tags":"","loc":"proc/prm_get_line_by_key.html","title":"prm_get_line_by_key – Fortran Program"},{"text":"public function prm_get_logical_by_key(key, value, default) Arguments Type Intent Optional Attributes Name character(len=*) :: key logical, intent(out) :: value logical, intent(in), optional :: default Return Value logical Variables Type Visibility Attributes Name Initial character(len=80), public :: inkey character(len=80), public :: invalue","tags":"","loc":"proc/prm_get_logical_by_key.html","title":"prm_get_logical_by_key – Fortran Program"},{"text":"public function prm_get_line(line) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: line Return Value logical","tags":"","loc":"proc/prm_get_line.html","title":"prm_get_line – Fortran Program"},{"text":"public function prm_get_field(field, skip) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: field logical, intent(in), optional :: skip Return Value logical Variables Type Visibility Attributes Name Initial character(len=500), public, save :: line integer, public, save :: pos integer, public, save :: linelen type( LINE_TYPE ), public, pointer, save :: my_line character, public, save :: TAB = char(9) integer, public :: start_field integer, public :: end_field logical, public :: prm_res","tags":"","loc":"proc/prm_get_field.html","title":"prm_get_field – Fortran Program"},{"text":"public function prm_count(section) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: section Return Value integer","tags":"","loc":"proc/prm_count.html","title":"prm_count – Fortran Program"},{"text":"public function prm_max_enum(section, count_out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: section integer, intent(out), optional :: count_out Return Value integer Variables Type Visibility Attributes Name Initial character(len=200), public :: line integer, public :: max_enum integer, public :: enum integer, public :: count logical, public :: dummy","tags":"","loc":"proc/prm_max_enum.html","title":"prm_max_enum – Fortran Program"},{"text":"public function prm_max_enum2(section, count_out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: section integer, intent(out), optional :: count_out Return Value integer Variables Type Visibility Attributes Name Initial character(len=200), public :: line character(len=200), public :: tmp_str integer, public :: max_enum integer, public :: enum integer, public :: count logical, public :: dummy","tags":"","loc":"proc/prm_max_enum2.html","title":"prm_max_enum2 – Fortran Program"},{"text":"public function prm_get_string_string(key, value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: key character(len=*), intent(out) :: value Return Value logical","tags":"","loc":"proc/prm_get_string_string.html","title":"prm_get_string_string – Fortran Program"},{"text":"public function prm_get_string_line(key, value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: key character(len=*), intent(out) :: value Return Value logical Variables Type Visibility Attributes Name Initial character(len=200), public :: line logical, public :: stat","tags":"","loc":"proc/prm_get_string_line.html","title":"prm_get_string_line – Fortran Program"},{"text":"public function prm_get_string_int(key, value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: key integer, intent(out) :: value Return Value logical Variables Type Visibility Attributes Name Initial character(len=200), public :: str_value","tags":"","loc":"proc/prm_get_string_int.html","title":"prm_get_string_int – Fortran Program"},{"text":"public function prm_get_string_real(key, value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: key real, intent(out) :: value Return Value logical Variables Type Visibility Attributes Name Initial character(len=200), public :: str_value","tags":"","loc":"proc/prm_get_string_real.html","title":"prm_get_string_real – Fortran Program"},{"text":"public function prm_get_string_real8(key, value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: key real(kind=8), intent(out) :: value Return Value logical Variables Type Visibility Attributes Name Initial character(len=200), public :: str_value","tags":"","loc":"proc/prm_get_string_real8.html","title":"prm_get_string_real8 – Fortran Program"},{"text":"public function prm_get_int_real(key, value) Arguments Type Intent Optional Attributes Name integer, intent(out) :: key real, intent(out) :: value Return Value logical Variables Type Visibility Attributes Name Initial character(len=200), public :: line","tags":"","loc":"proc/prm_get_int_real.html","title":"prm_get_int_real – Fortran Program"},{"text":"public function prm_get_int_real8(key, value) Arguments Type Intent Optional Attributes Name integer, intent(out) :: key real(kind=8), intent(out) :: value Return Value logical Variables Type Visibility Attributes Name Initial character(len=200), public :: line","tags":"","loc":"proc/prm_get_int_real8.html","title":"prm_get_int_real8 – Fortran Program"},{"text":"public function prm_get_int_int(key, value) Arguments Type Intent Optional Attributes Name integer, intent(out) :: key integer, intent(out) :: value Return Value logical Variables Type Visibility Attributes Name Initial character(len=200), public :: line","tags":"","loc":"proc/prm_get_int_int.html","title":"prm_get_int_int – Fortran Program"},{"text":"public function prm_get_int(value) Arguments Type Intent Optional Attributes Name integer, intent(out) :: value Return Value logical Variables Type Visibility Attributes Name Initial character(len=200), public :: line","tags":"","loc":"proc/prm_get_int.html","title":"prm_get_int – Fortran Program"},{"text":"public function prm_open_section(section, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: section character(len=*), intent(in), optional :: filename Return Value logical Variables Type Visibility Attributes Name Initial logical, public :: used","tags":"","loc":"proc/prm_open_section.html","title":"prm_open_section – Fortran Program"},{"text":"public function prm_get_next_title(title) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: title Return Value logical","tags":"","loc":"proc/prm_get_next_title.html","title":"prm_get_next_title – Fortran Program"},{"text":"public function prm_open(filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical","tags":"","loc":"proc/prm_open.html","title":"prm_open – Fortran Program"},{"text":"public subroutine prmfile_startup() Arguments None","tags":"","loc":"proc/prmfile_startup.html","title":"prmfile_startup – Fortran Program"},{"text":"public subroutine rewind_section() Arguments None","tags":"","loc":"proc/rewind_section.html","title":"rewind_section – Fortran Program"},{"text":"public subroutine rewind_title() Arguments None","tags":"","loc":"proc/rewind_title.html","title":"rewind_title – Fortran Program"},{"text":"public subroutine clear() Arguments None Variables Type Visibility Attributes Name Initial type( SECTION_TYPE ), public, pointer :: sp_next type( LINE_TYPE ), public, pointer :: lp_next type( LINE_TYPE ), public, pointer :: lp_current","tags":"","loc":"proc/clear.html","title":"clear – Fortran Program"},{"text":"public subroutine prm_dump() Arguments None Variables Type Visibility Attributes Name Initial type( SECTION_TYPE ), public, pointer :: sp_next type( LINE_TYPE ), public, pointer :: lp_next type( LINE_TYPE ), public, pointer :: lp_current","tags":"","loc":"proc/prm_dump.html","title":"prm_dump – Fortran Program"},{"text":"public subroutine prm_close() Arguments None","tags":"","loc":"proc/prm_close.html","title":"prm_close – Fortran Program"},{"text":"public function qatom_old_load_atoms(fep_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fep_file Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: iat","tags":"","loc":"proc/qatom_old_load_atoms.html","title":"qatom_old_load_atoms – Fortran Program"},{"text":"public function qatom_load_atoms(fep_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fep_file Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: iat integer, public :: ires integer, public :: iatq integer, public :: s integer, public :: topno integer, public :: icase integer, public :: stat integer, public :: last integer, public :: add_res integer, public :: qflag (max_states) integer, public :: type_count logical, public :: yes character(len=4), public :: offset_name character(len=4), public :: res_name character(len=7), public :: res_str character(len=50), public :: line character(len=50), public :: word character(len=4), public, allocatable :: names (:) integer, public :: offset_residue integer, public :: max_res integer, public :: resno integer, public, allocatable :: residues (:)","tags":"","loc":"proc/qatom_load_atoms.html","title":"qatom_load_atoms – Fortran Program"},{"text":"public function qatom_old_load_fep() Arguments None Return Value logical Variables Type Visibility Attributes Name Initial character, public :: libtext *80 character, public :: qaname *2 integer, public :: i integer, public :: j integer, public :: k integer, public :: iat integer, public :: nqcrg integer, public :: nqcod integer, public :: qflag (max_states) integer, public :: exspectemp (max_states)","tags":"","loc":"proc/qatom_old_load_fep.html","title":"qatom_old_load_fep – Fortran Program"},{"text":"public function qatom_load_fep(fep_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fep_file Return Value logical Description * *Softcore section * MPA * END * Softcore section END * *  MPA Variables Type Visibility Attributes Name Initial character(len=200), public :: line integer, public :: i integer, public :: j integer, public :: k integer, public :: l integer, public :: iat integer, public :: st integer, public :: h integer, public :: nqcrg integer, public :: nqcod character(len=40), public :: section logical, public, allocatable, dimension(:) :: type_read integer, public :: type_count integer, public :: filestat real(kind=8), public :: el_scale (max_states) integer, public :: stat integer, public :: exspectemp (max_states) character(len=keylength), public :: qtac_tmp (max_states) integer, public :: temp_atom (MAX_ATOMS_IN_SPECIAL_GROUP)","tags":"","loc":"proc/qatom_load_fep.html","title":"qatom_load_fep – Fortran Program"},{"text":"public function bond_harmonic_in_any_state(k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: st","tags":"","loc":"proc/bond_harmonic_in_any_state.html","title":"bond_harmonic_in_any_state – Fortran Program"},{"text":"public subroutine qatom_startup() Arguments None","tags":"","loc":"proc/qatom_startup.html","title":"qatom_startup – Fortran Program"},{"text":"public subroutine qatom_shutdown() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: alloc_status","tags":"","loc":"proc/qatom_shutdown.html","title":"qatom_shutdown – Fortran Program"},{"text":"function get_topology() Arguments None Return Value logical Variables Type Visibility Attributes Name Initial character(len=200), public :: topfile","tags":"","loc":"proc/get_topology.html","title":"get_topology – Fortran Program"},{"text":"function get_coordfile(cf, fn, frames) Arguments Type Intent Optional Attributes Name character(len=256), intent(out) :: cf integer, intent(out) :: fn character(len=80) , optional :: frames Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: filestat integer, public :: p character(len=4), public :: trj_type","tags":"","loc":"proc/get_coordfile.html","title":"get_coordfile – Fortran Program"},{"text":"function load_restart(fn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fn Return Value logical Variables Type Visibility Attributes Name Initial integer(kind=4), public :: nat3 integer, public :: filestat","tags":"","loc":"proc/load_restart.html","title":"load_restart – Fortran Program"},{"text":"subroutine startup() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/startup.html","title":"startup – Fortran Program"},{"text":"subroutine shutdown() Arguments None","tags":"","loc":"proc/shutdown.html","title":"shutdown – Fortran Program"},{"text":"subroutine initialize() Arguments None","tags":"","loc":"proc/initialize.html","title":"initialize – Fortran Program"},{"text":"subroutine do_pre_calcs() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: c integer, public :: i","tags":"","loc":"proc/do_pre_calcs.html","title":"do_pre_calcs – Fortran Program"},{"text":"subroutine finalize() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: c integer, public :: i","tags":"","loc":"proc/finalize.html","title":"finalize – Fortran Program"},{"text":"subroutine calc_help() Arguments None","tags":"","loc":"proc/calc_help.html","title":"calc_help – Fortran Program"},{"text":"subroutine process_help() Arguments None","tags":"","loc":"proc/process_help.html","title":"process_help – Fortran Program"},{"text":"subroutine finishtrj_all() Arguments None","tags":"","loc":"proc/finishtrj_all.html","title":"finishtrj_all – Fortran Program"},{"text":"subroutine process_data() Arguments None Variables Type Visibility Attributes Name Initial character(len=256), public :: cf integer, public :: fn real(kind=8), public :: rms integer, public :: frame integer, public :: p1 integer, public :: p2 integer, public :: frame_start integer, public :: frame_end integer, public :: every_n character(len=80), public :: frames","tags":"","loc":"proc/process_data.html","title":"process_data – Fortran Program"},{"text":"subroutine process_frame(cf, frame) Arguments Type Intent Optional Attributes Name character(len=*) :: cf integer :: frame Variables Type Visibility Attributes Name Initial character(len=32), public :: filename","tags":"","loc":"proc/process_frame.html","title":"process_frame – Fortran Program"},{"text":"subroutine make_mean_all() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: c","tags":"","loc":"proc/make_mean_all.html","title":"make_mean_all – Fortran Program"},{"text":"subroutine finalize_topology() Arguments None","tags":"","loc":"proc/finalize_topology.html","title":"finalize_topology – Fortran Program"},{"text":"subroutine add_kind(desc, key, output) Arguments Type Intent Optional Attributes Name character(len=*) :: desc character(len=*) :: key logical :: output","tags":"","loc":"proc/add_kind.html","title":"add_kind – Fortran Program"},{"text":"subroutine calc_menu() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/calc_menu.html","title":"calc_menu – Fortran Program"},{"text":"subroutine add_calcs() Arguments None Variables Type Visibility Attributes Name Initial character(len=200), public :: input integer, public :: kind integer, public :: readstat","tags":"","loc":"proc/add_calcs.html","title":"add_calcs – Fortran Program"},{"text":"subroutine make_ref_all(x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x (:) Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/make_ref_all.html","title":"make_ref_all – Fortran Program"},{"text":"subroutine list_calcs() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: c","tags":"","loc":"proc/list_calcs.html","title":"list_calcs – Fortran Program"},{"text":"subroutine add_a_calc(kind) Arguments Type Intent Optional Attributes Name integer :: kind","tags":"","loc":"proc/add_a_calc.html","title":"add_a_calc – Fortran Program"},{"text":"subroutine print_headings() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: c integer, public :: i","tags":"","loc":"proc/print_headings.html","title":"print_headings – Fortran Program"},{"text":"subroutine calc_all(frame) Arguments Type Intent Optional Attributes Name integer :: frame Variables Type Visibility Attributes Name Initial integer, public :: c integer, public :: i","tags":"","loc":"proc/calc_all.html","title":"calc_all – Fortran Program"},{"text":"function signal(signum, proc, flag) Arguments Type Intent Optional Attributes Name integer(kind=4) :: signum real :: proc integer(kind=4) :: flag Return Value integer(kind=4)","tags":"","loc":"proc/signal.html","title":"signal – Fortran Program"},{"text":"subroutine startup() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: datum (8)","tags":"","loc":"proc/startup~2.html","title":"startup – Fortran Program"},{"text":"subroutine shutdown() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/shutdown~2.html","title":"shutdown – Fortran Program"},{"text":"subroutine prompt(outtxt) Arguments Type Intent Optional Attributes Name character(len=*) :: outtxt Variables Type Visibility Attributes Name Initial integer, public, parameter :: f = 5 integer, public, save :: f integer, public, parameter :: f = 6","tags":"","loc":"proc/prompt~2.html","title":"prompt – Fortran Program"},{"text":"subroutine tred2(A, N, NP, D, E) Arguments Type Intent Optional Attributes Name real(kind=8), , dimension(:,:) :: A integer :: N integer :: NP real(kind=8), , dimension(:) :: D real(kind=8), , dimension(:) :: E Variables Type Visibility Attributes Name Initial integer, public :: I integer, public :: J integer, public :: K integer, public :: L integer, public :: ERR real(kind=8), public :: SCALE real(kind=8), public :: F real(kind=8), public :: G real(kind=8), public :: H real(kind=8), public :: HH","tags":"","loc":"proc/tred2.html","title":"tred2 – Fortran Program"},{"text":"subroutine tqli(D, E, N, NP, Z) Arguments Type Intent Optional Attributes Name real(kind=8), , dimension(:) :: D real(kind=8), , dimension(:) :: E integer :: N integer :: NP real(kind=8), , dimension(:,:) :: Z Variables Type Visibility Attributes Name Initial integer, public :: I integer, public :: K integer, public :: L integer, public :: M integer, public :: ITER real(kind=8), public :: DD real(kind=8), public :: G real(kind=8), public :: R real(kind=8), public :: S real(kind=8), public :: C real(kind=8), public :: P real(kind=8), public :: F real(kind=8), public :: B","tags":"","loc":"proc/tqli.html","title":"tqli – Fortran Program"},{"text":"function check_inputfile(infilename) Arguments Type Intent Optional Attributes Name character(len=200), intent(out) :: infilename Return Value logical Description Determine if qprep is to be run from command line or from input file Variables Type Visibility Attributes Name Initial integer, public :: num_args character(len=300), public :: text","tags":"","loc":"proc/check_inputfile.html","title":"check_inputfile – Fortran Program"},{"text":"subroutine qprep_from_inputfile(filename) Arguments Type Intent Optional Attributes Name character(len=200) :: filename Description Read input from file and execute commands Variables Type Visibility Attributes Name Initial character(len=200), public :: command logical, public :: readable integer, public :: INPF_U = 0 integer, public :: stat","tags":"","loc":"proc/qprep_from_inputfile.html","title":"qprep_from_inputfile – Fortran Program"},{"text":"subroutine qprep_from_commandline() Arguments None Description Read input from command line and execute commands Variables Type Visibility Attributes Name Initial character(len=200), public :: command","tags":"","loc":"proc/qprep_from_commandline.html","title":"qprep_from_commandline – Fortran Program"},{"text":"subroutine parse_command(command) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: command Description Parse a command and call corresponding subroutine","tags":"","loc":"proc/parse_command.html","title":"parse_command – Fortran Program"},{"text":"subroutine help() Arguments None Description Give help on commands","tags":"","loc":"proc/help.html","title":"help – Fortran Program"},{"text":"subroutine startup() Arguments None Description Startup subroutine","tags":"","loc":"proc/startup~3.html","title":"startup – Fortran Program"},{"text":"subroutine shutdown() Arguments None Description Shutdown subroutine","tags":"","loc":"proc/shutdown~3.html","title":"shutdown – Fortran Program"},{"text":"subroutine commandlineoptions() Arguments None Description subroutine: commandlineoptions","tags":"","loc":"proc/commandlineoptions.html","title":"commandlineoptions – Fortran Program"},{"text":"subroutine print_help() Arguments None Description subroutine: print_help","tags":"","loc":"proc/print_help.html","title":"print_help – Fortran Program"},{"text":"public function topo_load(filename, require_version) Arguments Type Intent Optional Attributes Name character(len=*) :: filename real, intent(in) :: require_version Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: u integer, public :: readflag","tags":"","loc":"proc/topo_load.html","title":"topo_load – Fortran Program"},{"text":"public function topo_open(filename) Arguments Type Intent Optional Attributes Name character(len=*) :: filename Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: u integer, public :: stat_out","tags":"","loc":"proc/topo_open.html","title":"topo_open – Fortran Program"},{"text":"public function topo_read(u, require_version, extrabonds) Arguments Type Intent Optional Attributes Name integer :: u real, intent(in) :: require_version integer, intent(in), optional :: extrabonds Return Value logical Description * PWadded input reading 2001-10-10 Variables Type Visibility Attributes Name Initial integer, public :: rd integer, public :: nat3 integer, public :: nwat integer, public :: i integer, public :: j integer, public :: k integer, public :: n integer, public :: si integer, public :: nhyds integer, public :: paths character(len=256), public :: line character(len=256), public :: restofline character(len=10), public :: key character(len=10), public :: boundary_type integer, public :: filestat integer(kind=1), public, allocatable :: temp_list (:,:) integer, public :: extra real(kind=8), public :: deprecated","tags":"","loc":"proc/topo_read.html","title":"topo_read – Fortran Program"},{"text":"public subroutine topo_startup() Arguments None","tags":"","loc":"proc/topo_startup.html","title":"topo_startup – Fortran Program"},{"text":"public subroutine topo_set_max(max, max_lib, max_nbr) Arguments Type Intent Optional Attributes Name integer :: max integer :: max_lib integer :: max_nbr","tags":"","loc":"proc/topo_set_max.html","title":"topo_set_max – Fortran Program"},{"text":"public subroutine topo_allocate_potential(stat_out) Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: stat_out $                bnd(max_bonds), &\n$             bondlib(max_bondlib), &\n$             SYBYL_bond_type(max_bondlib), &\n$             ang(max_angles), &\n$             anglib(max_anglib), &\n$             tor(max_tors), &\n$             torlib(max_torlib), &\n$             imp(max_imps), &\n$             implib(max_implib), &\n$             lj2(max_lj2), &","tags":"","loc":"proc/topo_allocate_potential.html","title":"topo_allocate_potential – Fortran Program"},{"text":"public subroutine topo_allocate_atom(stat_out) Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: stat_out","tags":"","loc":"proc/topo_allocate_atom.html","title":"topo_allocate_atom – Fortran Program"},{"text":"public subroutine topo_deallocate(keep_ff) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: keep_ff Variables Type Visibility Attributes Name Initial logical, public :: keep","tags":"","loc":"proc/topo_deallocate.html","title":"topo_deallocate – Fortran Program"},{"text":"public subroutine topo_reallocate_xtop(atoms) Arguments Type Intent Optional Attributes Name integer :: atoms Variables Type Visibility Attributes Name Initial real(kind=8), public, allocatable :: r8temp (:) integer, public :: nat3old_array (1) integer, public :: nat3old","tags":"","loc":"proc/topo_reallocate_xtop.html","title":"topo_reallocate_xtop – Fortran Program"},{"text":"public subroutine topo_reallocate(oldatoms, atoms, waters) Arguments Type Intent Optional Attributes Name integer :: oldatoms integer :: atoms integer :: waters Variables Type Visibility Attributes Name Initial integer, public :: oldbonds integer, public :: bonds integer, public :: oldangles integer, public :: angles real, public, allocatable :: r4temp (:) integer(kind=1), public, allocatable :: i1temp (:) type( bond_type ), public, allocatable :: bndtemp (:) type( ang_type ), public, allocatable :: angtemp (:)","tags":"","loc":"proc/topo_reallocate.html","title":"topo_reallocate – Fortran Program"},{"text":"public subroutine topo_save(name) Arguments Type Intent Optional Attributes Name character(len=*) :: name Description * PWedited this part Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: u integer, public :: ig integer, public :: si integer(kind=1), public, allocatable :: temp_list (:,:) real, public :: crgtot","tags":"","loc":"proc/topo_save.html","title":"topo_save – Fortran Program"},{"text":"public function trj_add(line) Arguments Type Intent Optional Attributes Name character(len=*) :: line Return Value integer","tags":"","loc":"proc/trj_add.html","title":"trj_add – Fortran Program"},{"text":"public function trj_store_mask(line) Arguments Type Intent Optional Attributes Name character(len=*) :: line Return Value logical","tags":"","loc":"proc/trj_store_mask.html","title":"trj_store_mask – Fortran Program"},{"text":"public function trj_commit_mask() Arguments None Return Value integer Variables Type Visibility Attributes Name Initial integer, public :: row","tags":"","loc":"proc/trj_commit_mask.html","title":"trj_commit_mask – Fortran Program"},{"text":"public function trj_count() Arguments None Return Value integer","tags":"","loc":"proc/trj_count.html","title":"trj_count – Fortran Program"},{"text":"public function trj_create(filename, append) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical , optional :: append Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: filestat character(len=10), public :: writemode character(len=80), public :: titlerow","tags":"","loc":"proc/trj_create.html","title":"trj_create – Fortran Program"},{"text":"public function trj_write(x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x (:) Return Value logical","tags":"","loc":"proc/trj_write.html","title":"trj_write – Fortran Program"},{"text":"public function trj_read(x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x (:) Return Value logical","tags":"","loc":"proc/trj_read.html","title":"trj_read – Fortran Program"},{"text":"public function trj_read_masked(x) Arguments Type Intent Optional Attributes Name real(kind=4) :: x (:) Return Value logical","tags":"","loc":"proc/trj_read_masked.html","title":"trj_read_masked – Fortran Program"},{"text":"public function trj_seek(frame) Arguments Type Intent Optional Attributes Name integer :: frame Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/trj_seek.html","title":"trj_seek – Fortran Program"},{"text":"public function trj_open(filename) Arguments Type Intent Optional Attributes Name character(len=*) :: filename Return Value logical Variables Type Visibility Attributes Name Initial character(len=80), public :: titlerow integer, public :: atoms integer, public :: i","tags":"","loc":"proc/trj_open.html","title":"trj_open – Fortran Program"},{"text":"public function trj_intersection(m) Arguments Type Intent Optional Attributes Name type(MASK_TYPE) :: m Return Value integer","tags":"","loc":"proc/trj_intersection.html","title":"trj_intersection – Fortran Program"},{"text":"public function trj_get_ncoords() Arguments None Return Value integer","tags":"","loc":"proc/trj_get_ncoords.html","title":"trj_get_ncoords – Fortran Program"},{"text":"public subroutine trj_startup() Arguments None","tags":"","loc":"proc/trj_startup.html","title":"trj_startup – Fortran Program"},{"text":"public subroutine trj_shutdown() Arguments None","tags":"","loc":"proc/trj_shutdown.html","title":"trj_shutdown – Fortran Program"},{"text":"public subroutine trj_initialize(frames, steps_before, interval, steps, degf, topfile) Arguments Type Intent Optional Attributes Name integer, intent(in) :: frames integer, intent(in) :: steps_before integer, intent(in) :: interval integer, intent(in) :: steps integer, intent(in) :: degf character(len=*), intent(in) :: topfile","tags":"","loc":"proc/trj_initialize.html","title":"trj_initialize – Fortran Program"},{"text":"public subroutine trj_close() Arguments None Variables Type Visibility Attributes Name Initial logical, public :: is_open","tags":"","loc":"proc/trj_close.html","title":"trj_close – Fortran Program"},{"text":"public subroutine trj_clone_mask(m) Arguments Type Intent Optional Attributes Name type(MASK_TYPE) :: m","tags":"","loc":"proc/trj_clone_mask.html","title":"trj_clone_mask – Fortran Program"},{"text":"public subroutine version_check(q_program, q_version, q_date, q_suffix) Arguments Type Intent Optional Attributes Name character(len=*) :: q_program character(len=*) :: q_version character(len=*) :: q_date character(len=*) :: q_suffix Variables Type Visibility Attributes Name Initial character(len=32), public :: arg logical, public :: fin integer, public :: i integer, public :: count integer, public :: datum (8) character(len=200), public :: flag","tags":"","loc":"proc/version_check.html","title":"version_check – Fortran Program"},{"text":"public elemental subroutine lowcase(word) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: word Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ic integer, public :: nlen","tags":"","loc":"proc/lowcase.html","title":"lowcase – Fortran Program"},{"text":"public subroutine version_print(q_program, q_version, q_date, q_suffix) Arguments Type Intent Optional Attributes Name character(len=*) :: q_program character(len=*) :: q_version character(len=*) :: q_date character(len=*) :: q_suffix Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: datum (8)","tags":"","loc":"proc/version_print.html","title":"version_print – Fortran Program"},{"text":"Uses: prep Variables Type Visibility Attributes Name Initial integer, public, parameter :: ave_pdb = 11 Subroutines public subroutine avetr_calc () Arguments None public subroutine add_coordinates () Arguments None public subroutine average () Arguments None public subroutine write_average () Arguments None","tags":"","loc":"module/avetr.html","title":"avetr – Fortran Program"},{"text":"Uses: topo Variables Type Visibility Attributes Name Initial real(kind=8), public, allocatable :: xin (:)","tags":"","loc":"module/calc_base.html","title":"calc_base – Fortran Program"},{"text":"Uses: calc_base MASKMANIP trj prmfile indexer qatom Variables Type Visibility Attributes Name Initial real, public :: score integer, public :: frame integer, public :: stat integer, public :: i character(len=4), public :: trj_type character(len=0), public :: top_file character(len=0), public :: fep_file integer, public, parameter :: MAX_MASKS = 10 integer, public :: nScores integer, public :: maxScores integer(kind=AI), public, allocatable :: lph_r (:) integer(kind=AI), public, allocatable :: lph_l (:) type( donor ), public, allocatable :: hbd_r (:) type( donor ), public, allocatable :: hbd_l (:) integer(kind=AI), public, allocatable :: hba_r (:) integer(kind=AI), public, allocatable :: hba_l (:) integer(kind=AI), public, allocatable :: met_r (:) type( wat ), public, allocatable :: waters (:) integer, public, allocatable :: pol_con (:) integer, public :: nlph_r integer, public :: nlph_l integer, public :: nhbd_r integer, public :: nhbd_l integer, public :: nhba_r integer, public :: nhba_l integer, public :: nmet_r integer, public :: nwaters integer, public :: nqbonds integer, public :: nhbd_prot integer, public :: nhba_prot integer, public :: nrings integer, public, parameter :: LIPO = 1 integer, public, parameter :: METAL = 2 integer, public, parameter :: SULPHUR = 3 integer, public, parameter :: ACCEPTOR = 4 integer, public, parameter :: SP3 = 5 integer, public, parameter :: SP2 = 6 integer, public, parameter :: SP3_N = 7 integer, public, parameter :: PL_N = 8 integer, public, parameter :: HYDROGEN = 9 integer, public, parameter :: OXYGEN = 10 integer, public, parameter :: CARBON_LIPO = 11 integer, public, parameter :: CARBONYL_CARBON = 12 integer, public, parameter :: CARBONYL_OXYGEN = 13 integer, public, parameter :: NPROPS = 13 character(len=*), public, parameter :: file_heading (NPROPS) = ['lipophilic     ', 'metal          ', 'sulphur        ', 'acceptor       ', 'sp3            ', 'sp2            ', 'sp3_nitrogen   ', 'planar_nitrogen', 'hydrogen       ', 'oxygen         ', 'carbon_lipo    ', 'carbonyl_carbon', 'carbonyl_oxygen'] type( ATOM_DATA_TYPE ), public, allocatable :: atom_data (:) integer, public, allocatable :: iqatom (:) real, public, allocatable :: vdwr (:) character(len=0), public :: atom_data_file character(len=0), public :: coord_file real, public :: hbond_term real, public :: metal_term real, public :: lipo_term real, public :: rot_term real, public, parameter :: dGconst = -5.48 real, public, parameter :: dGhbond = -3.34 real, public, parameter :: dGmetal = -6.03 real, public, parameter :: dGlipo = -0.117 real, public, parameter :: dGrot = 2.56 Derived Types type, public :: score_precalc_type Components Type Visibility Attributes Name Initial character(len=80), public :: chFilename integer, public :: iType type, public :: score_type Components Type Visibility Attributes Name Initial character(len=80), public :: chFilename integer, public :: frame real(kind=8), public :: score real(kind=8), public :: h_bonds real(kind=8), public :: metal real(kind=8), public :: lipophil real(kind=8), public :: rot_bond type, public :: SCORE_COORD_TYPE Components Type Visibility Attributes Name Initial real(kind=8), public, pointer :: xr (:) real(kind=8), public :: xrcm (3) type, public :: wat Components Type Visibility Attributes Name Initial integer(kind=AI), public :: O integer(kind=AI), public :: H1 integer(kind=AI), public :: H2 real, public :: score type, public :: donor Components Type Visibility Attributes Name Initial integer(kind=AI), public :: heavy integer(kind=AI), public :: hydr type, public :: lipos Components Type Visibility Attributes Name Initial integer, public :: n_lip integer, public :: n_nonlip type, public :: bond_pointer Components Type Visibility Attributes Name Initial type( q_bond ), public, pointer :: qb type, public :: q_atom Components Type Visibility Attributes Name Initial integer, public :: top_nr integer, public :: n type( bond_pointer ), public, dimension(1:6) :: bd logical, public :: contact integer, public :: at_type integer, public :: hybrid logical, public :: been_there logical, public, pointer :: cyclic (:) logical, public :: active type, public :: q_bond Components Type Visibility Attributes Name Initial type( q_atom ), public, pointer :: a type( q_atom ), public, pointer :: b logical, public :: rotatable logical, public :: acontact logical, public :: bcontact logical, public :: been_there integer, public :: a_nonlip integer, public :: b_nonlip integer, public :: a_lip integer, public :: b_lip logical, public, pointer :: cyclic (:) logical, public :: active type, public :: ATOM_DATA_TYPE Components Type Visibility Attributes Name Initial real, public :: radius logical, public :: prop (NPROPS) Functions public recursive function lip_atom (atom) result(ans) Arguments Type Intent Optional Attributes Name type( q_atom ), , pointer :: atom Return Value type( lipos ) public recursive function find_contact (atom) result(ans) Arguments Type Intent Optional Attributes Name type( q_atom ), , pointer :: atom Return Value logical public recursive function trace_ring (atom, ir) result(ans) Arguments Type Intent Optional Attributes Name type( q_atom ), , pointer :: atom integer :: ir Return Value logical public function angle (a, b, c) Arguments Type Intent Optional Attributes Name integer :: a integer :: b integer :: c Return Value real public function dist (a, b) Arguments Type Intent Optional Attributes Name integer :: a integer :: b Return Value real Description ! Gives the distance between two atoms. public function distsq (a, b) Arguments Type Intent Optional Attributes Name integer :: a integer :: b Return Value real Description ! Gives the squared distance between two atoms. public function fr_lip (a, b) Arguments Type Intent Optional Attributes Name integer :: a integer :: b Return Value real Description ! Gives f(rlL) i.e. contribution from one lipophilic - lipophilic pair public function fr_met (a, b) Arguments Type Intent Optional Attributes Name integer :: a integer :: b Return Value real public function g1_hb (a, b) Arguments Type Intent Optional Attributes Name integer :: a integer :: b Return Value real public function g2_hb (a, b, c) Arguments Type Intent Optional Attributes Name integer :: a integer :: b integer :: c Return Value real Description ! Gives g2(dev_ang) i.e. contribution depending on the H-bond angle at the hydrogen atom public function score_add (desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Subroutines public subroutine score_initialize () Arguments None public subroutine chemscore_finalize () Arguments None public subroutine log_frame (iFrame) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iFrame public subroutine score_heading (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine calc_hbonds () Arguments None public subroutine calc_lipo () Arguments None public subroutine calc_metals () Arguments None public subroutine calc_rot () Arguments None public subroutine calc_scores () Arguments None public subroutine count_qlipo () Arguments None public subroutine frozen () Arguments None public subroutine get_atom_data () Arguments None Description ! Go through all atoms and give them a vdW radius.\n! I represents atom number. public subroutine make_tac_index () Arguments None public subroutine q_contacts () Arguments None public subroutine q_types () Arguments None public subroutine report_ligand () Arguments None public subroutine report_protein () Arguments None public subroutine report_rings () Arguments None public subroutine reset_waters () Arguments None public subroutine score_waters () Arguments None public subroutine set_ligand () Arguments None public subroutine set_rings () Arguments None public recursive subroutine search_ring (bond, ir) Arguments Type Intent Optional Attributes Name type( q_bond ), , pointer :: bond integer :: ir public subroutine mark_ring (bond, ir) Arguments Type Intent Optional Attributes Name type( q_bond ), , pointer :: bond integer :: ir public subroutine set_rotatable () Arguments None public subroutine set_waters () Arguments None public subroutine sort_atoms () Arguments None public subroutine sort_bonds () Arguments None public subroutine sort_waters () Arguments None public subroutine start () Arguments None Description ! Takes vdw_radii from vdw_file and puts into vector vdwr.\n! Also assigns radii to every solute atom public subroutine store_waters () Arguments None public subroutine score_precalc () Arguments None public subroutine score_mean () Arguments None public subroutine score_calc (iCalc, iFrame) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iCalc integer, intent(in) :: iFrame","tags":"","loc":"module/calc_chemscore.html","title":"calc_chemscore – Fortran Program"},{"text":"Uses: calc_base MASKMANIP Variables Type Visibility Attributes Name Initial integer, public, parameter :: MAX_MASKS = 10 Derived Types type, public :: COM_COORD_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: x (:) real, public, pointer :: y (:) real, public, pointer :: z (:) real, public, pointer :: mass (:) type, public :: COORD_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: xyz (:) type, public :: MASS_AVE_TYPE Components Type Visibility Attributes Name Initial real, public :: x real, public :: y real, public :: z Functions public function COM_add (desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Subroutines public subroutine COM_initialize () Arguments None public subroutine COM_finalize (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine COM_calc (i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i public subroutine COM_put_mass (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine COM_heading (i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"module/calc_com.html","title":"calc_com – Fortran Program"},{"text":"Uses: calc_base MASKMANIP Variables Type Visibility Attributes Name Initial integer, public, parameter :: MAX_MASKS = 10 real(kind=8), public, allocatable :: kineticenergy (:) Derived Types type, public :: COM_KE_COORD_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: x (:) real, public, pointer :: y (:) real, public, pointer :: z (:) real, public, pointer :: mass (:) type, public :: COM_KE_VELOCITY_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: x (:) real, public, pointer :: y (:) real, public, pointer :: z (:) type, public :: COORD_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: xyz (:) type, public :: DP_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: dp (:) type, public :: MASS_AVE_TYPE Components Type Visibility Attributes Name Initial real, public :: x real, public :: y real, public :: z type, public :: EIGEN_STUFF_TYPE Components Type Visibility Attributes Name Initial real, public :: evalue (3) real, public :: evector (3,3) Functions public function COM_KE_add (desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Subroutines public subroutine COM_KE_initialize () Arguments None public subroutine COM_KE_finalize (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine COM_KE_calc (i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i public subroutine COM_KE_put_mass (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine COM_KE_heading (i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"module/calc_com_ke.html","title":"calc_com_ke – Fortran Program"},{"text":"Uses: calc_base MASKMANIP trj calc_fit calc_geom Variables Type Visibility Attributes Name Initial real(kind=8), public :: pi_val real(kind=8), public :: hs real(kind=8), public :: R real(kind=8), public :: ref_vol real(kind=8), public :: e real(kind=8), public :: u real(kind=8), public :: kb real(kind=8), public :: cm integer, public :: entropy_frame integer, public :: start Derived Types type, public :: COVARIANCE_MATRIX Components Type Visibility Attributes Name Initial real(kind=8), public :: Exy real(kind=8), public :: Ex real(kind=8), public :: Ey type, public :: ENTROPY_COORD_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: x (:) real, public, pointer :: xref (:) real(kind=8), public, pointer :: xr (:) real(kind=8), public :: xrcm (3) integer, public :: interval integer, public :: Calc_type character(len=9), public :: Calc_select real(kind=8), public :: Temperature integer, public :: tot_no_frames type, public :: trajectory Components Type Visibility Attributes Name Initial type( COVARIANCE_MATRIX ), public, pointer :: COV_DATA (:,:) real(kind=8), public, pointer :: C (:,:) real(kind=8), public, pointer :: VIZ (:) real(kind=8), public, pointer :: massvector (:) real(kind=8), public, pointer :: Xcm (:,:) real(kind=8), public, pointer :: Xrot (:) real(kind=8), public, pointer :: X (:,:) integer, public :: startframe integer, public :: endframe integer, public :: no_atoms integer, public :: no_frames integer, public :: store_cov integer, public :: Temperature integer, public :: Calc_type real(kind=8), public, dimension(3,3) :: ROT real(kind=8), public :: masstot Functions public function entropy_add (desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Subroutines public subroutine construct_trajectory (t, Temp, startframe, endframe, no_atoms, Calc_type) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t real(kind=8) :: Temp integer :: startframe integer :: endframe integer :: no_atoms integer :: Calc_type public subroutine ENTROPY_initialize () Arguments None public subroutine ENTROPY_finalize (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine entropy_heading (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine entropy_calc (i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i public subroutine CovarianceMatrix (t) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t public subroutine SchlittersFormula (t, det) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t real(kind=8) :: det public subroutine MultiplyMatrices (t) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t public subroutine CholeskyFactorization (t) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t public subroutine RotationAndTranslation (t, i) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t integer, intent(in) :: i public subroutine fit_make_reference (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine Quasiharmonic_analysis (i, t, det) Arguments Type Intent Optional Attributes Name integer :: i type( trajectory ) :: t real(kind=8) :: det public subroutine massweight (t) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t public subroutine VIZ (t) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t public subroutine entropy_ho (m, t, det) Arguments Type Intent Optional Attributes Name integer :: m type( trajectory ) :: t real(kind=8) :: det public subroutine PCA (t, det) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t real(kind=8) :: det public subroutine Euler_angles (t) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t public subroutine UpdateCovariancematrix (t, i) Arguments Type Intent Optional Attributes Name type( trajectory ) :: t integer :: i","tags":"","loc":"module/calc_entropy.html","title":"calc_entropy – Fortran Program"},{"text":"Uses: calc_base MASKMANIP Variables Type Visibility Attributes Name Initial integer, public, parameter :: MAX_MASKS = 10 Derived Types type, public :: FIT_COORD_TYPE Components Type Visibility Attributes Name Initial real(kind=8), public, pointer :: xr (:) real(kind=8), public :: xrcm (3) Functions public function fit_add (desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer public function LSQSTR (NR, W, XP, X, E, U) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NR logical(kind=1), intent(in) :: W (:) real(kind=8), intent(in) :: XP (:) real(kind=8), intent(inout) :: X (:) real(kind=8), intent(out), optional :: E real(kind=8) , optional :: U (3,3) Return Value integer Description *CONSTRUCT OMEGA, DIAGONALIZE IT AND DETERMINE H AND K DETERMINE R AND ROTATE X ***CALCULATE E, WHEN REQUIRED Subroutines public subroutine fit_initialize () Arguments None public subroutine fit_finalize (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine fit_calc (i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i public subroutine fit_make_ref (i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"module/calc_fit.html","title":"calc_fit – Fortran Program"},{"text":"Uses: calc_base Variables Type Visibility Attributes Name Initial integer, public, parameter :: MAX_MEASUREMENTS = 99 real(kind=8), public :: pi Derived Types type, public :: GEOM_TYPE Components Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: l integer, public :: cod integer, public :: kind Functions public function dist_add (desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer public function angle_add (desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer public function torsion_add (desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Subroutines public subroutine geom_initialize () Arguments None public subroutine geom_finalize () Arguments None public subroutine dist_calc (i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i public subroutine angle_calc (i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i public subroutine torsion_calc (i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i public subroutine dist_heading (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine angle_heading (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine torsion_heading (i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"module/calc_geom.html","title":"calc_geom – Fortran Program"},{"text":"Uses: calc_base MASKMANIP PARSE atom_mask Invoked from Qcalc to calculate nonbonded interactions \n  between two masks defined by user. Make pair lists of interacting atoms in mask1 and mask2 Add new calculation of nonbonded interactions between\n  two sets of residues, e.g. protein aa and q-atoms. The\n  interactions will be calculated for for the first group\n  one at the time against all residues in the second group. Step through one residue at the time and calculate nonbonded\n interactions with all q-atoms. Print final averages and clean up. Variables Type Visibility Attributes Name Initial integer, public, parameter :: MAX_LISTS = 20 integer, public, parameter :: MAX_NB_QP = 1 type( AVERAGES ), public, allocatable :: aves (:) type( AVERAGES ), public, allocatable :: qp_aves (:) integer, public, allocatable :: total_frames (:) integer, public :: total_qp_frames = 0 Derived Types type, public :: NB_LIST_TYPE Components Type Visibility Attributes Name Initial integer, public :: number_of_NB integer, public, pointer :: atom1 (:) integer, public, pointer :: atom2 (:) real, public, pointer :: AA (:) real, public, pointer :: BB (:) real, public, pointer :: qq (:) type, public :: AVERAGES Components Type Visibility Attributes Name Initial real, public :: lj real, public :: el type, public :: NB_QP_TYPE Components Type Visibility Attributes Name Initial integer, public :: p_first integer, public :: p_last integer, public :: q_first integer, public :: q_last Functions public function nb_add (desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer public function nb_qp_add (desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Subroutines public subroutine nb_initialize () Arguments None public subroutine nb_finalize (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine nb_calc (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine nb_calc_lists (NB_Vlj, NB_Vel, nb_list) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: NB_Vlj real(kind=8), intent(out) :: NB_Vel type( NB_LIST_TYPE ), intent(in) :: nb_list public subroutine nb_make_list (mask1, mask2, nb_list) Arguments Type Intent Optional Attributes Name type(MASK_TYPE), intent(in) :: mask1 type(MASK_TYPE), intent(in) :: mask2 type( NB_LIST_TYPE ) :: nb_list public subroutine nb_heading (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine nb_qp_calc () Arguments None public subroutine nb_qp_finalize () Arguments None","tags":"","loc":"module/calc_nb.html","title":"CALC_NB – Fortran Program"},{"text":"Uses: calc_base MASKMANIP PARSE atom_mask Invoked from Qcalc to calculate nonbonded interactions \n  between two masks defined by user. Make pair lists of interacting atoms in mask1 and mask2 Add new calculation of nonbonded interactions between\n  two sets of residues, e.g. protein aa and q-atoms. The\n  interactions will be calculated for for the first group\n  one at the time against all residues in the second group. Step through one residue at the time and calculate nonbonded\n interactions with all q-atoms. Print final averages and clean up. Variables Type Visibility Attributes Name Initial integer, public, parameter :: MAX_LISTS = 20 integer, public, parameter :: MAX_NB_QP = 1 type( AVERAGES ), public, allocatable :: aves (:) type( AVERAGES ), public, allocatable :: qp_aves (:) integer, public, allocatable :: total_frames (:) integer, public :: total_qp_frames = 0 real, public :: center_mask1 (3) real, public :: ave_Elj_r (10,100) real, public :: Elj_r (100) Derived Types type, public :: NB_LIST_TYPE Components Type Visibility Attributes Name Initial integer, public :: number_of_NB integer, public, pointer :: atom1 (:) integer, public, pointer :: atom2 (:) real, public, pointer :: AA (:) real, public, pointer :: BB (:) real, public, pointer :: qq (:) type, public :: AVERAGES Components Type Visibility Attributes Name Initial real, public :: lj real, public :: el type, public :: NB_QP_TYPE Components Type Visibility Attributes Name Initial integer, public :: p_first integer, public :: p_last integer, public :: q_first integer, public :: q_last Functions public function nb_add (desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer public function dist_group1 (atom2) Arguments Type Intent Optional Attributes Name integer :: atom2 Return Value integer public function nb_qp_add (desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Subroutines public subroutine nb_initialize () Arguments None public subroutine nb_finalize (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine calc_center () Arguments None public subroutine nb_calc (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine nb_calc_lists (NB_Vlj, NB_Vel, nb_list) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: NB_Vlj real(kind=8), intent(out) :: NB_Vel type( NB_LIST_TYPE ), intent(in) :: nb_list public subroutine nb_make_list (mask1, mask2, nb_list) Arguments Type Intent Optional Attributes Name type(MASK_TYPE), intent(in) :: mask1 type(MASK_TYPE), intent(in) :: mask2 type( NB_LIST_TYPE ) :: nb_list public subroutine nb_heading (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine nb_qp_calc () Arguments None public subroutine nb_qp_finalize () Arguments None","tags":"","loc":"module/calc_nb~2.html","title":"CALC_NB – Fortran Program"},{"text":"Uses: calc_base MASKMANIP PARSE Qcalc calls this function to set up one RDF calculation,\n which is then added to the list of calculations in Qcalc Calculates RDF data from the current trajectory frame r(a,b) calculates the distance between atoms a and b rdf_make_list makes a list of all atom atom pairs in the masks and return the number of pairs Variables Type Visibility Attributes Name Initial integer, public, parameter :: MAX_MASKS = 10 real(kind=8), public :: pi Derived Types type, public :: RDF_CALC_TYPE Components Type Visibility Attributes Name Initial integer, public :: atoms_in_mask1 integer, public :: frames = 0 integer, public :: Nbins real(kind=8), public :: rdf_radius real(kind=8), public, pointer :: bins (:) type, public :: RDF_LIST_TYPE Components Type Visibility Attributes Name Initial integer, public :: number_of_pairs integer, public, pointer :: atom1 (:) integer, public, pointer :: atom2 (:) Functions public function RDF_add (desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer public function r (a, b) Arguments Type Intent Optional Attributes Name integer :: a integer :: b Return Value real public function rdf_make_list (mask1, mask2, rdf_list) Arguments Type Intent Optional Attributes Name type(MASK_TYPE), intent(in) :: mask1 type(MASK_TYPE), intent(in) :: mask2 type( RDF_LIST_TYPE ) :: rdf_list Return Value integer Subroutines public subroutine RDF_initialize () Arguments None public subroutine RDF_finalize (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine RDF_calc (i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i public subroutine RDF_heading (i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"module/calc_rdf.html","title":"CALC_RDF – Fortran Program"},{"text":"Uses: calc_base MASKMANIP Variables Type Visibility Attributes Name Initial integer, public, parameter :: MAX_MASKS = 10 Derived Types type, public :: RMS_COORD_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: x (:) real, public, pointer :: x0 (:) Functions public function RMS_add (desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Subroutines public subroutine RMS_initialize () Arguments None public subroutine RMS_finalize (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine RMS_calc (i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i public subroutine RMS_make_ref (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine RMS_heading (i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"module/calc_rms.html","title":"CALC_RMS – Fortran Program"},{"text":"Uses: calc_base MASKMANIP Variables Type Visibility Attributes Name Initial integer, public, parameter :: MAX_MASKS = 10 real(kind=8), public, allocatable :: rmsf (:) Derived Types type, public :: RMSF_COORD_TYPE Components Type Visibility Attributes Name Initial real, public, pointer :: x (:) real, public, pointer :: x0 (:) real, public, pointer :: x2 (:) Functions public function RMSF_add (desc) Arguments Type Intent Optional Attributes Name character(len=*) :: desc Return Value integer Subroutines public subroutine RMSF_initialize () Arguments None public subroutine RMSF_finalize (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine RMSF_calc (i) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i public subroutine RMSF_make_ref (i) Arguments Type Intent Optional Attributes Name integer :: i public subroutine RMSF_heading (i) Arguments Type Intent Optional Attributes Name integer :: i","tags":"","loc":"module/calc_rmsf.html","title":"CALC_RMSF – Fortran Program"},{"text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: KEYLENGTH = 8 Derived Types type, public :: indexentry Components Type Visibility Attributes Name Initial character(len=KEYLENGTH), public :: key integer, public :: ndx Functions public function index_add (key, index) Arguments Type Intent Optional Attributes Name character(len=*) :: key integer :: index Return Value logical public function index_alias (alias, key) Arguments Type Intent Optional Attributes Name character(len=*) :: alias character(len=*) :: key Return Value logical public function index_get (key, i, allow_wildcard) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key integer, intent(out) :: i logical , optional :: allow_wildcard Return Value logical Subroutines public subroutine index_create (size) Arguments Type Intent Optional Attributes Name integer , optional :: size public subroutine index_clear () Arguments None public subroutine index_shutdown () Arguments None public subroutine index_startup () Arguments None public subroutine index_resize (size) Arguments Type Intent Optional Attributes Name integer :: size","tags":"","loc":"module/indexer.html","title":"indexer – Fortran Program"},{"text":"Uses: topo Add atoms to mask according to rules in 'line'. Update mask from rules in s.\n if s%property1 and s%property2 are true, then that\n requested without \"not\". if both are false then it has\n been requested with \"not\" flag. else it has not been requested Update mask from rules in s.\n Used before topology is made, thus\n vectors 'excl' or 'shell' cannot be used. Function: get_sybylcode()\n Argument: A (potential) SYBYL atom name\n Returns:  the integer atom code (iac) for that SYBYL name\n           (returns 0 if the argument is not a valid SYBYL name) transfer coords from masked atoms in 'xmasked'\n to topology coord array 'x' Derived Types type, public :: MASK_TYPE Components Type Visibility Attributes Name Initial integer, public :: included logical(kind=1), public, pointer :: mask (:) Functions public function mask_count (m) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m Return Value integer public function mask_add (m, line, pretop) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m character(len=*) :: line logical, intent(in), optional :: pretop Return Value integer Subroutines public subroutine mask_startup () Arguments None public subroutine mask_shutdown () Arguments None public subroutine mask_initialize (m) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m public subroutine mask_finalize (m) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m public subroutine mask_clear (m) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m public subroutine mask_all (m) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m public subroutine get_sybylcode (sybylname) Arguments Type Intent Optional Attributes Name character(len=*) :: sybylname public subroutine mask_get (m, x, xmasked) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m real(kind=8) :: x (:) real :: xmasked (:) public subroutine mask_put (m, x, xmasked) Arguments Type Intent Optional Attributes Name type( MASK_TYPE ) :: m real(kind=8) :: x (:) real :: xmasked (:)","tags":"","loc":"module/atom_mask.html","title":"atom_mask – Fortran Program"},{"text":"Uses: atom_mask misc PARSE Functions public function maskmanip_make (mask) Arguments Type Intent Optional Attributes Name type(MASK_TYPE) :: mask Return Value integer public function maskmanip_make_pretop (mask) Arguments Type Intent Optional Attributes Name type(MASK_TYPE) :: mask Return Value integer Subroutines public subroutine maskmanip_help () Arguments None public subroutine maskmanip_help_pretop () Arguments None","tags":"","loc":"module/maskmanip.html","title":"MASKMANIP – Fortran Program"},{"text":"Uses: sizes Functions public function freefile () Arguments None Return Value integer public function onoff (l) Arguments Type Intent Optional Attributes Name logical :: l Return Value character(len=3) public function string_part (string, separator, start) Arguments Type Intent Optional Attributes Name character(len=*) :: string character(len=*) :: separator integer :: start Return Value integer public function rtime () Arguments None Return Value real(kind=8) Subroutines public subroutine centered_heading (msg, fill) Arguments Type Intent Optional Attributes Name character(len=*) :: msg character :: fill public subroutine skip_comments (unit) Arguments Type Intent Optional Attributes Name integer :: unit public subroutine getlin (intxt, outtxt) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: intxt character(len=*), intent(in), optional :: outtxt public subroutine upcase (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string public subroutine locase (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string","tags":"","loc":"module/misc.html","title":"misc – Fortran Program"},{"text":"Uses: nrgy Variables Type Visibility Attributes Name Initial integer, public :: nodeid integer, public :: numnodes integer, public :: ierr integer, public, allocatable :: mpi_status (:,:) real(kind=dp), public, allocatable :: d_recv (:,:) type( MPI_NB_ENERGIES ), public, allocatable :: E_recv (:) type( MPI_NB_ENERGIES ), public, allocatable :: E_send (:) type( MPI_NBQ_ENERGIES ), public, allocatable :: EQ_recv (:,:) type( MPI_NBQ_ENERGIES ), public, allocatable :: EQ_send (:) integer, public, allocatable :: request_recv (:,:) integer, public :: totnbpp integer, public :: totnbpw integer, public :: totnbww integer, public :: totnbqp integer, public :: totnbqw integer, public, dimension(5) :: nbxx integer, public, dimension(5) :: nbxx_tot integer, public, allocatable :: nbpp_per_cgp (:) integer, public, allocatable :: nbpw_per_cgp (:) integer, public, allocatable :: nbww_per_cgp (:) integer, public, allocatable :: nbqp_per_cgp (:) integer, public, allocatable :: nbqw_per_cgp (:) Derived Types type, public :: PAIR_ASSIGNMENT_TYPE Components Type Visibility Attributes Name Initial integer, public :: start integer, public :: end integer, public :: max type, public :: NODE_ASSIGNMENT_TYPE Components Type Visibility Attributes Name Initial type( PAIR_ASSIGNMENT_TYPE ), public :: pp type( PAIR_ASSIGNMENT_TYPE ), public :: pw type( PAIR_ASSIGNMENT_TYPE ), public :: ww type( PAIR_ASSIGNMENT_TYPE ), public :: qp type( PAIR_ASSIGNMENT_TYPE ), public :: qw type, public, sequence  :: MPI_NB_ENERGIES Components Type Visibility Attributes Name Initial real(kind=dp), public :: lrf type(NB_ENERGIES), public :: pp type(NB_ENERGIES), public :: pw type(NB_ENERGIES), public :: ww type, public, sequence  :: MPI_NBQ_ENERGIES Components Type Visibility Attributes Name Initial type(NB_ENERGIES), public :: qp type(NB_ENERGIES), public :: qw","tags":"","loc":"module/mpiglob.html","title":"mpiglob – Fortran Program"},{"text":"Uses: misc Variables Type Visibility Attributes Name Initial integer, public, parameter :: MAX_ARGS = 10 character(len=200), public :: inbuf type( substring ), public :: argv (0:MAX_ARGS) integer, public :: argc = 0 integer, public :: argp = 1 Derived Types type, public :: substring Components Type Visibility Attributes Name Initial integer, public :: istart integer, public :: iend Functions public function parse_open_file (filename) Arguments Type Intent Optional Attributes Name character(len=*) :: filename Return Value logical public function openit (lun, fil, stat, frm, mode) Arguments Type Intent Optional Attributes Name integer :: lun character(len=*) :: fil character(len=*) :: stat character(len=*) :: frm character(len=*) :: mode Return Value integer public function get_string_single_line (arg, prompt) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arg character(len=*), intent(in), optional :: prompt Return Value logical public function get_int_arg (prompt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: prompt Return Value integer public function get_real_arg (prompt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: prompt Return Value real Subroutines public subroutine parse_startup () Arguments None public subroutine split () Arguments None public subroutine getline () Arguments None public subroutine get_string_arg (arg, prompt) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arg character(len=*), intent(in), optional :: prompt public subroutine get_line_arg (arg, prompt) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: arg character(len=*), intent(in), optional :: prompt public subroutine parse_reset () Arguments None","tags":"","loc":"module/parse.html","title":"PARSE – Fortran Program"},{"text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: PREF_LEN = 200 Functions public function pref_add (name, ival, rval, sval) Arguments Type Intent Optional Attributes Name character(len=*), , target :: name integer, , optional target :: ival real, , optional target :: rval character(len=*), , optional target :: sval Return Value logical public function pref_set (string, inval) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in), optional :: inval Return Value logical Subroutines public subroutine pref_initialize (max) Arguments Type Intent Optional Attributes Name integer , optional :: max public subroutine pref_list (heading) Arguments Type Intent Optional Attributes Name character(len=*) , optional :: heading","tags":"","loc":"module/prefs.html","title":"PREFS – Fortran Program"},{"text":"Uses: trj PARSE prmfile indexer PREFS MASKMANIP Variables Type Visibility Attributes Name Initial integer, public, parameter :: max_entry = 1000 integer, public, parameter :: max_atlib = 500 integer, public, parameter :: max_cgplib = 100 integer, public, parameter :: max_atcgplib = 100 integer, public, parameter :: max_old_atyps = 100 integer, public, parameter :: max_extrabnd = 100 integer, public, parameter :: max_lib = 1000 integer, public, parameter :: max_long = 10000 integer, public, parameter :: max_conn = 10 real, public, target :: solvent_pack = 2.4 real, public, target :: rho_solute = 0.05794 real, public, target :: max_xlink = 2.1 character(len=200), public, target :: solvent_names = '' integer, public, target :: random_seed_solute = 179857 integer, public, target :: random_seed_solvent = 758971 integer, public, parameter :: build_rule_torsion = 1 integer, public :: nlibres type( lib_entry_type ), public, target :: lib (max_entry) logical, public :: have_prm_file_name = .false. logical, public :: have_solute_sphere = .false. logical, public :: have_title = .false. logical, public :: have_solvent_boundary = .false. logical, public :: boundary_set = .false. integer, public :: nbnd_prm integer, public :: nbnd_types type( bond_type_type ), public, allocatable :: bnd_types (:) type( bond_prm_type ), public, allocatable :: bnd_prm (:) type( angle_type_type ), public, allocatable :: ang_types (:) type( anglib_type ), public, allocatable :: ang_prm (:) integer, public :: nang_types integer, public :: nang_prm type( torsion_type_type ), public, allocatable :: tor_types (:) type( torlib_type ), public, allocatable :: tor_prm (:) integer, public :: ntor_types integer, public :: ntor_prm type( imp_prm_type ), public, allocatable :: imp_prm (:) integer, public :: nimp_prm logical, public :: imp_explicit integer, public :: natom integer, public :: nat_wat integer, public :: nwat character(len=100), public :: coord_source = '' character(len=80), public :: auto_name = '' integer, public, parameter :: trj_unit = 17 integer, public :: trj_frame = 0 character(len=180), public :: trj_filnam type(mask_type), public :: mask integer, public :: nextrabnd type( bond_type ), public :: extrabnd (max_extrabnd) logical, public, allocatable :: makeh (:) integer, public, allocatable :: nconn (:) integer, public, allocatable :: iconn (:,:) real(kind=8), public :: pi real(kind=8), public :: deg2rad real(kind=8), public, allocatable :: xw (:,:,:) logical, public, allocatable :: keep (:) integer, public :: irc_solvent character(len=4), public :: solvent_name logical, public :: topo_ok = .false. logical, public :: ff_ok = .false. Derived Types type, public :: lib_bond_type Components Type Visibility Attributes Name Initial integer(kind=AI), public :: i integer(kind=AI), public :: j type, public :: lib_imp_type Components Type Visibility Attributes Name Initial character(len=1+4), public :: i character(len=1+4), public :: j character(len=1+4), public :: k character(len=1+4), public :: l type, public :: lib_rule_type Components Type Visibility Attributes Name Initial integer, public :: kind integer, public :: atom (4) real, public :: value type, public :: lib_entry_type Components Type Visibility Attributes Name Initial integer, public :: nat integer, public :: nbnd integer, public :: nimp integer, public :: ncgp integer, public :: nrules integer, public :: head integer, public :: tail logical, public :: hetatm logical, public :: solvent real, public :: density character(len=4), public :: nam character(len=8), public :: sybyltype character(len=4), public, pointer :: atnam (:) character(len=keylength), public, pointer :: tac_lib (:) real, public, pointer :: crg_lib (:) type( lib_rule_type ), public, pointer :: rules (:) type( lib_bond_type ), public, pointer :: bnd (:) type( lib_imp_type ), public, pointer :: imp (:) integer(kind=ai), public, pointer :: natcgp (:) integer(kind=ai), public, pointer :: switch (:) integer(kind=ai), public, pointer :: atcgp (:,:) type, public :: bond_type_type Components Type Visibility Attributes Name Initial character(len=keylength), public :: taci character(len=keylength), public :: tacj integer, public :: cod type, public :: bond_prm_type Components Type Visibility Attributes Name Initial type( bondlib_type ), public :: prm character(len=2), public :: SYBYLtype type, public :: angle_type_type Components Type Visibility Attributes Name Initial character(len=keylength), public :: taci character(len=keylength), public :: tacj character(len=keylength), public :: tack integer, public :: cod type, public :: torsion_type_type Components Type Visibility Attributes Name Initial character(len=keylength), public :: taci character(len=keylength), public :: tacj character(len=keylength), public :: tack character(len=keylength), public :: tacl integer, public :: cod type, public :: tor_codes Components Type Visibility Attributes Name Initial integer, public :: ncod integer, public :: cod (10) type, public :: imp_prm_type Components Type Visibility Attributes Name Initial character(len=keylength), public :: taci character(len=keylength), public :: tacj character(len=keylength), public :: tack character(len=keylength), public :: tacl type( implib_type ), public :: prm Functions public function anglecode (taci, tacj, tack) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: taci character(len=*), intent(in) :: tacj character(len=*), intent(in) :: tack Return Value integer public function wildcard_tac (taci) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: taci Return Value character(len=keylength) public function bondcode (taci, tacj) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: taci character(len=*), intent(in) :: tacj Return Value integer public function cross_product (a, b) Arguments Type Intent Optional Attributes Name real(kind=8) :: a (3) real(kind=8) :: b (3) Return Value real(kind=8)\n  (3) public function impcode (taci, tacj, tack, tacl) Arguments Type Intent Optional Attributes Name character(len=KEYLENGTH) :: taci character(len=KEYLENGTH) :: tacj character(len=KEYLENGTH) :: tack character(len=KEYLENGTH) :: tacl Return Value integer public function makeextrabonds () Arguments None Return Value integer public function makesomebonds (startres, endres) Arguments Type Intent Optional Attributes Name integer :: startres integer :: endres Return Value integer public function genH (j, residue) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: residue Return Value integer public function find_atom (ires, atom) Arguments Type Intent Optional Attributes Name integer :: ires character(len=5) :: atom Return Value integer public function randm (seed, seed_only) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: seed logical, intent(in), optional :: seed_only Return Value real public function countpdb (pdb_fileno, atoms, residues, molecules) Arguments Type Intent Optional Attributes Name integer :: pdb_fileno integer :: atoms integer :: residues integer :: molecules Return Value logical public function set_irc_solvent () Arguments None Return Value logical public function get_atom_from_descriptor (aid) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: aid Return Value integer public function set_boundary_condition () Arguments None Return Value logical public function set_simulation_sphere () Arguments None Return Value logical public function set_solvent_box () Arguments None Return Value logical public function set_solvent_sphere () Arguments None Return Value logical public function rwat_eff () Arguments None Return Value real public function torcode (taci, tacj, tack, tacl) Arguments Type Intent Optional Attributes Name character(len=KEYLENGTH) :: taci character(len=KEYLENGTH) :: tacj character(len=KEYLENGTH) :: tack character(len=KEYLENGTH) :: tacl Return Value type( tor_codes ) public function check_residues () Arguments None Return Value logical public function get_centre_by_mass (centre) Arguments Type Intent Optional Attributes Name real(kind=8), intent(out) :: centre (3) Return Value logical Subroutines public subroutine prep_startup () Arguments None public subroutine allocate_for_pdb (atoms, residues, molecules) Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms integer, intent(in) :: residues integer, intent(in) :: molecules public subroutine prep_shutdown () Arguments None public subroutine clearlib () Arguments None public subroutine addbond () Arguments None public subroutine clearbond () Arguments None public subroutine angle_ene (emax, nlarge, av_ene) Arguments Type Intent Optional Attributes Name real :: emax integer :: nlarge real :: av_ene public subroutine bond_ene (emax, nlarge, av_ene) Arguments Type Intent Optional Attributes Name real :: emax integer :: nlarge real :: av_ene public subroutine changeimp () Arguments None public subroutine checkangs () Arguments None public subroutine checkbonds () Arguments None public subroutine checkimps () Arguments None public subroutine checktors () Arguments None public subroutine xlink () Arguments None public subroutine impr_ene (emax, nlarge, av_ene, mode) Arguments Type Intent Optional Attributes Name real :: emax integer :: nlarge real :: av_ene integer :: mode public subroutine listres () Arguments None public subroutine listseq () Arguments None public subroutine make14list () Arguments None public subroutine makeangles () Arguments None public subroutine make_solute_bonds () Arguments None public subroutine makebonds () Arguments None public subroutine set_bondcodes () Arguments None public subroutine makeexlist () Arguments None public subroutine makehyds () Arguments None public subroutine makeimps () Arguments None public subroutine imp_params () Arguments None public subroutine makeimps_explicit () Arguments None public subroutine maketop () Arguments None public subroutine set_default_mask () Arguments None public subroutine makeconn () Arguments None public subroutine maketors () Arguments None public subroutine prompt (outtxt) Arguments Type Intent Optional Attributes Name character(len=*) :: outtxt public subroutine oldreadlib (filnam) Arguments Type Intent Optional Attributes Name character(len=*) :: filnam public subroutine readlib (file) Arguments Type Intent Optional Attributes Name character(len=*) , optional :: file public subroutine check_overload (resnam) Arguments Type Intent Optional Attributes Name character(len=80) :: resnam public subroutine oldreadparm (flag) Arguments Type Intent Optional Attributes Name logical :: flag public subroutine readff () Arguments None public subroutine readparm (filnam) Arguments Type Intent Optional Attributes Name character(len=*) :: filnam public subroutine clearpdb () Arguments None public subroutine cleartop () Arguments None public subroutine readpdb () Arguments None public subroutine readtop () Arguments None public subroutine readx () Arguments None public subroutine readnext () Arguments None public subroutine readframe () Arguments None public subroutine trajectory () Arguments None public subroutine modify_mask () Arguments None public subroutine set_cgp () Arguments None public subroutine set_crg () Arguments None public subroutine set_iac () Arguments None public subroutine set_solvent_type () Arguments None public subroutine define_boundary_condition () Arguments None public subroutine solvate () Arguments None public subroutine solvate_box () Arguments None public subroutine solvate_box_grid () Arguments None public subroutine solvate_box_file () Arguments None public subroutine solvate_sphere () Arguments None public subroutine solvate_sphere_grid () Arguments None public subroutine solvate_sphere_file (shift) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: shift public subroutine solvate_restart () Arguments None public subroutine add_solvent_to_topology (waters_in_sphere, max_waters, make_hydrogens, pack) Arguments Type Intent Optional Attributes Name integer :: waters_in_sphere integer :: max_waters logical :: make_hydrogens real :: pack Description *PWchanged way of computing packing *PWadded new loop checking water-water distance public subroutine grow_arrays_for_solvent (nmore, atoms_per_molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmore integer, intent(in) :: atoms_per_molecule public subroutine tors_ene (emax, nlarge, av_ene) Arguments Type Intent Optional Attributes Name real :: emax integer :: nlarge real :: av_ene public subroutine writepdb () Arguments None public subroutine writemol2 () Arguments None public subroutine writetop () Arguments None public subroutine listprefs () Arguments None public subroutine set () Arguments None public subroutine make_shell2 () Arguments None","tags":"","loc":"module/prep.html","title":"prep – Fortran Program"},{"text":"Uses: misc comment\ncomment Variables Type Visibility Attributes Name Initial type( SECTION_TYPE ), public, pointer :: first_sec type( SECTION_TYPE ), public, pointer :: current_sec type( LINE_TYPE ), public, pointer :: current_lp integer, public :: section_count character(len=80), public :: current_title character(len=80), public :: next_title Derived Types type, public :: LINE_TYPE Components Type Visibility Attributes Name Initial character(len=900), public :: text type( LINE_TYPE ), public, pointer :: next type, public :: SECTION_TYPE Components Type Visibility Attributes Name Initial character(len=80), public :: name type( SECTION_TYPE ), public, pointer :: next type( LINE_TYPE ), public, pointer :: lp integer, public :: count integer, public :: max_enum Functions public function prm_get_integer_by_key (key, value, default) Arguments Type Intent Optional Attributes Name character(len=*) :: key integer, intent(out) :: value integer, intent(in), optional :: default Return Value logical public function prm_get_real_by_key (key, value, default) Arguments Type Intent Optional Attributes Name character(len=*) :: key real, intent(out) :: value real, intent(in), optional :: default Return Value logical public function prm_get_real8_by_key (key, value, default) Arguments Type Intent Optional Attributes Name character(len=*) :: key real(kind=8), intent(out) :: value real(kind=8), intent(in), optional :: default Return Value logical public function prm_get_string_by_key (key, value, default) Arguments Type Intent Optional Attributes Name character(len=*) :: key character(len=*), intent(out) :: value character(len=*), intent(in), optional :: default Return Value logical public function prm_get_line_by_key (key, value, default) Arguments Type Intent Optional Attributes Name character(len=*) :: key character(len=*), intent(out) :: value character(len=*), intent(in), optional :: default Return Value logical public function prm_get_logical_by_key (key, value, default) Arguments Type Intent Optional Attributes Name character(len=*) :: key logical, intent(out) :: value logical, intent(in), optional :: default Return Value logical public function prm_get_line (line) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: line Return Value logical public function prm_get_field (field, skip) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: field logical, intent(in), optional :: skip Return Value logical public function prm_count (section) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: section Return Value integer public function prm_max_enum (section, count_out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: section integer, intent(out), optional :: count_out Return Value integer public function prm_max_enum2 (section, count_out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: section integer, intent(out), optional :: count_out Return Value integer public function prm_get_string_string (key, value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: key character(len=*), intent(out) :: value Return Value logical public function prm_get_string_line (key, value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: key character(len=*), intent(out) :: value Return Value logical public function prm_get_string_int (key, value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: key integer, intent(out) :: value Return Value logical public function prm_get_string_real (key, value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: key real, intent(out) :: value Return Value logical public function prm_get_string_real8 (key, value) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: key real(kind=8), intent(out) :: value Return Value logical public function prm_get_int_real (key, value) Arguments Type Intent Optional Attributes Name integer, intent(out) :: key real, intent(out) :: value Return Value logical public function prm_get_int_real8 (key, value) Arguments Type Intent Optional Attributes Name integer, intent(out) :: key real(kind=8), intent(out) :: value Return Value logical public function prm_get_int_int (key, value) Arguments Type Intent Optional Attributes Name integer, intent(out) :: key integer, intent(out) :: value Return Value logical public function prm_get_int (value) Arguments Type Intent Optional Attributes Name integer, intent(out) :: value Return Value logical public function prm_open_section (section, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: section character(len=*), intent(in), optional :: filename Return Value logical public function prm_get_next_title (title) Arguments Type Intent Optional Attributes Name character(len=*), intent(out) :: title Return Value logical public function prm_open (filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value logical Subroutines public subroutine prmfile_startup () Arguments None public subroutine rewind_section () Arguments None public subroutine rewind_title () Arguments None public subroutine clear () Arguments None public subroutine prm_dump () Arguments None public subroutine prm_close () Arguments None","tags":"","loc":"module/prmfile.html","title":"prmfile – Fortran Program"},{"text":"Uses: sizes nrgy misc prmfile indexer topo Variables Type Visibility Attributes Name Initial integer, public, parameter :: max_states = 10 integer, public, parameter :: max_qat = 1000 integer, public, parameter :: max_link = 10 integer, public :: nstates integer, public :: nqat * PWadded this variable\nTopology atom number of the switching atom of the Q-atoms\nNeeded if periodic boundaries are used integer, public :: qswitch integer, public :: offset logical, public :: qvdw_flag logical, public :: qq_use_library_charges integer(kind=AI), public, allocatable :: iqseq (:) integer, public, allocatable :: qiac (:,:) character(len=KEYLENGTH), public, allocatable :: qtac (:) integer, public :: nqexpnb integer(kind=AI), public, allocatable :: iqexpnb (:) integer(kind=AI), public, allocatable :: jqexpnb (:) integer, public :: nqlib real(kind=4), public, allocatable :: qcrg (:,:) real(kind=8), public, allocatable :: qmass (:) real(kind=8), public, allocatable :: qavdw (:,:) real(kind=8), public, allocatable :: qbvdw (:,:) integer, public :: nqbond type( QBOND_TYPE ), public, allocatable :: qbnd (:) type( QBONDLIB_TYPE ), public, allocatable :: qbondlib (:) integer, public :: nqangle type( QANGLE_TYPE ), public, allocatable :: qang (:) type( anglib_type ), public, allocatable :: qanglib (:) integer, public :: nqtor integer(kind=AI), public, allocatable :: iqtor (:) integer(kind=AI), public, allocatable :: jqtor (:) integer(kind=AI), public, allocatable :: kqtor (:) integer(kind=AI), public, allocatable :: lqtor (:) integer(kind=TINY), public, allocatable :: qtorcod (:,:) real(kind=8), public, allocatable :: qfktor (:) real(kind=8), public, allocatable :: qrmult (:) real(kind=8), public, allocatable :: qdeltor (:) integer, public :: nqimp integer(kind=AI), public, allocatable :: iqimp (:) integer(kind=AI), public, allocatable :: jqimp (:) integer(kind=AI), public, allocatable :: kqimp (:) integer(kind=AI), public, allocatable :: lqimp (:) integer(kind=TINY), public, allocatable :: qimpcod (:,:) real(kind=8), public, allocatable :: qfkimp (:) real(kind=8), public, allocatable :: qimp0 (:) integer, public :: nang_coupl integer, public :: ntor_coupl integer, public :: nimp_coupl integer(kind=AI), public :: iang_coupl (3,max_qat) integer(kind=AI), public :: itor_coupl (3,max_qat) integer(kind=AI), public :: iimp_coupl (3,max_qat) integer, public :: nqshake integer(kind=AI), public :: iqshake (max_qat) integer(kind=AI), public :: jqshake (max_qat) real(kind=8), public :: qshake_dist (max_qat,max_states) integer, public :: noffd type(OFFDIAG_SAVE), public, allocatable :: offd (:) type(OFFDIAG_AUX), public, allocatable :: offd2 (:) integer, public :: nexspec type( SPECEX_TYPE ), public, allocatable :: exspec (:) type( monitor_group_pair_TYPE ), public, allocatable :: monitor_group_pair (:) type( monitor_atom_group_TYPE ), public, allocatable :: monitor_atom_group (:) integer, public, parameter :: MAX_ATOMS_IN_SPECIAL_GROUP = 30 integer, public :: monitor_group_pairs integer, public :: monitor_groups type( qq_el_scale_type ), public, allocatable :: qq_el_scale (:) integer, public :: nel_scale integer, public :: tmpindex integer, public :: numsoftlines integer, public :: i2 real(kind=8), public, allocatable :: sc_lookup (:,:,:) real(kind=8), public, allocatable :: alpha_max (:,:) real(kind=8), public :: sc_aq real(kind=8), public :: sc_bq real(kind=8), public :: sc_aj real(kind=8), public :: sc_bj real(kind=8), public :: alpha_max_tmp logical, public :: softcore_use_max_potential type(Q_ENERGIES), public, allocatable :: EQ (:) real(kind=8), public :: Hij (max_states,max_states) real(kind=8), public :: EMorseD (max_qat) real(kind=8), public :: dMorse_i (3,max_qat) real(kind=8), public :: dMorse_j (3,max_qat) logical, public :: use_new_fep_format Derived Types type, public :: QBOND_TYPE Components Type Visibility Attributes Name Initial integer(kind=AI), public :: i integer(kind=AI), public :: j integer(kind=TINY), public :: cod (max_states) type, public :: QBONDLIB_TYPE Components Type Visibility Attributes Name Initial real(kind=8), public :: Dmz real(kind=8), public :: amz real(kind=8), public :: r0 real(kind=8), public :: fk type, public :: QANGLE_TYPE Components Type Visibility Attributes Name Initial integer(kind=AI), public :: i integer(kind=AI), public :: j integer(kind=AI), public :: k integer(kind=TINY), public :: cod (max_states) type, public :: SPECEX_TYPE Components Type Visibility Attributes Name Initial integer(kind=AI), public :: i integer(kind=AI), public :: j logical, public :: flag (max_states) type, public :: monitor_group_pair_TYPE Components Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=8), public :: Vel (max_states) real(kind=8), public :: Vlj (max_states) real(kind=8), public :: Vwel real(kind=8), public :: Vwlj real(kind=8), public :: Vwsum type, public :: monitor_atom_group_TYPE Components Type Visibility Attributes Name Initial integer, public, pointer :: atom (:) integer, public :: n type, public :: qq_el_scale_type Components Type Visibility Attributes Name Initial integer(kind=AI), public :: iqat integer(kind=AI), public :: jqat real(kind=8), public :: el_scale (max_states) Functions public function qatom_old_load_atoms (fep_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fep_file Return Value logical public function qatom_load_atoms (fep_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fep_file Return Value logical public function qatom_old_load_fep () Arguments None Return Value logical public function qatom_load_fep (fep_file) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fep_file Return Value logical Description * *Softcore section * MPA * END * Softcore section END * *  MPA public function bond_harmonic_in_any_state (k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k Return Value logical Subroutines public subroutine qatom_startup () Arguments None public subroutine qatom_shutdown () Arguments None","tags":"","loc":"module/qatom.html","title":"qatom – Fortran Program"},{"text":"Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp8 = selected_real_kind(15, 307) integer, public, parameter :: sp = selected_real_kind(6, 37) integer, public, parameter :: dp = selected_real_kind(15, 307) integer, public, parameter :: qp = selected_real_kind(33, 4931) integer, public, parameter :: q_int2 = selected_int_kind(4) integer, public, parameter :: q_int4 = selected_int_kind(9) integer, public, parameter :: q_int8 = selected_int_kind(18) integer, public, parameter :: int_byte = selected_int_kind(2) integer, public, parameter :: ai = 4 integer, public, parameter :: flag = 1 integer, public, parameter :: max_flag = 2**(8*flag-1)-1 integer, public, parameter :: tiny = 2 integer, public, parameter :: max_tiny = 2**(8*tiny-1)-1 integer, public, parameter :: shrt = 2 integer, public, parameter :: max_shrt = 2**(8*shrt-1)-1","tags":"","loc":"module/sizes.html","title":"sizes – Fortran Program"},{"text":"Uses: sizes misc Variables Type Visibility Attributes Name Initial integer, public, parameter :: nljtyp = 3 integer, public, parameter :: max_nbr_range = 25 real, public :: version character(len=256), public :: title = '' character(len=256), public :: forcefield = '' character(len=256), public :: creation_date character(len=256), public :: pdb_file = '' character(len=256), public :: lib_files = '' character(len=256), public :: prm_file integer, public :: nat_pro integer, public :: nat_solute integer, public :: max_atom real(kind=8), public, allocatable :: xtop (:) integer(kind=tiny), public, allocatable :: iac (:) logical, public, allocatable :: heavy (:) real, public, allocatable :: crg (:) integer(kind=ai), public, allocatable :: cgpatom (:) integer, public, parameter :: solvent_spc = 0 integer, public, parameter :: solvent_3atom = 1 integer, public, parameter :: solvent_general = 2 integer, public :: solvent_type integer, public, allocatable :: glb_cofactor (:) integer, public :: ligand_offset sim. sphere & water sphere centres real(kind=8), public :: xpcent (3) real(kind=8), public :: xwcent (3) real(kind=8), public :: rwat real(kind=8), public :: rexcl_o real(kind=8), public :: rexcl_i integer, public :: nexats integer, public :: nshellats integer, public :: nexwat logical, public, allocatable :: shell (:) logical, public, allocatable :: excl (:) real(kind=8), public :: boxlength (3) real(kind=8), public :: boxcentre (3) real(kind=8), public :: inv_boxl (3) logical, public :: use_pbc = .false. integer, public :: nbonds integer, public :: nbonds_solute integer, public :: max_bonds type( bond_type ), public, allocatable :: bnd (:) integer, public :: nbndcod integer, public :: max_bondlib type( bondlib_type ), public, allocatable :: bondlib (:) character(len=3), public, allocatable :: sybyl_bond_type (:) integer, public :: nangles integer, public :: nangles_solute integer, public :: max_angles type( ang_type ), public, allocatable :: ang (:) integer, public :: nangcod integer, public :: max_anglib type( anglib_type ), public, allocatable :: anglib (:) integer, public :: ntors integer, public :: ntors_solute integer, public :: ntorcod integer, public :: max_tors integer, public :: max_torlib integer, public :: nimps integer, public :: nimps_solute integer, public :: nimpcod integer, public :: max_imps integer, public :: max_implib integer, public :: imp_type type( tor_type ), public, target, allocatable :: tor (:) type( tor_type ), public, target, allocatable :: imp (:) type( torlib_type ), public, target, allocatable :: torlib (:) type( implib_type ), public, target, allocatable :: implib (:) integer, public :: ncgp integer, public :: ncgp_solute integer, public :: max_cgp type( cgp_type ), public, allocatable :: cgp (:) integer, public :: natyps integer, public :: max_atyps integer, public :: nlj2 integer, public :: max_lj2 type( iac_type ), public, allocatable :: iaclib (:) character(len=5), public, allocatable :: sybyl_atom_type (:) character(len=8), public, allocatable :: tac (:) type( lj2_type ), public, allocatable :: lj2 (:) integer, public :: ivdw_rule integer, public, parameter :: vdw_geometric = 1 integer, public, parameter :: vdw_arithmetic = 2 real(kind=8), public :: el14_scale integer, public :: iuse_switch_atom real(kind=8), public :: coulomb_constant integer, public :: ff_type integer, public, parameter :: ff_gromos = 1 integer, public, parameter :: ff_amber = 2 integer, public, parameter :: ff_charmm = 3 integer, public :: n14nbrs integer, public :: nexnbrs integer, public :: max_exbnrs integer, public :: n14long integer, public :: max_14long integer, public :: nexlong integer, public :: max_exlong logical, public, allocatable :: list14 (:,:) logical, public, allocatable :: listex (:,:) integer(kind=ai), public, allocatable :: list14long (:,:) integer(kind=ai), public, pointer :: listexlong (:,:) integer, public :: nres integer, public :: nres_solute integer, public :: max_res type( residue_type ), public, allocatable :: res (:) integer, public :: nmol integer, public :: max_mol integer, public, allocatable :: istart_mol (:) Derived Types type, public :: bond_type Components Type Visibility Attributes Name Initial integer(kind=ai), public :: i integer(kind=ai), public :: j integer(kind=shrt), public :: cod type, public :: ang_type Components Type Visibility Attributes Name Initial integer(kind=ai), public :: i integer(kind=ai), public :: j integer(kind=ai), public :: k integer(kind=shrt), public :: cod type, public :: bondlib_type Components Type Visibility Attributes Name Initial real(kind=8), public :: fk real(kind=8), public :: bnd0 type, public :: anglib_type Components Type Visibility Attributes Name Initial real(kind=8), public :: fk real(kind=8), public :: ang0 real(kind=8), public :: ureyfk real(kind=8), public :: ureyr0 type, public :: tor_type Components Type Visibility Attributes Name Initial integer(kind=ai), public :: i integer(kind=ai), public :: j integer(kind=ai), public :: k integer(kind=ai), public :: l integer(kind=shrt), public :: cod type, public :: torlib_type Components Type Visibility Attributes Name Initial real, public :: fk real, public :: rmult real, public :: deltor real, public :: paths type, public :: implib_type Components Type Visibility Attributes Name Initial real, public :: fk real, public :: imp0 type, public :: cgp_type Components Type Visibility Attributes Name Initial integer(kind=ai), public :: iswitch integer(kind=ai), public :: first integer(kind=ai), public :: last type, public :: iac_type Components Type Visibility Attributes Name Initial real(kind=8), public :: mass real(kind=8), public :: avdw (nljtyp) real(kind=8), public :: bvdw (nljtyp) type, public :: lj2_type Components Type Visibility Attributes Name Initial integer(kind=tiny), public :: i integer(kind=tiny), public :: j type, public :: residue_type Components Type Visibility Attributes Name Initial integer, public :: irc integer, public :: start character(len=4), public :: name Functions public function topo_load (filename, require_version) Arguments Type Intent Optional Attributes Name character(len=*) :: filename real, intent(in) :: require_version Return Value logical public function topo_open (filename) Arguments Type Intent Optional Attributes Name character(len=*) :: filename Return Value integer public function topo_read (u, require_version, extrabonds) Arguments Type Intent Optional Attributes Name integer :: u real, intent(in) :: require_version integer, intent(in), optional :: extrabonds Return Value logical Description * PWadded input reading 2001-10-10 Subroutines public subroutine topo_startup () Arguments None public subroutine topo_set_max (max, max_lib, max_nbr) Arguments Type Intent Optional Attributes Name integer :: max integer :: max_lib integer :: max_nbr public subroutine topo_allocate_potential (stat_out) Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: stat_out $                bnd(max_bonds), &\n$             bondlib(max_bondlib), &\n$             SYBYL_bond_type(max_bondlib), &\n$             ang(max_angles), &\n$             anglib(max_anglib), &\n$             tor(max_tors), &\n$             torlib(max_torlib), &\n$             imp(max_imps), &\n$             implib(max_implib), &\n$             lj2(max_lj2), & public subroutine topo_allocate_atom (stat_out) Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: stat_out public subroutine topo_deallocate (keep_ff) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: keep_ff public subroutine topo_reallocate_xtop (atoms) Arguments Type Intent Optional Attributes Name integer :: atoms public subroutine topo_reallocate (oldatoms, atoms, waters) Arguments Type Intent Optional Attributes Name integer :: oldatoms integer :: atoms integer :: waters public subroutine topo_save (name) Arguments Type Intent Optional Attributes Name character(len=*) :: name Description * PWedited this part","tags":"","loc":"module/topo.html","title":"topo – Fortran Program"},{"text":"Uses: atom_mask misc Write real(4) coords to trajectory. Writes only \n atoms in current mask. Read a frame from trajectory file and return coordinates\n associated with atomnumbers in topology. Read a frame from trajectory file containing masked atoms,\n return only masked coordinates. !REAL(4)! Variables Type Visibility Attributes Name Initial integer, public, parameter :: max_mask_rows = 20 character(len=80), public :: mask_row (max_mask_rows) Functions public function trj_add (line) Arguments Type Intent Optional Attributes Name character(len=*) :: line Return Value integer public function trj_store_mask (line) Arguments Type Intent Optional Attributes Name character(len=*) :: line Return Value logical public function trj_commit_mask () Arguments None Return Value integer public function trj_count () Arguments None Return Value integer public function trj_create (filename, append) Arguments Type Intent Optional Attributes Name character(len=*) :: filename logical , optional :: append Return Value logical public function trj_write (x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x (:) Return Value logical public function trj_read (x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x (:) Return Value logical public function trj_read_masked (x) Arguments Type Intent Optional Attributes Name real(kind=4) :: x (:) Return Value logical public function trj_seek (frame) Arguments Type Intent Optional Attributes Name integer :: frame Return Value logical public function trj_open (filename) Arguments Type Intent Optional Attributes Name character(len=*) :: filename Return Value logical public function trj_intersection (m) Arguments Type Intent Optional Attributes Name type(MASK_TYPE) :: m Return Value integer public function trj_get_ncoords () Arguments None Return Value integer Subroutines public subroutine trj_startup () Arguments None public subroutine trj_shutdown () Arguments None public subroutine trj_initialize (frames, steps_before, interval, steps, degf, topfile) Arguments Type Intent Optional Attributes Name integer, intent(in) :: frames integer, intent(in) :: steps_before integer, intent(in) :: interval integer, intent(in) :: steps integer, intent(in) :: degf character(len=*), intent(in) :: topfile public subroutine trj_close () Arguments None public subroutine trj_clone_mask (m) Arguments Type Intent Optional Attributes Name type(MASK_TYPE) :: m","tags":"","loc":"module/trj.html","title":"trj – Fortran Program"},{"text":"Subroutines public subroutine version_check (q_program, q_version, q_date, q_suffix) Arguments Type Intent Optional Attributes Name character(len=*) :: q_program character(len=*) :: q_version character(len=*) :: q_date character(len=*) :: q_suffix public elemental subroutine lowcase (word) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: word public subroutine version_print (q_program, q_version, q_date, q_suffix) Arguments Type Intent Optional Attributes Name character(len=*) :: q_program character(len=*) :: q_version character(len=*) :: q_date character(len=*) :: q_suffix","tags":"","loc":"module/version.html","title":"version – Fortran Program"},{"text":"Variables Type Attributes Name Initial integer :: count","tags":"","loc":"program/test_command_argument_count.html","title":"test_command_argument_count – Fortran Program"},{"text":"Uses: version trj calc_base CALC_RMS calc_fit calc_geom calc_entropy CALC_NB calc_chemscore calc_xscore calc_pmf CALC_RDF CALC_RMSF calc_com_ke calc_com Variables Type Attributes Name Initial character(len=*), parameter :: PROGRAM_VERSION = '5.7' character(len=*), parameter :: PROGRAM_DATE = '2015-02-22' integer, parameter :: MAX_CALCS = 99 integer, parameter :: MAX_CALC_KINDS = 99 integer :: nkinds = 0 integer :: ncalcs = 0 type( calc_kind_type ) :: cdef (max_calc_kinds) type( calc_type ) :: calcs (max_calcs) Derived Types type :: calc_type Components Type Visibility Attributes Name Initial character(len=60), public :: desc integer, public :: i integer, public :: typ type :: calc_kind_type Components Type Visibility Attributes Name Initial character(len=40), public :: desc character(len=14), public :: key logical, public :: output Functions function get_topology () Arguments None Return Value logical function get_coordfile (cf, fn, frames) Arguments Type Intent Optional Attributes Name character(len=256), intent(out) :: cf integer, intent(out) :: fn character(len=80) , optional :: frames Return Value logical function load_restart (fn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: fn Return Value logical Subroutines subroutine startup () Arguments None subroutine shutdown () Arguments None subroutine initialize () Arguments None subroutine do_pre_calcs () Arguments None subroutine finalize () Arguments None subroutine calc_help () Arguments None subroutine process_help () Arguments None subroutine finishtrj_all () Arguments None subroutine process_data () Arguments None subroutine process_frame (cf, frame) Arguments Type Intent Optional Attributes Name character(len=*) :: cf integer :: frame subroutine make_mean_all () Arguments None subroutine finalize_topology () Arguments None subroutine add_kind (desc, key, output) Arguments Type Intent Optional Attributes Name character(len=*) :: desc character(len=*) :: key logical :: output subroutine calc_menu () Arguments None subroutine add_calcs () Arguments None subroutine make_ref_all (x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x (:) subroutine list_calcs () Arguments None subroutine add_a_calc (kind) Arguments Type Intent Optional Attributes Name integer :: kind subroutine print_headings () Arguments None subroutine calc_all (frame) Arguments Type Intent Optional Attributes Name integer :: frame","tags":"","loc":"program/qcalc.html","title":"qcalc – Fortran Program"},{"text":"Uses: md mpiglob version dfport Variables Type Attributes Name Initial character(len=*), parameter :: PROGRAM_NAME = 'qdyn' character(len=*), parameter :: PROGRAM_VERSION = '5.7' character(len=*), parameter :: PROGRAM_DATE = '2015-02-22' character(len=10) :: PROGRAM_SUFFIX = '_parallel' character(len=10) :: PROGRAM_SUFFIX = '' integer :: qdyn_ierr integer(kind=4) :: sigret integer(kind=4), parameter :: SIGINT = 2 integer(kind=4), parameter :: SIGKILL = 9 integer(kind=4), parameter :: SIGABRT = 6 Functions function signal (signum, proc, flag) Arguments Type Intent Optional Attributes Name integer(kind=4) :: signum real :: proc integer(kind=4) :: flag Return Value integer(kind=4) Subroutines subroutine startup () Arguments None subroutine shutdown () Arguments None","tags":"","loc":"program/qdyn.html","title":"qdyn – Fortran Program"},{"text":"Uses: nrgy PARSE Variables Type Attributes Name Initial character(len=*), parameter :: PROGRAM_VERSION = '5.7' character(len=*), parameter :: PROGRAM_DATE = '2015-04-01' integer, parameter :: mxpts = 20000000 integer, parameter :: mxbin = 100 integer, parameter :: mxstates = 4 character(len=80) :: filnam character(len=80) :: line integer :: i integer :: j integer :: ifile integer :: ipt integer :: istate integer :: ibin integer :: nfiles integer :: nstates integer :: ERR integer :: nskip integer :: nbins integer :: nmin integer :: idum integer :: noffd integer :: nnoffd integer :: offel integer :: ngroups integer :: iexclg integer :: igrp integer :: mpts integer :: iexclgn integer :: astate integer :: bstate type(OFFDIAG_SAVE), dimension(mxstates) :: offd real(kind=8) :: rt real(kind=8) :: gapmin real(kind=8) :: gapmax real(kind=8) :: sum real(kind=8) :: dv real(kind=8) :: gaprange real(kind=8) :: xint real(kind=8) :: dvg real(kind=8) :: veff1 real(kind=8) :: veff2 real(kind=8) :: dGa real(kind=8) :: dGb real(kind=8) :: dGg real(kind=8) :: alpha_B real(kind=8) :: scale_Hij real(kind=8) :: veff real(kind=8) :: min real(kind=8) :: dlam real(kind=8) :: sumf real(kind=8) :: sumb real(kind=8) :: konst real(kind=8) :: fel real(kind=8) :: nfnr real(kind=8) :: nrnf real(kind=8), dimension(mxbin) :: sumg real(kind=8), dimension(mxbin) :: sumg2 real(kind=8), dimension(mxbin) :: avdvg real(kind=8), dimension(mxbin) :: avc1 real(kind=8), dimension(mxbin) :: avc2 real(kind=8), dimension(mxbin) :: avc11 real(kind=8), dimension(mxbin) :: avc12 real(kind=8), dimension(mxbin) :: avc13 real(kind=8), dimension(mxbin) :: avc21 real(kind=8), dimension(mxbin) :: avc22 real(kind=8), dimension(mxbin) :: avc23 real(kind=8), dimension(mxbin) :: avc31 real(kind=8), dimension(mxbin) :: avc32 real(kind=8), dimension(mxbin) :: avc33 real(kind=8), dimension(mxbin) :: avr real(kind=8), dimension(mxbin,4) :: binsum integer, dimension(mxbin) :: nbinpts integer, dimension(mxbin) :: ptsum type(Q_ENERGIES), dimension(mxstates) :: EQ type(Q_ENERGIES), dimension(mxstates) :: avEQ real(kind=8), dimension(mxstates) :: dvv real(kind=8), dimension(mxstates) :: dGv real(kind=8), dimension(mxstates) :: alfa real(kind=8), dimension(mxstates) :: coeff real(kind=8), dimension(mxstates) :: Vel real(kind=8), dimension(mxstates) :: Vvdw real(kind=8), dimension(3) :: u real(kind=8), dimension(3) :: y real(kind=8), allocatable :: dgf (:) real(kind=8), allocatable :: dgr (:) real(kind=8), allocatable :: dgfsum (:) real(kind=8), allocatable :: dgrsum (:) real(kind=8), allocatable :: dG (:) real(kind=8), allocatable :: dgti (:) real(kind=8), allocatable :: dgtisum (:) real(kind=8), allocatable :: dglu (:) real(kind=8), allocatable :: dglusum (:) real(kind=8), allocatable :: dgbar (:) real(kind=8), allocatable :: dgbarsum (:) real(kind=8), dimension(mxstates,mxstates) :: A real(kind=8), dimension(mxstates,mxstates) :: mu real(kind=8), dimension(mxstates,mxstates) :: eta real(kind=8), dimension(mxstates,mxstates) :: rxy0 real(kind=8), allocatable :: Hij (:,:) real(kind=8), allocatable :: d (:) real(kind=8), allocatable :: e (:) type( FEP_DATA_TYPE ), allocatable :: FEP (:) type( FEP_DATA_TYPE ) :: FEPtmp real(kind=8), dimension(mxstates,mxbin) :: avdvv real(kind=8), dimension(mxstates,mxbin) :: sumv real(kind=8), dimension(mxstates,mxbin) :: sumv2 integer :: f integer :: gas = 0 integer :: error integer :: dummyno real :: dummy character(len=100) :: iline Derived Types type :: FEP_DATA_TYPE Components Type Visibility Attributes Name Initial integer, public :: npts real(kind=8), public :: lambda (mxstates) real(kind=8), public, pointer :: v (:,:) real(kind=8), public, pointer :: r (:,:) real(kind=8), public, pointer :: vg (:) real(kind=8), public, pointer :: gap (:) real(kind=8), public, pointer :: c1 (:) real(kind=8), public, pointer :: c2 (:) Subroutines subroutine prompt (outtxt) Arguments Type Intent Optional Attributes Name character(len=*) :: outtxt subroutine tred2 (A, N, NP, D, E) Arguments Type Intent Optional Attributes Name real(kind=8), , dimension(:,:) :: A integer :: N integer :: NP real(kind=8), , dimension(:) :: D real(kind=8), , dimension(:) :: E subroutine tqli (D, E, N, NP, Z) Arguments Type Intent Optional Attributes Name real(kind=8), , dimension(:) :: D real(kind=8), , dimension(:) :: E integer :: N integer :: NP real(kind=8), , dimension(:,:) :: Z","tags":"","loc":"program/qfep.html","title":"qfep – Fortran Program"},{"text":"Uses: iso_fortran_env prep avetr (c) 2015 Uppsala Molekylmekaniska HB, Uppsala, Sweden\n  program: qprep.f90\n  by Johan Aqvist & John Marelius\n  qprep topology preparation main program Variables Type Attributes Name Initial character(len=*), parameter :: PROGRAM_NAME = 'qprep' character(len=*), parameter :: PROGRAM_VERSION = '5.7' character(len=*), parameter :: PROGRAM_DATE = '2015-04-01' character(len=*), parameter :: PROGRAM_SUFFIX = '' character(len=*), parameter :: options = compiler_options() logical :: use_inputfile character(len=200) :: fileName = '' character(len=32) :: arg integer :: i Functions function check_inputfile (infilename) Arguments Type Intent Optional Attributes Name character(len=200), intent(out) :: infilename Return Value logical Description Determine if qprep is to be run from command line or from input file Subroutines subroutine qprep_from_inputfile (filename) Arguments Type Intent Optional Attributes Name character(len=200) :: filename Description Read input from file and execute commands subroutine qprep_from_commandline () Arguments None Description Read input from command line and execute commands subroutine parse_command (command) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: command Description Parse a command and call corresponding subroutine subroutine help () Arguments None Description Give help on commands subroutine startup () Arguments None Description Startup subroutine subroutine shutdown () Arguments None Description Shutdown subroutine subroutine commandlineoptions () Arguments None Description subroutine: commandlineoptions subroutine print_help () Arguments None Description subroutine: print_help","tags":"","loc":"program/qprep.html","title":"qprep – Fortran Program"}]}